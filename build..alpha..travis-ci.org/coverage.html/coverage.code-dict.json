{"/home/travis/build/npmtest/node-npmtest-tslint/test.js":"/* istanbul instrument in package npmtest_tslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tslint/lib.npmtest_tslint.js":"/* istanbul instrument in package npmtest_tslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tslint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tslint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tslint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tslint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tslint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tslint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_tslint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tslint.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_tslint.__dirname + '/lib.npmtest_tslint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/index.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Configuration = require(\"./configuration\");\nexports.Configuration = Configuration;\nvar Formatters = require(\"./formatters\");\nexports.Formatters = Formatters;\nvar Linter = require(\"./linter\");\nexports.Linter = Linter;\nvar Rules = require(\"./rules\");\nexports.Rules = Rules;\nvar Test = require(\"./test\");\nexports.Test = Test;\nvar Utils = require(\"./utils\");\nexports.Utils = Utils;\n__export(require(\"./language/rule/rule\"));\n__export(require(\"./enableDisableRules\"));\n__export(require(\"./formatterLoader\"));\n__export(require(\"./ruleLoader\"));\n__export(require(\"./language/utils\"));\n__export(require(\"./language/walker\"));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/configuration.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar findup = require(\"findup-sync\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar resolve = require(\"resolve\");\nvar error_1 = require(\"./error\");\nvar utils_1 = require(\"./utils\");\nexports.CONFIG_FILENAME = \"tslint.json\";\nexports.DEFAULT_CONFIG = {\n    defaultSeverity: \"error\",\n    extends: [\"tslint:recommended\"],\n    jsRules: new Map(),\n    rules: new Map(),\n    rulesDirectory: [],\n};\nexports.EMPTY_CONFIG = {\n    defaultSeverity: \"error\",\n    extends: [],\n    jsRules: new Map(),\n    rules: new Map(),\n    rulesDirectory: [],\n};\nvar BUILT_IN_CONFIG = /^tslint:(.*)$/;\n/**\n * Searches for a TSLint configuration and returns the data from the config.\n * @param configFile A path to a config file, this can be null if the location of a config is not known\n * @param inputFileLocation A path to the current file being linted. This is the starting location\n * of the search for a configuration.\n * @returns Load status for a TSLint configuration object\n */\nfunction findConfiguration(configFile, inputFilePath) {\n    var path = findConfigurationPath(configFile, inputFilePath);\n    var loadResult = { path: path };\n    try {\n        loadResult.results = loadConfigurationFromPath(path);\n        return loadResult;\n    }\n    catch (error) {\n        throw new error_1.FatalError(\"Failed to load \" + path + \": \" + error.message, error);\n    }\n}\nexports.findConfiguration = findConfiguration;\n/**\n * Searches for a TSLint configuration and returns the path to it.\n * Could return undefined if not configuration is found.\n * @param suppliedConfigFilePath A path to an known config file supplied by a user. Pass null here if\n * the location of the config file is not known and you want to search for one.\n * @param inputFilePath A path to the current file being linted. This is the starting location\n * of the search for a configuration.\n * @returns An absolute path to a tslint.json file\n * or undefined if neither can be found.\n */\nfunction findConfigurationPath(suppliedConfigFilePath, inputFilePath) {\n    if (suppliedConfigFilePath != null) {\n        if (!fs.existsSync(suppliedConfigFilePath)) {\n            throw new Error(\"Could not find config file at: \" + path.resolve(suppliedConfigFilePath));\n        }\n        else {\n            return path.resolve(suppliedConfigFilePath);\n        }\n    }\n    else {\n        // search for tslint.json from input file location\n        var configFilePath = findup(exports.CONFIG_FILENAME, { cwd: inputFilePath, nocase: true });\n        if (configFilePath != null && fs.existsSync(configFilePath)) {\n            return path.resolve(configFilePath);\n        }\n        // search for tslint.json in home directory\n        var homeDir = getHomeDir();\n        if (homeDir != null) {\n            configFilePath = path.join(homeDir, exports.CONFIG_FILENAME);\n            if (fs.existsSync(configFilePath)) {\n                return path.resolve(configFilePath);\n            }\n        }\n        // no path could be found\n        return undefined;\n    }\n}\nexports.findConfigurationPath = findConfigurationPath;\n/**\n * Used Node semantics to load a configuration file given configFilePath.\n * For example:\n * '/path/to/config' will be treated as an absolute path\n * './path/to/config' will be treated as a relative path\n * 'path/to/config' will attempt to load a to/config file inside a node module named path\n * @returns a configuration object for TSLint loaded from the file at configFilePath\n */\nfunction loadConfigurationFromPath(configFilePath) {\n    if (configFilePath == null) {\n        return exports.DEFAULT_CONFIG;\n    }\n    else {\n        var resolvedConfigFilePath = resolveConfigurationPath(configFilePath);\n        var rawConfigFile = void 0;\n        if (path.extname(resolvedConfigFilePath) === \".json\") {\n            var fileContent = utils_1.stripComments(fs.readFileSync(resolvedConfigFilePath)\n                .toString()\n                .replace(/^\\uFEFF/, \"\"));\n            rawConfigFile = JSON.parse(fileContent);\n        }\n        else {\n            rawConfigFile = require(resolvedConfigFilePath);\n            delete require.cache[resolvedConfigFilePath];\n        }\n        var configFileDir_1 = path.dirname(resolvedConfigFilePath);\n        var configFile = parseConfigFile(rawConfigFile, configFileDir_1);\n        // load configurations, in order, using their identifiers or relative paths\n        // apply the current configuration last by placing it last in this array\n        var configs = configFile.extends.map(function (name) {\n            var nextConfigFilePath = resolveConfigurationPath(name, configFileDir_1);\n            return loadConfigurationFromPath(nextConfigFilePath);\n        }).concat([configFile]);\n        return configs.reduce(extendConfigurationFile, exports.EMPTY_CONFIG);\n    }\n}\nexports.loadConfigurationFromPath = loadConfigurationFromPath;\n/**\n * Resolve configuration file path or node_module reference\n * @param filePath Relative (\"./path\"), absolute (\"/path\"), node module (\"path\"), or built-in (\"tslint:path\")\n */\nfunction resolveConfigurationPath(filePath, relativeTo) {\n    var matches = filePath.match(BUILT_IN_CONFIG);\n    var isBuiltInConfig = matches != null && matches.length > 0;\n    if (isBuiltInConfig) {\n        var configName = matches[1];\n        try {\n            return require.resolve(\"./configs/\" + configName);\n        }\n        catch (err) {\n            throw new Error(filePath + \" is not a built-in config, try \\\"tslint:recommended\\\" instead.\");\n        }\n    }\n    var basedir = relativeTo || process.cwd();\n    try {\n        return resolve.sync(filePath, { basedir: basedir });\n    }\n    catch (err) {\n        try {\n            return require.resolve(filePath);\n        }\n        catch (err) {\n            throw new Error(\"Invalid \\\"extends\\\" configuration value - could not require \\\"\" + filePath + \"\\\". \" +\n                \"Review the Node lookup algorithm (https://nodejs.org/api/modules.html#modules_all_together) \" +\n                \"for the approximate method TSLint uses to find the referenced configuration file.\");\n        }\n    }\n}\nfunction extendConfigurationFile(targetConfig, nextConfigSource) {\n    var combineProperties = function (targetProperty, nextProperty) {\n        var combinedProperty = {};\n        for (var _i = 0, _a = Object.keys(utils_1.objectify(targetProperty)); _i < _a.length; _i++) {\n            var name = _a[_i];\n            combinedProperty[name] = targetProperty[name];\n        }\n        // next config source overwrites the target config object\n        for (var _b = 0, _c = Object.keys(utils_1.objectify(nextProperty)); _b < _c.length; _b++) {\n            var name = _c[_b];\n            combinedProperty[name] = nextProperty[name];\n        }\n        return combinedProperty;\n    };\n    var combineMaps = function (target, next) {\n        var combined = new Map();\n        target.forEach(function (options, ruleName) {\n            combined.set(ruleName, options);\n        });\n        next.forEach(function (options, ruleName) {\n            var combinedRule = combined.get(ruleName);\n            if (combinedRule != null) {\n                combined.set(ruleName, combineProperties(combinedRule, options));\n            }\n            else {\n                combined.set(ruleName, options);\n            }\n        });\n        return combined;\n    };\n    var combinedRulesDirs = targetConfig.rulesDirectory.concat(nextConfigSource.rulesDirectory);\n    var dedupedRulesDirs = Array.from(new Set(combinedRulesDirs));\n    return {\n        extends: [],\n        jsRules: combineMaps(targetConfig.jsRules, nextConfigSource.jsRules),\n        linterOptions: combineProperties(targetConfig.linterOptions, nextConfigSource.linterOptions),\n        rules: combineMaps(targetConfig.rules, nextConfigSource.rules),\n        rulesDirectory: dedupedRulesDirs,\n    };\n}\nexports.extendConfigurationFile = extendConfigurationFile;\nfunction getHomeDir() {\n    var environment = global.process.env;\n    var paths = [\n        environment.USERPROFILE,\n        environment.HOME,\n        environment.HOMEPATH,\n        environment.HOMEDRIVE + environment.HOMEPATH,\n    ];\n    for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {\n        var homePath = paths_1[_i];\n        if (homePath != null && fs.existsSync(homePath)) {\n            return homePath;\n        }\n    }\n}\n// returns the absolute path (contrary to what the name implies)\nfunction getRelativePath(directory, relativeTo) {\n    if (directory != null) {\n        var basePath = relativeTo || process.cwd();\n        return path.resolve(basePath, directory);\n    }\n    return undefined;\n}\nexports.getRelativePath = getRelativePath;\n/**\n * @param directories A path(s) to a directory of custom rules\n * @param relativeTo A path that directories provided are relative to.\n * For example, if the directories come from a tslint.json file, this path\n * should be the path to the tslint.json file.\n * @return An array of absolute paths to directories potentially containing rules\n */\nfunction getRulesDirectories(directories, relativeTo) {\n    var rulesDirectories = utils_1.arrayify(directories)\n        .map(function (dir) { return getRelativePath(dir, relativeTo); })\n        .filter(function (dir) { return dir !== undefined; });\n    for (var _i = 0, rulesDirectories_1 = rulesDirectories; _i < rulesDirectories_1.length; _i++) {\n        var directory = rulesDirectories_1[_i];\n        if (directory != null && !fs.existsSync(directory)) {\n            throw new Error(\"Could not find custom rule directory: \" + directory);\n        }\n    }\n    return rulesDirectories;\n}\nexports.getRulesDirectories = getRulesDirectories;\n/**\n * Parses the options of a single rule and upgrades legacy settings such as `true`, `[true, \"option\"]`\n *\n * @param ruleConfigValue The raw option setting of a rule\n */\nfunction parseRuleOptions(ruleConfigValue, rawDefaultRuleSeverity) {\n    var ruleArguments;\n    var ruleSeverity;\n    var defaultRuleSeverity = \"error\";\n    if (rawDefaultRuleSeverity) {\n        switch (rawDefaultRuleSeverity.toLowerCase()) {\n            case \"warn\":\n            case \"warning\":\n                defaultRuleSeverity = \"warning\";\n                break;\n            case \"off\":\n            case \"none\":\n                defaultRuleSeverity = \"off\";\n                break;\n            default:\n                defaultRuleSeverity = \"error\";\n        }\n    }\n    if (ruleConfigValue == null) {\n        ruleArguments = [];\n        ruleSeverity = \"off\";\n    }\n    else if (Array.isArray(ruleConfigValue) && ruleConfigValue.length > 0) {\n        // old style: array\n        ruleArguments = ruleConfigValue.slice(1);\n        ruleSeverity = ruleConfigValue[0] === true ? defaultRuleSeverity : \"off\";\n    }\n    else if (typeof ruleConfigValue === \"boolean\") {\n        // old style: boolean\n        ruleArguments = [];\n        ruleSeverity = ruleConfigValue === true ? defaultRuleSeverity : \"off\";\n    }\n    else if (ruleConfigValue.severity) {\n        switch (ruleConfigValue.severity.toLowerCase()) {\n            case \"default\":\n                ruleSeverity = defaultRuleSeverity;\n                break;\n            case \"error\":\n                ruleSeverity = \"error\";\n                break;\n            case \"warn\":\n            case \"warning\":\n                ruleSeverity = \"warning\";\n                break;\n            case \"off\":\n            case \"none\":\n                ruleSeverity = \"off\";\n                break;\n            default:\n                console.warn(\"Invalid severity level: \" + ruleConfigValue.severity);\n                ruleSeverity = defaultRuleSeverity;\n        }\n    }\n    else {\n        ruleSeverity = defaultRuleSeverity;\n    }\n    if (ruleConfigValue && ruleConfigValue.options) {\n        ruleArguments = utils_1.arrayify(ruleConfigValue.options);\n    }\n    return {\n        ruleArguments: ruleArguments,\n        ruleSeverity: ruleSeverity,\n    };\n}\n/**\n * Parses a config file and normalizes legacy config settings\n *\n * @param configFile The raw object read from the JSON of a config file\n * @param configFileDir The directory of the config file\n */\nfunction parseConfigFile(configFile, configFileDir) {\n    var rules = new Map();\n    var jsRules = new Map();\n    if (configFile.rules) {\n        for (var ruleName in configFile.rules) {\n            if (configFile.rules.hasOwnProperty(ruleName)) {\n                rules.set(ruleName, parseRuleOptions(configFile.rules[ruleName], configFile.defaultSeverity));\n            }\n        }\n    }\n    if (configFile.jsRules) {\n        for (var ruleName in configFile.jsRules) {\n            if (configFile.jsRules.hasOwnProperty(ruleName)) {\n                jsRules.set(ruleName, parseRuleOptions(configFile.jsRules[ruleName], configFile.defaultSeverity));\n            }\n        }\n    }\n    return {\n        extends: utils_1.arrayify(configFile.extends),\n        jsRules: jsRules,\n        linterOptions: configFile.linterOptions || {},\n        rulesDirectory: getRulesDirectories(configFile.rulesDirectory, configFileDir),\n        rules: rules,\n    };\n}\nexports.parseConfigFile = parseConfigFile;\n/**\n * Fills in default values for `IOption` properties and outputs an array of `IOption`\n */\nfunction convertRuleOptions(ruleConfiguration) {\n    var output = [];\n    ruleConfiguration.forEach(function (partialOptions, ruleName) {\n        var options = {\n            disabledIntervals: [],\n            ruleArguments: partialOptions.ruleArguments || [],\n            ruleName: ruleName,\n            ruleSeverity: partialOptions.ruleSeverity || \"error\",\n        };\n        output.push(options);\n    });\n    return output;\n}\nexports.convertRuleOptions = convertRuleOptions;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/error.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shownWarnings = new Set();\n/**\n * Used to exit the program and display a friendly message without the callstack.\n */\nvar FatalError = (function (_super) {\n    __extends(FatalError, _super);\n    function FatalError(message, innerError) {\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        _this.innerError = innerError;\n        _this.name = FatalError.NAME;\n        _this.stack = new Error().stack;\n        return _this;\n    }\n    return FatalError;\n}(Error));\nFatalError.NAME = \"FatalError\";\nexports.FatalError = FatalError;\nfunction isError(possibleError) {\n    return possibleError != null && possibleError.message !== undefined;\n}\nexports.isError = isError;\nfunction showWarningOnce(message) {\n    if (!shownWarnings.has(message)) {\n        console.warn(message);\n        shownWarnings.add(message);\n    }\n}\nexports.showWarningOnce = showWarningOnce;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/utils.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Enforces the invariant that the input is an array.\n */\nfunction arrayify(arg) {\n    if (Array.isArray(arg)) {\n        return arg;\n    }\n    else if (arg != null) {\n        return [arg];\n    }\n    else {\n        return [];\n    }\n}\nexports.arrayify = arrayify;\n/**\n * Enforces the invariant that the input is an object.\n */\nfunction objectify(arg) {\n    if (typeof arg === \"object\" && arg != null) {\n        return arg;\n    }\n    else {\n        return {};\n    }\n}\nexports.objectify = objectify;\n/**\n * Replace hyphens in a rule name by upper-casing the letter after them.\n * E.g. \"foo-bar\" -> \"fooBar\"\n */\nfunction camelize(stringWithHyphens) {\n    return stringWithHyphens.replace(/-(.)/g, function (_, nextLetter) { return nextLetter.toUpperCase(); });\n}\nexports.camelize = camelize;\n/**\n * Removes leading indents from a template string without removing all leading whitespace\n */\nfunction dedent(strings) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    var fullString = strings.reduce(function (accumulator, str, i) {\n        return accumulator + values[i - 1] + str;\n    });\n    // match all leading spaces/tabs at the start of each line\n    var match = fullString.match(/^[ \\t]*(?=\\S)/gm);\n    if (!match) {\n        // e.g. if the string is empty or all whitespace.\n        return fullString;\n    }\n    // find the smallest indent, we don't want to remove all leading whitespace\n    var indent = Math.min.apply(Math, match.map(function (el) { return el.length; }));\n    var regexp = new RegExp(\"^[ \\\\t]{\" + indent + \"}\", \"gm\");\n    fullString = indent > 0 ? fullString.replace(regexp, \"\") : fullString;\n    return fullString;\n}\nexports.dedent = dedent;\n/**\n * Strip comments from file content.\n */\nfunction stripComments(content) {\n    /**\n     * First capturing group matches double quoted string\n     * Second matches single quotes string\n     * Third matches block comments\n     * Fourth matches line comments\n     */\n    var regexp = /(\"(?:[^\\\\\\\"]*(?:\\\\.)?)*\")|('(?:[^\\\\\\']*(?:\\\\.)?)*')|(\\/\\*(?:\\r?\\n|.)*?\\*\\/)|(\\/{2,}.*?(?:(?:\\r?\\n)|$))/g;\n    var result = content.replace(regexp, function (match, _m1, _m2, m3, m4) {\n        // Only one of m1, m2, m3, m4 matches\n        if (m3) {\n            // A block comment. Replace with nothing\n            return \"\";\n        }\n        else if (m4) {\n            // A line comment. If it ends in \\r?\\n then keep it.\n            var length = m4.length;\n            if (length > 2 && m4[length - 1] === \"\\n\") {\n                return m4[length - 2] === \"\\r\" ? \"\\r\\n\" : \"\\n\";\n            }\n            else {\n                return \"\";\n            }\n        }\n        else {\n            // We match a string\n            return match;\n        }\n    });\n    return result;\n}\nexports.stripComments = stripComments;\n/**\n * Escapes all special characters in RegExp pattern to avoid broken regular expressions and ensure proper matches\n */\nfunction escapeRegExp(re) {\n    return re.replace(/[.+*?|^$[\\]{}()\\\\]/g, \"\\\\$&\");\n}\nexports.escapeRegExp = escapeRegExp;\nfunction arraysAreEqual(a, b, eq) {\n    return a === b || !!a && !!b && a.length === b.length && a.every(function (x, idx) { return eq(x, b[idx]); });\n}\nexports.arraysAreEqual = arraysAreEqual;\n/** Returns an array that is the concatenation of all output arrays. */\nfunction flatMap(inputs, getOutputs) {\n    var out = [];\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input = inputs_1[_i];\n        out.push.apply(out, getOutputs(input));\n    }\n    return out;\n}\nexports.flatMap = flatMap;\n/** Returns an array of all outputs that are not `undefined`. */\nfunction mapDefined(inputs, getOutput) {\n    var out = [];\n    for (var _i = 0, inputs_2 = inputs; _i < inputs_2.length; _i++) {\n        var input = inputs_2[_i];\n        var output = getOutput(input);\n        if (output !== undefined) {\n            out.push(output);\n        }\n    }\n    return out;\n}\nexports.mapDefined = mapDefined;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./language/formatter/abstractFormatter\"));\n__export(require(\"./formatters/index\"));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/formatter/abstractFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractFormatter = (function () {\n    function AbstractFormatter() {\n    }\n    return AbstractFormatter;\n}());\nexports.AbstractFormatter = AbstractFormatter;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/index.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar jsonFormatter_1 = require(\"./jsonFormatter\");\nexports.JsonFormatter = jsonFormatter_1.Formatter;\nvar pmdFormatter_1 = require(\"./pmdFormatter\");\nexports.PmdFormatter = pmdFormatter_1.Formatter;\nvar proseFormatter_1 = require(\"./proseFormatter\");\nexports.ProseFormatter = proseFormatter_1.Formatter;\nvar verboseFormatter_1 = require(\"./verboseFormatter\");\nexports.VerboseFormatter = verboseFormatter_1.Formatter;\nvar stylishFormatter_1 = require(\"./stylishFormatter\");\nexports.StylishFormatter = stylishFormatter_1.Formatter;\nvar fileslistFormatter_1 = require(\"./fileslistFormatter\");\nexports.FileslistFormatter = fileslistFormatter_1.Formatter;\nvar codeFrameFormatter_1 = require(\"./codeFrameFormatter\");\nexports.CodeFrameFormatter = codeFrameFormatter_1.Formatter;\nvar tapFormatter_1 = require(\"./tapFormatter\");\nexports.TapFormatter = tapFormatter_1.Formatter;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/jsonFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        var failuresJSON = failures.map(function (failure) { return failure.toJson(); });\n        return JSON.stringify(failuresJSON);\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"json\",\n    description: \"Formats errors as simple JSON.\",\n    sample: (_a = [\"\\n        [\\n            {\\n                \\\"endPosition\\\": {\\n                    \\\"character\\\": 13,\\n                    \\\"line\\\": 0,\\n                    \\\"position\\\": 13\\n                },\\n                \\\"failure\\\": \\\"Missing semicolon\\\",\\n                \\\"fix\\\": {\\n                    \\\"innerStart\\\": 13,\\n                    \\\"innerLength\\\": 0,\\n                    \\\"innerText\\\": \\\";\\\"\\n                },\\n                \\\"name\\\": \\\"myFile.ts\\\",\\n                \\\"ruleName\\\": \\\"semicolon\\\",\\n                \\\"startPosition\\\": {\\n                    \\\"character\\\": 13,\\n                    \\\"line\\\": 0,\\n                    \\\"position\\\": 13\\n                }\\n            }\\n        ]\"], _a.raw = [\"\\n        [\\n            {\\n                \\\"endPosition\\\": {\\n                    \\\"character\\\": 13,\\n                    \\\"line\\\": 0,\\n                    \\\"position\\\": 13\\n                },\\n                \\\"failure\\\": \\\"Missing semicolon\\\",\\n                \\\"fix\\\": {\\n                    \\\"innerStart\\\": 13,\\n                    \\\"innerLength\\\": 0,\\n                    \\\"innerText\\\": \\\";\\\"\\n                },\\n                \\\"name\\\": \\\"myFile.ts\\\",\\n                \\\"ruleName\\\": \\\"semicolon\\\",\\n                \\\"startPosition\\\": {\\n                    \\\"character\\\": 13,\\n                    \\\"line\\\": 0,\\n                    \\\"position\\\": 13\\n                }\\n            }\\n        ]\"], Utils.dedent(_a)),\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/pmdFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        var output = \"<pmd version=\\\"tslint\\\">\";\n        for (var _i = 0, failures_1 = failures; _i < failures_1.length; _i++) {\n            var failure = failures_1[_i];\n            var failureString = failure.getFailure()\n                .replace(/&/g, \"&amp;\")\n                .replace(/</g, \"&lt;\")\n                .replace(/>/g, \"&gt;\")\n                .replace(/'/g, \"&#39;\")\n                .replace(/\"/g, \"&quot;\");\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var priority = failure.getRuleSeverity() === \"warning\" ? 4 : 3;\n            output += \"<file name=\\\"\" + failure.getFileName();\n            output += \"\\\"><violation begincolumn=\\\"\" + (lineAndCharacter.character + 1);\n            output += \"\\\" beginline=\\\"\" + (lineAndCharacter.line + 1);\n            output += \"\\\" priority=\\\"\" + priority + \"\\\"\";\n            output += \" rule=\\\"\" + failureString + \"\\\"> </violation></file>\";\n        }\n        output += \"</pmd>\";\n        return output;\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"pmd\",\n    description: \"Formats errors as through they were PMD output.\",\n    descriptionDetails: \"Imitates the XML output from PMD. All errors have a priority of 1.\",\n    sample: (_a = [\"\\n        <pmd version=\\\"tslint\\\">\\n            <file name=\\\"myFile.ts\\\">\\n                <violation begincolumn=\\\"14\\\" beginline=\\\"1\\\" priority=\\\"3\\\" rule=\\\"Missing semicolon\\\"></violation>\\n            </file>\\n        </pmd>\"], _a.raw = [\"\\n        <pmd version=\\\"tslint\\\">\\n            <file name=\\\"myFile.ts\\\">\\n                <violation begincolumn=\\\"14\\\" beginline=\\\"1\\\" priority=\\\"3\\\" rule=\\\"Missing semicolon\\\"></violation>\\n            </file>\\n        </pmd>\"], Utils.dedent(_a)),\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/proseFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures, fixes) {\n        if (failures.length === 0 && (!fixes || fixes.length === 0)) {\n            return \"\\n\";\n        }\n        var fixLines = [];\n        if (fixes) {\n            var perFileFixes = new Map();\n            for (var _i = 0, fixes_1 = fixes; _i < fixes_1.length; _i++) {\n                var fix = fixes_1[_i];\n                perFileFixes.set(fix.getFileName(), (perFileFixes.get(fix.getFileName()) || 0) + 1);\n            }\n            perFileFixes.forEach(function (fixCount, fixedFile) {\n                fixLines.push(\"Fixed \" + fixCount + \" error(s) in \" + fixedFile);\n            });\n            fixLines.push(\"\"); // add a blank line between fixes and failures\n        }\n        var errorLines = failures.map(function (failure) {\n            var fileName = failure.getFileName();\n            var failureString = failure.getFailure();\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var positionTuple = \"[\" + (lineAndCharacter.line + 1) + \", \" + (lineAndCharacter.character + 1) + \"]\";\n            return failure.getRuleSeverity().toUpperCase() + \": \" + fileName + positionTuple + \": \" + failureString;\n        });\n        return fixLines.concat(errorLines).join(\"\\n\") + \"\\n\";\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"prose\",\n    description: \"The default formatter which outputs simple human-readable messages.\",\n    sample: \"ERROR: myFile.ts[1, 14]: Missing semicolon\",\n    consumer: \"human\",\n};\nexports.Formatter = Formatter;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/verboseFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        return this.mapToMessages(failures)\n            .join(\"\\n\") + \"\\n\";\n    };\n    Formatter.prototype.mapToMessages = function (failures) {\n        return failures.map(function (failure) {\n            var fileName = failure.getFileName();\n            var failureString = failure.getFailure();\n            var ruleName = failure.getRuleName();\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var positionTuple = \"[\" + (lineAndCharacter.line + 1) + \", \" + (lineAndCharacter.character + 1) + \"]\";\n            return failure.getRuleSeverity().toUpperCase() + \": (\" + ruleName + \") \" + fileName + positionTuple + \": \" + failureString;\n        });\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"verbose\",\n    description: \"The human-readable formatter which includes the rule name in messages.\",\n    descriptionDetails: \"The output is the same as the prose formatter with the rule name included\",\n    sample: \"ERROR: (semicolon) myFile.ts[1, 14]: Missing semicolon\",\n    consumer: \"human\",\n};\nexports.Formatter = Formatter;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/stylishFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar colors = require(\"colors\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        var outputLines = this.mapToMessages(failures);\n        // Removes initial blank line\n        if (outputLines[0] === \"\") {\n            outputLines.shift();\n        }\n        return outputLines.join(\"\\n\") + \"\\n\";\n    };\n    Formatter.prototype.mapToMessages = function (failures) {\n        if (!failures) {\n            return [];\n        }\n        var outputLines = [];\n        var positionMaxSize = this.getPositionMaxSize(failures);\n        var ruleMaxSize = this.getRuleMaxSize(failures);\n        var currentFile;\n        for (var _i = 0, failures_1 = failures; _i < failures_1.length; _i++) {\n            var failure = failures_1[_i];\n            var fileName = failure.getFileName();\n            // Output the name of each file once\n            if (currentFile !== fileName) {\n                outputLines.push(\"\");\n                outputLines.push(fileName);\n                currentFile = fileName;\n            }\n            var failureString = failure.getFailure();\n            failureString = colors.yellow(failureString);\n            // Rule\n            var ruleName = failure.getRuleName();\n            ruleName = this.pad(ruleName, ruleMaxSize);\n            ruleName = colors.grey(ruleName);\n            // Lines\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var positionTuple = lineAndCharacter.line + 1 + \":\" + (lineAndCharacter.character + 1);\n            positionTuple = this.pad(positionTuple, positionMaxSize);\n            if (failure.getRuleSeverity() === \"warning\") {\n                positionTuple = colors.blue(failure.getRuleSeverity().toUpperCase() + \": \" + positionTuple);\n            }\n            else {\n                positionTuple = colors.red(failure.getRuleSeverity().toUpperCase() + \": \" + positionTuple);\n            }\n            // Output\n            var output = positionTuple + \"  \" + ruleName + \"  \" + failureString;\n            outputLines.push(output);\n        }\n        return outputLines;\n    };\n    Formatter.prototype.pad = function (str, len) {\n        var padder = Array(len + 1).join(\" \");\n        return (str + padder).substring(0, padder.length);\n    };\n    Formatter.prototype.getPositionMaxSize = function (failures) {\n        var positionMaxSize = 0;\n        for (var _i = 0, failures_2 = failures; _i < failures_2.length; _i++) {\n            var failure = failures_2[_i];\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var positionSize = (lineAndCharacter.line + 1 + \":\" + (lineAndCharacter.character + 1)).length;\n            if (positionSize > positionMaxSize) {\n                positionMaxSize = positionSize;\n            }\n        }\n        return positionMaxSize;\n    };\n    Formatter.prototype.getRuleMaxSize = function (failures) {\n        var ruleMaxSize = 0;\n        for (var _i = 0, failures_3 = failures; _i < failures_3.length; _i++) {\n            var failure = failures_3[_i];\n            var ruleSize = failure.getRuleName().length;\n            if (ruleSize > ruleMaxSize) {\n                ruleMaxSize = ruleSize;\n            }\n        }\n        return ruleMaxSize;\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"stylish\",\n    description: \"Human-readable formatter which creates stylish messages.\",\n    descriptionDetails: (_a = [\"\\n            The output matches that produced by eslint's stylish formatter. Its readability\\n            enhanced through spacing and colouring\"], _a.raw = [\"\\n            The output matches that produced by eslint's stylish formatter. Its readability\\n            enhanced through spacing and colouring\"], Utils.dedent(_a)),\n    sample: (_b = [\"\\n        myFile.ts\\n        1:14  semicolon  Missing semicolon\"], _b.raw = [\"\\n        myFile.ts\\n        1:14  semicolon  Missing semicolon\"], Utils.dedent(_b)),\n    consumer: \"human\",\n};\nexports.Formatter = Formatter;\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/fileslistFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        if (failures.length === 0) {\n            return \"\";\n        }\n        var files = [];\n        var currentFile;\n        for (var _i = 0, failures_1 = failures; _i < failures_1.length; _i++) {\n            var failure = failures_1[_i];\n            var fileName = failure.getFileName();\n            if (fileName !== currentFile) {\n                files.push(fileName);\n                currentFile = fileName;\n            }\n        }\n        return files.join(\"\\n\") + \"\\n\";\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"filesList\",\n    description: \"Lists files containing lint errors.\",\n    sample: \"directory/myFile.ts\",\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/codeFrameFormatter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar codeFrame = require(\"babel-code-frame\");\nvar colors = require(\"colors\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        if (typeof failures[0] === \"undefined\") {\n            return \"\\n\";\n        }\n        var outputLines = [];\n        var currentFile;\n        for (var _i = 0, failures_1 = failures; _i < failures_1.length; _i++) {\n            var failure = failures_1[_i];\n            var fileName = failure.getFileName();\n            // Output the name of each file once\n            if (currentFile !== fileName) {\n                outputLines.push(\"\");\n                outputLines.push(fileName);\n                currentFile = fileName;\n            }\n            var failureString = failure.getFailure();\n            failureString = colors.red(failureString);\n            // Rule\n            var ruleName = failure.getRuleName();\n            ruleName = colors.gray(\"(\" + ruleName + \")\");\n            // Frame\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var frame = codeFrame(failure.getRawLines(), lineAndCharacter.line + 1, // babel-code-frame is 1 index\n            lineAndCharacter.character, {\n                forceColor: colors.enabled,\n                highlightCode: true,\n            });\n            // Ouput\n            outputLines.push(failureString + \" \" + ruleName);\n            outputLines.push(frame);\n            outputLines.push(\"\");\n        }\n        // Removes initial blank line\n        if (outputLines[0] === \"\") {\n            outputLines.shift();\n        }\n        return outputLines.join(\"\\n\") + \"\\n\";\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"codeFrame\",\n    description: \"Framed formatter which creates a frame of error code.\",\n    descriptionDetails: (_a = [\"\\n            Prints syntax highlighted code in a frame with a pointer to where\\n            exactly lint error is happening.\"], _a.raw = [\"\\n            Prints syntax highlighted code in a frame with a pointer to where\\n            exactly lint error is happening.\"], Utils.dedent(_a)),\n    sample: (_b = [\"\\n            src/components/Payment.tsx\\n            Parentheses are required around the parameters of an arrow function definition (arrow-parens)\\n              21 |     public componentDidMount() {\\n              22 |         this.input.focus();\\n            > 23 |         loadStripe().then(Stripe => Stripe.pay());\\n                 |                          ^\\n              24 |     }\\n              25 |\\n              26 |     public render() {\"], _b.raw = [\"\\n            src/components/Payment.tsx\\n            Parentheses are required around the parameters of an arrow function definition (arrow-parens)\\n              21 |     public componentDidMount() {\\n              22 |         this.input.focus();\\n            > 23 |         loadStripe().then(Stripe => Stripe.pay());\\n                 |                          ^\\n              24 |     }\\n              25 |\\n              26 |     public render() {\"], Utils.dedent(_b)),\n    consumer: \"human\",\n};\nexports.Formatter = Formatter;\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/tapFormatter.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        var output = [\"TAP version 13\"];\n        if (failures.length === 0) {\n            output = output.concat([\n                \"1..0 # SKIP No failures\",\n            ]);\n        }\n        else {\n            output = output.concat([\"1..\" + failures.length]).concat(this.mapToMessages(failures));\n        }\n        return output.join(\"\\n\") + \"\\n\";\n    };\n    Formatter.prototype.mapToMessages = function (failures) {\n        return failures.map(function (failure, i) {\n            var fileName = failure.getFileName();\n            var failureString = failure.getFailure();\n            var ruleName = failure.getRuleName();\n            var failureMessage = failure.getFailure();\n            var failureSeverity = failure.getRuleSeverity();\n            var failureRaw = failure.getRawLines();\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            return (_a = [\"\\n                not ok \", \" - \", \"\\n                  ---\\n                  message : \", \"\\n                  severity: \", \"\\n                  data:\\n                    ruleName: \", \"\\n                    fileName: \", \"\\n                    line: \", \"\\n                    character: \", \"\\n                    failureString: \", \"\\n                    rawLines: \", \"\\n                  ...\"], _a.raw = [\"\\n                not ok \", \" - \", \"\\n                  ---\\n                  message : \", \"\\n                  severity: \", \"\\n                  data:\\n                    ruleName: \", \"\\n                    fileName: \", \"\\n                    line: \", \"\\n                    character: \", \"\\n                    failureString: \", \"\\n                    rawLines: \", \"\\n                  ...\"], Utils.dedent(_a, String(i + 1), failureMessage, failureMessage, failureSeverity, ruleName, fileName, String(lineAndCharacter.line), String(lineAndCharacter.character), failureString, failureRaw));\n            var _a;\n        });\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"tap\",\n    description: \"Formats output as TAP stream.\",\n    descriptionDetails: \"Provides error messages output in TAP13 format which can be consumed by any TAP formatter.\",\n    sample: (_a = [\"\\n            TAP version 13\\n            1..1\\n            not ok 1 - Some error\\n              ---\\n              message: Variable has any type\\n              severity: error\\n              data:\\n                 ruleName: no-any\\n                 fileName: test-file.ts\\n                 line: 10\\n                 character: 10\\n                 failureString: Some error\\n                 rawLines: Some raw output\\n              ...\"], _a.raw = [\"\\n            TAP version 13\\n            1..1\\n            not ok 1 - Some error\\n              ---\\n              message: Variable has any type\\n              severity: error\\n              data:\\n                 ruleName: no-any\\n                 fileName: test-file.ts\\n                 line: 10\\n                 character: 10\\n                 failureString: Some error\\n                 rawLines: Some raw output\\n              ...\"], Utils.dedent(_a)),\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/linter.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar ts = require(\"typescript\");\nvar configuration_1 = require(\"./configuration\");\nvar enableDisableRules_1 = require(\"./enableDisableRules\");\nvar error_1 = require(\"./error\");\nvar formatterLoader_1 = require(\"./formatterLoader\");\nvar rule_1 = require(\"./language/rule/rule\");\nvar utils = require(\"./language/utils\");\nvar ruleLoader_1 = require(\"./ruleLoader\");\nvar utils_1 = require(\"./utils\");\n/**\n * Linter that can lint multiple files in consecutive runs.\n */\nvar Linter = (function () {\n    function Linter(options, program) {\n        this.options = options;\n        this.program = program;\n        this.failures = [];\n        this.fixes = [];\n        if (typeof options !== \"object\") {\n            throw new Error(\"Unknown Linter options type: \" + typeof options);\n        }\n        if (options.configuration != null) {\n            throw new Error(\"ILinterOptions does not contain the property `configuration` as of version 4. \" +\n                \"Did you mean to pass the `IConfigurationFile` object to lint() ? \");\n        }\n    }\n    /**\n     * Creates a TypeScript program object from a tsconfig.json file path and optional project directory.\n     */\n    Linter.createProgram = function (configFile, projectDirectory) {\n        if (projectDirectory === undefined) {\n            projectDirectory = path.dirname(configFile);\n        }\n        var config = ts.readConfigFile(configFile, ts.sys.readFile).config;\n        var parseConfigHost = {\n            fileExists: fs.existsSync,\n            readDirectory: ts.sys.readDirectory,\n            readFile: function (file) { return fs.readFileSync(file, \"utf8\"); },\n            useCaseSensitiveFileNames: true,\n        };\n        var parsed = ts.parseJsonConfigFileContent(config, parseConfigHost, projectDirectory);\n        var host = ts.createCompilerHost(parsed.options, true);\n        var program = ts.createProgram(parsed.fileNames, parsed.options, host);\n        return program;\n    };\n    /**\n     * Returns a list of source file names from a TypeScript program. This includes all referenced\n     * files and excludes declaration (\".d.ts\") files.\n     */\n    Linter.getFileNames = function (program) {\n        return program.getSourceFiles().map(function (s) { return s.fileName; }).filter(function (l) { return l.substr(-5) !== \".d.ts\"; });\n    };\n    Linter.prototype.lint = function (fileName, source, configuration) {\n        if (configuration === void 0) { configuration = configuration_1.DEFAULT_CONFIG; }\n        var sourceFile = this.getSourceFile(fileName, source);\n        var isJs = /\\.jsx?$/i.test(fileName);\n        var enabledRules = this.getEnabledRules(sourceFile, configuration, isJs);\n        var hasLinterRun = false;\n        var fileFailures = [];\n        if (this.options.fix) {\n            for (var _i = 0, enabledRules_1 = enabledRules; _i < enabledRules_1.length; _i++) {\n                var rule = enabledRules_1[_i];\n                var ruleFailures = this.applyRule(rule, sourceFile);\n                source = this.applyFixes(fileName, source, ruleFailures);\n                sourceFile = this.getSourceFile(fileName, source);\n                fileFailures = fileFailures.concat(ruleFailures);\n            }\n            hasLinterRun = true;\n        }\n        // make a 1st pass or make a 2nd pass if there were any fixes because the positions may be off\n        if (!hasLinterRun || this.fixes.length > 0) {\n            fileFailures = [];\n            for (var _a = 0, enabledRules_2 = enabledRules; _a < enabledRules_2.length; _a++) {\n                var rule = enabledRules_2[_a];\n                var ruleFailures = this.applyRule(rule, sourceFile);\n                if (ruleFailures.length > 0) {\n                    fileFailures = fileFailures.concat(ruleFailures);\n                }\n            }\n        }\n        this.failures = this.failures.concat(fileFailures);\n        // add rule severity to failures\n        var ruleSeverityMap = new Map(enabledRules.map(function (rule) {\n            return [rule.getOptions().ruleName, rule.getOptions().ruleSeverity];\n        }));\n        for (var _b = 0, _c = this.failures; _b < _c.length; _b++) {\n            var failure = _c[_b];\n            var severity = ruleSeverityMap.get(failure.getRuleName());\n            if (severity === undefined) {\n                throw new Error(\"Severity for rule '\" + failure.getRuleName() + \" not found\");\n            }\n            failure.setRuleSeverity(severity);\n        }\n    };\n    Linter.prototype.getResult = function () {\n        var formatter;\n        var formattersDirectory = configuration_1.getRelativePath(this.options.formattersDirectory);\n        var formatterName = this.options.formatter || \"prose\";\n        var Formatter = formatterLoader_1.findFormatter(formatterName, formattersDirectory);\n        if (Formatter) {\n            formatter = new Formatter();\n        }\n        else {\n            throw new Error(\"formatter '\" + formatterName + \"' not found\");\n        }\n        var output = formatter.format(this.failures, this.fixes);\n        var errorCount = this.failures.filter(function (failure) { return failure.getRuleSeverity() === \"error\"; }).length;\n        return {\n            errorCount: errorCount,\n            failures: this.failures,\n            fixes: this.fixes,\n            format: formatterName,\n            output: output,\n            warningCount: this.failures.length - errorCount,\n        };\n    };\n    // Applies fixes to the files where the failures are reported.\n    // Returns the content of the source file which AST needs to be reloaded.\n    Linter.prototype.applyFixes = function (sourceFilePath, sourceContent, ruleFailures) {\n        var fixesPerFile = ruleFailures\n            .reduce(function (accum, c) {\n            var currentFileName = c.getFileName();\n            var fix = c.getFix();\n            if (fix) {\n                accum[currentFileName] = accum[currentFileName] || [];\n                accum[currentFileName].push(fix);\n            }\n            return accum;\n        }, {});\n        var hasFixes = Object.keys(fixesPerFile).length > 0;\n        var result = sourceContent;\n        if (hasFixes) {\n            this.fixes = this.fixes.concat(ruleFailures);\n            Object.keys(fixesPerFile).forEach(function (currentFileName) {\n                var fixesForFile = fixesPerFile[currentFileName];\n                var source = fs.readFileSync(currentFileName, { encoding: \"utf-8\" });\n                source = rule_1.Replacement.applyFixes(source, fixesForFile);\n                fs.writeFileSync(currentFileName, source, { encoding: \"utf-8\" });\n                if (sourceFilePath === currentFileName) {\n                    result = source;\n                }\n            });\n        }\n        return result;\n    };\n    Linter.prototype.applyRule = function (rule, sourceFile) {\n        var ruleFailures = [];\n        try {\n            if (this.program && rule_1.isTypedRule(rule)) {\n                ruleFailures = rule.applyWithProgram(sourceFile, this.program);\n            }\n            else {\n                ruleFailures = rule.apply(sourceFile);\n            }\n        }\n        catch (error) {\n            if (error_1.isError(error)) {\n                error_1.showWarningOnce(\"Warning: \" + error.message);\n            }\n            else {\n                console.warn(\"Warning: \" + error);\n            }\n        }\n        var fileFailures = [];\n        for (var _i = 0, ruleFailures_1 = ruleFailures; _i < ruleFailures_1.length; _i++) {\n            var ruleFailure = ruleFailures_1[_i];\n            if (!this.containsRule(this.failures, ruleFailure)) {\n                fileFailures.push(ruleFailure);\n            }\n        }\n        return fileFailures;\n    };\n    Linter.prototype.getEnabledRules = function (sourceFile, configuration, isJs) {\n        if (configuration === void 0) { configuration = configuration_1.DEFAULT_CONFIG; }\n        var ruleOptionsList = configuration_1.convertRuleOptions(isJs ? configuration.jsRules : configuration.rules);\n        // walk the code first to find all the intervals where rules are disabled\n        var enableDisableRuleMap = new enableDisableRules_1.EnableDisableRulesWalker(sourceFile, ruleOptionsList).getEnableDisableRuleMap();\n        var rulesDirectories = utils_1.arrayify(this.options.rulesDirectory)\n            .concat(utils_1.arrayify(configuration.rulesDirectory));\n        var configuredRules = ruleLoader_1.loadRules(ruleOptionsList, enableDisableRuleMap, rulesDirectories, isJs);\n        return configuredRules.filter(function (r) { return r.isEnabled(); });\n    };\n    Linter.prototype.getSourceFile = function (fileName, source) {\n        if (this.program) {\n            var sourceFile = this.program.getSourceFile(fileName);\n            if (sourceFile === undefined) {\n                var INVALID_SOURCE_ERROR = (_a = [\"\\n                    Invalid source file: \", \". Ensure that the files supplied to lint have a .ts, .tsx, .js or .jsx extension.\\n                \"], _a.raw = [\"\\n                    Invalid source file: \", \". Ensure that the files supplied to lint have a .ts, .tsx, .js or .jsx extension.\\n                \"], utils_1.dedent(_a, fileName));\n                throw new Error(INVALID_SOURCE_ERROR);\n            }\n            // check if the program has been type checked\n            if (!(\"resolvedModules\" in sourceFile)) {\n                throw new Error(\"Program must be type checked before linting\");\n            }\n            return sourceFile;\n        }\n        else {\n            return utils.getSourceFile(fileName, source);\n        }\n        var _a;\n    };\n    Linter.prototype.containsRule = function (rules, rule) {\n        return rules.some(function (r) { return r.equals(rule); });\n    };\n    return Linter;\n}());\nLinter.VERSION = \"5.1.0\";\nLinter.findConfiguration = configuration_1.findConfiguration;\nLinter.findConfigurationPath = configuration_1.findConfigurationPath;\nLinter.getRulesDirectories = configuration_1.getRulesDirectories;\nLinter.loadConfigurationFromPath = configuration_1.loadConfigurationFromPath;\nmodule.exports = Linter;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/enableDisableRules.js":"/**\n * @license\n * Copyright 2014 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar EnableDisableRulesWalker = (function () {\n    function EnableDisableRulesWalker(sourceFile, ruleOptionsList) {\n        this.sourceFile = sourceFile;\n        this.enableDisableRuleMap = new Map();\n        this.enabledRules = [];\n        for (var _i = 0, ruleOptionsList_1 = ruleOptionsList; _i < ruleOptionsList_1.length; _i++) {\n            var ruleOptions = ruleOptionsList_1[_i];\n            if (ruleOptions.ruleSeverity !== \"off\") {\n                this.enabledRules.push(ruleOptions.ruleName);\n                this.enableDisableRuleMap.set(ruleOptions.ruleName, [{\n                        isEnabled: true,\n                        position: 0,\n                    }]);\n            }\n        }\n    }\n    EnableDisableRulesWalker.prototype.getEnableDisableRuleMap = function () {\n        var _this = this;\n        utils.forEachComment(this.sourceFile, function (fullText, comment) {\n            var commentText = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia\n                ? fullText.substring(comment.pos + 2, comment.end)\n                : fullText.substring(comment.pos + 2, comment.end - 2);\n            return _this.handleComment(commentText, comment);\n        });\n        return this.enableDisableRuleMap;\n    };\n    EnableDisableRulesWalker.prototype.getStartOfLinePosition = function (position, lineOffset) {\n        if (lineOffset === void 0) { lineOffset = 0; }\n        var line = ts.getLineAndCharacterOfPosition(this.sourceFile, position).line + lineOffset;\n        var lineStarts = this.sourceFile.getLineStarts();\n        if (line >= lineStarts.length) {\n            // next line ends with eof or there is no next line\n            // undefined switches the rule until the end and avoids an extra array entry\n            return undefined;\n        }\n        return lineStarts[line];\n    };\n    EnableDisableRulesWalker.prototype.switchRuleState = function (ruleName, isEnabled, start, end) {\n        var ruleStateMap = this.enableDisableRuleMap.get(ruleName);\n        if (ruleStateMap === undefined ||\n            isEnabled === ruleStateMap[ruleStateMap.length - 1].isEnabled // no need to add switch points if there is no change\n        ) {\n            return;\n        }\n        ruleStateMap.push({\n            isEnabled: isEnabled,\n            position: start,\n        });\n        if (end) {\n            // we only get here when rule state changes therefore we can safely use opposite state\n            ruleStateMap.push({\n                isEnabled: !isEnabled,\n                position: end,\n            });\n        }\n    };\n    EnableDisableRulesWalker.prototype.handleComment = function (commentText, range) {\n        // regex is: start of string followed by any amount of whitespace\n        // followed by tslint and colon\n        // followed by either \"enable\" or \"disable\"\n        // followed optionally by -line or -next-line\n        // followed by either colon, whitespace or end of string\n        var match = /^\\s*tslint:(enable|disable)(?:-(line|next-line))?(:|\\s|$)/.exec(commentText);\n        if (match !== null) {\n            // remove everything matched by the previous regex to get only the specified rules\n            // split at whitespaces\n            // filter empty items coming from whitespaces at start, at end or empty list\n            var rulesList = commentText.substr(match[0].length)\n                .split(/\\s+/)\n                .filter(function (rule) { return !!rule; });\n            if (rulesList.length === 0 && match[3] === \":\") {\n                // nothing to do here: an explicit separator was specified but no rules to switch\n                return;\n            }\n            if (rulesList.length === 0 ||\n                rulesList.indexOf(\"all\") !== -1) {\n                // if list is empty we default to all enabled rules\n                // if `all` is specified we ignore the other rules and take all enabled rules\n                rulesList = this.enabledRules;\n            }\n            this.handleTslintLineSwitch(rulesList, match[1] === \"enable\", match[2], range);\n        }\n    };\n    EnableDisableRulesWalker.prototype.handleTslintLineSwitch = function (rules, isEnabled, modifier, range) {\n        var start;\n        var end;\n        if (modifier === \"line\") {\n            // start at the beginning of the line where comment starts\n            start = this.getStartOfLinePosition(range.pos);\n            // end at the beginning of the line following the comment\n            end = this.getStartOfLinePosition(range.end, 1);\n        }\n        else if (modifier === \"next-line\") {\n            // start at the beginning of the line following the comment\n            start = this.getStartOfLinePosition(range.end, 1);\n            if (start === undefined) {\n                // no need to switch anything, there is no next line\n                return;\n            }\n            // end at the beginning of the line following the next line\n            end = this.getStartOfLinePosition(range.end, 2);\n        }\n        else {\n            // switch rule for the rest of the file\n            // start at the current position, but skip end position\n            start = range.pos;\n            end = undefined;\n        }\n        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\n            var ruleToSwitch = rules_1[_i];\n            this.switchRuleState(ruleToSwitch, isEnabled, start, end);\n        }\n    };\n    return EnableDisableRulesWalker;\n}());\nexports.EnableDisableRulesWalker = EnableDisableRulesWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatterLoader.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar utils_1 = require(\"./utils\");\nvar moduleDirectory = path.dirname(module.filename);\nvar CORE_FORMATTERS_DIRECTORY = path.resolve(moduleDirectory, \".\", \"formatters\");\nfunction findFormatter(name, formattersDirectory) {\n    if (typeof name === \"function\") {\n        return name;\n    }\n    else if (typeof name === \"string\") {\n        name = name.trim();\n        var camelizedName = utils_1.camelize(name + \"Formatter\");\n        // first check for core formatters\n        var Formatter = loadFormatter(CORE_FORMATTERS_DIRECTORY, camelizedName);\n        if (Formatter != null) {\n            return Formatter;\n        }\n        // then check for rules within the first level of rulesDirectory\n        if (formattersDirectory) {\n            Formatter = loadFormatter(formattersDirectory, camelizedName);\n            if (Formatter) {\n                return Formatter;\n            }\n        }\n        // else try to resolve as module\n        return loadFormatterModule(name);\n    }\n    else {\n        // If an something else is passed as a name (e.g. object)\n        throw new Error(\"Name of type \" + typeof name + \" is not supported.\");\n    }\n}\nexports.findFormatter = findFormatter;\nfunction loadFormatter() {\n    var paths = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        paths[_i] = arguments[_i];\n    }\n    var formatterPath = paths.reduce(function (p, c) { return path.join(p, c); }, \"\");\n    var fullPath = path.resolve(moduleDirectory, formatterPath);\n    if (fs.existsSync(fullPath + \".js\")) {\n        var formatterModule = require(fullPath);\n        return formatterModule.Formatter;\n    }\n    return undefined;\n}\nfunction loadFormatterModule(name) {\n    var src;\n    try {\n        src = require.resolve(name);\n    }\n    catch (e) {\n        return undefined;\n    }\n    return require(src).Formatter;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/rule/rule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../../utils\");\nfunction isTypedRule(rule) {\n    return \"applyWithProgram\" in rule;\n}\nexports.isTypedRule = isTypedRule;\nvar Replacement = (function () {\n    function Replacement(innerStart, innerLength, innerText) {\n        this.innerStart = innerStart;\n        this.innerLength = innerLength;\n        this.innerText = innerText;\n    }\n    Replacement.applyFixes = function (content, fixes) {\n        return this.applyAll(content, utils_1.flatMap(fixes, utils_1.arrayify));\n    };\n    Replacement.applyAll = function (content, replacements) {\n        // sort in reverse so that diffs are properly applied\n        replacements.sort(function (a, b) { return b.end - a.end; });\n        return replacements.reduce(function (text, r) { return r.apply(text); }, content);\n    };\n    Replacement.replaceNode = function (node, text, sourceFile) {\n        return this.replaceFromTo(node.getStart(sourceFile), node.getEnd(), text);\n    };\n    Replacement.replaceFromTo = function (start, end, text) {\n        return new Replacement(start, end - start, text);\n    };\n    Replacement.deleteText = function (start, length) {\n        return new Replacement(start, length, \"\");\n    };\n    Replacement.deleteFromTo = function (start, end) {\n        return new Replacement(start, end - start, \"\");\n    };\n    Replacement.appendText = function (start, text) {\n        return new Replacement(start, 0, text);\n    };\n    Object.defineProperty(Replacement.prototype, \"start\", {\n        get: function () {\n            return this.innerStart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Replacement.prototype, \"length\", {\n        get: function () {\n            return this.innerLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Replacement.prototype, \"end\", {\n        get: function () {\n            return this.innerStart + this.innerLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Replacement.prototype, \"text\", {\n        get: function () {\n            return this.innerText;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Replacement.prototype.apply = function (content) {\n        return content.substring(0, this.start) + this.text + content.substring(this.start + this.length);\n    };\n    return Replacement;\n}());\nexports.Replacement = Replacement;\nvar RuleFailurePosition = (function () {\n    function RuleFailurePosition(position, lineAndCharacter) {\n        this.position = position;\n        this.lineAndCharacter = lineAndCharacter;\n    }\n    RuleFailurePosition.prototype.getPosition = function () {\n        return this.position;\n    };\n    RuleFailurePosition.prototype.getLineAndCharacter = function () {\n        return this.lineAndCharacter;\n    };\n    RuleFailurePosition.prototype.toJson = function () {\n        return {\n            character: this.lineAndCharacter.character,\n            line: this.lineAndCharacter.line,\n            position: this.position,\n        };\n    };\n    RuleFailurePosition.prototype.equals = function (ruleFailurePosition) {\n        var ll = this.lineAndCharacter;\n        var rr = ruleFailurePosition.lineAndCharacter;\n        return this.position === ruleFailurePosition.position\n            && ll.line === rr.line\n            && ll.character === rr.character;\n    };\n    return RuleFailurePosition;\n}());\nexports.RuleFailurePosition = RuleFailurePosition;\nvar RuleFailure = (function () {\n    function RuleFailure(sourceFile, start, end, failure, ruleName, fix) {\n        this.sourceFile = sourceFile;\n        this.failure = failure;\n        this.ruleName = ruleName;\n        this.fix = fix;\n        this.fileName = sourceFile.fileName;\n        this.startPosition = this.createFailurePosition(start);\n        this.endPosition = this.createFailurePosition(end);\n        this.rawLines = sourceFile.text;\n        this.ruleSeverity = \"error\";\n    }\n    RuleFailure.prototype.getFileName = function () {\n        return this.fileName;\n    };\n    RuleFailure.prototype.getRuleName = function () {\n        return this.ruleName;\n    };\n    RuleFailure.prototype.getStartPosition = function () {\n        return this.startPosition;\n    };\n    RuleFailure.prototype.getEndPosition = function () {\n        return this.endPosition;\n    };\n    RuleFailure.prototype.getFailure = function () {\n        return this.failure;\n    };\n    RuleFailure.prototype.hasFix = function () {\n        return this.fix !== undefined;\n    };\n    RuleFailure.prototype.getFix = function () {\n        return this.fix;\n    };\n    RuleFailure.prototype.getRawLines = function () {\n        return this.rawLines;\n    };\n    RuleFailure.prototype.getRuleSeverity = function () {\n        return this.ruleSeverity;\n    };\n    RuleFailure.prototype.setRuleSeverity = function (value) {\n        this.ruleSeverity = value;\n    };\n    RuleFailure.prototype.toJson = function () {\n        return {\n            endPosition: this.endPosition.toJson(),\n            failure: this.failure,\n            fix: this.fix,\n            name: this.fileName,\n            ruleName: this.ruleName,\n            ruleSeverity: this.ruleSeverity.toUpperCase(),\n            startPosition: this.startPosition.toJson(),\n        };\n    };\n    RuleFailure.prototype.equals = function (ruleFailure) {\n        return this.failure === ruleFailure.getFailure()\n            && this.fileName === ruleFailure.getFileName()\n            && this.startPosition.equals(ruleFailure.getStartPosition())\n            && this.endPosition.equals(ruleFailure.getEndPosition());\n    };\n    RuleFailure.prototype.createFailurePosition = function (position) {\n        var lineAndCharacter = this.sourceFile.getLineAndCharacterOfPosition(position);\n        return new RuleFailurePosition(position, lineAndCharacter);\n    };\n    return RuleFailure;\n}());\nexports.RuleFailure = RuleFailure;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/utils.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = require(\"path\");\nvar ts = require(\"typescript\");\nfunction getSourceFile(fileName, source) {\n    var normalizedName = path.normalize(fileName).replace(/\\\\/g, \"/\");\n    return ts.createSourceFile(normalizedName, source, ts.ScriptTarget.ES5, /*setParentNodes*/ true);\n}\nexports.getSourceFile = getSourceFile;\nfunction doesIntersect(failure, disabledIntervals) {\n    return disabledIntervals.some(function (interval) {\n        var maxStart = Math.max(interval.startPosition, failure.getStartPosition().getPosition());\n        var minEnd = Math.min(interval.endPosition, failure.getEndPosition().getPosition());\n        return maxStart <= minEnd;\n    });\n}\nexports.doesIntersect = doesIntersect;\n/**\n * @returns true if any modifier kinds passed along exist in the given modifiers array\n */\nfunction hasModifier(modifiers) {\n    var modifierKinds = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        modifierKinds[_i - 1] = arguments[_i];\n    }\n    if (modifiers === undefined || modifierKinds.length === 0) {\n        return false;\n    }\n    return modifiers.some(function (m) {\n        return modifierKinds.some(function (k) { return m.kind === k; });\n    });\n}\nexports.hasModifier = hasModifier;\n/**\n * Determines if the appropriate bit in the parent (VariableDeclarationList) is set,\n * which indicates this is a \"let\" or \"const\".\n */\nfunction isBlockScopedVariable(node) {\n    var parentNode = (node.kind === ts.SyntaxKind.VariableDeclaration)\n        ? node.parent\n        : node.declarationList;\n    return isNodeFlagSet(parentNode, ts.NodeFlags.Let)\n        || isNodeFlagSet(parentNode, ts.NodeFlags.Const);\n}\nexports.isBlockScopedVariable = isBlockScopedVariable;\nfunction isBlockScopedBindingElement(node) {\n    var variableDeclaration = getBindingElementVariableDeclaration(node);\n    // if no variable declaration, it must be a function param, which is block scoped\n    return (variableDeclaration == null) || isBlockScopedVariable(variableDeclaration);\n}\nexports.isBlockScopedBindingElement = isBlockScopedBindingElement;\nfunction getBindingElementVariableDeclaration(node) {\n    var currentParent = node.parent;\n    while (currentParent.kind !== ts.SyntaxKind.VariableDeclaration) {\n        if (currentParent.parent == null) {\n            return null; // function parameter, no variable declaration\n        }\n        else {\n            currentParent = currentParent.parent;\n        }\n    }\n    return currentParent;\n}\nexports.getBindingElementVariableDeclaration = getBindingElementVariableDeclaration;\n/**\n * Finds a child of a given node with a given kind.\n * Note: This uses `node.getChildren()`, which does extra parsing work to include tokens.\n */\nfunction childOfKind(node, kind) {\n    return node.getChildren().find(function (child) { return child.kind === kind; });\n}\nexports.childOfKind = childOfKind;\n/**\n * @returns true if some ancestor of `node` satisfies `predicate`, including `node` itself.\n */\nfunction someAncestor(node, predicate) {\n    return predicate(node) || (node.parent != null && someAncestor(node.parent, predicate));\n}\nexports.someAncestor = someAncestor;\nfunction ancestorWhere(node, predicate) {\n    var cur = node;\n    do {\n        if (predicate(cur)) {\n            return cur;\n        }\n        cur = cur.parent;\n    } while (cur);\n    return undefined;\n}\nexports.ancestorWhere = ancestorWhere;\nfunction isAssignment(node) {\n    if (node.kind === ts.SyntaxKind.BinaryExpression) {\n        var binaryExpression = node;\n        return binaryExpression.operatorToken.kind >= ts.SyntaxKind.FirstAssignment\n            && binaryExpression.operatorToken.kind <= ts.SyntaxKind.LastAssignment;\n    }\n    else {\n        return false;\n    }\n}\nexports.isAssignment = isAssignment;\n/**\n * Bitwise check for node flags.\n */\nfunction isNodeFlagSet(node, flagToCheck) {\n    // tslint:disable-next-line:no-bitwise\n    return (node.flags & flagToCheck) !== 0;\n}\nexports.isNodeFlagSet = isNodeFlagSet;\n/**\n * Bitwise check for combined node flags.\n */\nfunction isCombinedNodeFlagSet(node, flagToCheck) {\n    // tslint:disable-next-line:no-bitwise\n    return (ts.getCombinedNodeFlags(node) & flagToCheck) !== 0;\n}\nexports.isCombinedNodeFlagSet = isCombinedNodeFlagSet;\n/**\n * Bitwise check for combined modifier flags.\n */\nfunction isCombinedModifierFlagSet(node, flagToCheck) {\n    // tslint:disable-next-line:no-bitwise\n    return (ts.getCombinedModifierFlags(node) & flagToCheck) !== 0;\n}\nexports.isCombinedModifierFlagSet = isCombinedModifierFlagSet;\n/**\n * Bitwise check for type flags.\n */\nfunction isTypeFlagSet(type, flagToCheck) {\n    // tslint:disable-next-line:no-bitwise\n    return (type.flags & flagToCheck) !== 0;\n}\nexports.isTypeFlagSet = isTypeFlagSet;\n/**\n * Bitwise check for symbol flags.\n */\nfunction isSymbolFlagSet(symbol, flagToCheck) {\n    // tslint:disable-next-line:no-bitwise\n    return (symbol.flags & flagToCheck) !== 0;\n}\nexports.isSymbolFlagSet = isSymbolFlagSet;\n/**\n * Bitwise check for object flags.\n * Does not work with TypeScript 2.0.x\n */\nfunction isObjectFlagSet(objectType, flagToCheck) {\n    // tslint:disable-next-line:no-bitwise\n    return (objectType.objectFlags & flagToCheck) !== 0;\n}\nexports.isObjectFlagSet = isObjectFlagSet;\n/**\n * @returns true if decl is a nested module declaration, i.e. represents a segment of a dotted module path.\n */\nfunction isNestedModuleDeclaration(decl) {\n    // in a declaration expression like 'module a.b.c' - 'a' is the top level module declaration node and 'b' and 'c'\n    // are nested therefore we can depend that a node's position will only match with its name's position for nested\n    // nodes\n    return decl.name.pos === decl.pos;\n}\nexports.isNestedModuleDeclaration = isNestedModuleDeclaration;\nfunction unwrapParentheses(node) {\n    while (node.kind === ts.SyntaxKind.ParenthesizedExpression) {\n        node = node.expression;\n    }\n    return node;\n}\nexports.unwrapParentheses = unwrapParentheses;\nfunction isScopeBoundary(node) {\n    return node.kind === ts.SyntaxKind.FunctionDeclaration\n        || node.kind === ts.SyntaxKind.FunctionExpression\n        || node.kind === ts.SyntaxKind.PropertyAssignment\n        || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n        || node.kind === ts.SyntaxKind.MethodDeclaration\n        || node.kind === ts.SyntaxKind.Constructor\n        || node.kind === ts.SyntaxKind.ModuleDeclaration\n        || node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.ClassDeclaration\n        || node.kind === ts.SyntaxKind.ClassExpression\n        || node.kind === ts.SyntaxKind.InterfaceDeclaration\n        || node.kind === ts.SyntaxKind.GetAccessor\n        || node.kind === ts.SyntaxKind.SetAccessor\n        || node.kind === ts.SyntaxKind.SourceFile && ts.isExternalModule(node);\n}\nexports.isScopeBoundary = isScopeBoundary;\nfunction isBlockScopeBoundary(node) {\n    return isScopeBoundary(node)\n        || node.kind === ts.SyntaxKind.Block\n        || isLoop(node)\n        || node.kind === ts.SyntaxKind.WithStatement\n        || node.kind === ts.SyntaxKind.SwitchStatement\n        || node.parent !== undefined\n            && (node.parent.kind === ts.SyntaxKind.TryStatement\n                || node.parent.kind === ts.SyntaxKind.IfStatement);\n}\nexports.isBlockScopeBoundary = isBlockScopeBoundary;\nfunction isLoop(node) {\n    return node.kind === ts.SyntaxKind.DoStatement\n        || node.kind === ts.SyntaxKind.WhileStatement\n        || node.kind === ts.SyntaxKind.ForStatement\n        || node.kind === ts.SyntaxKind.ForInStatement\n        || node.kind === ts.SyntaxKind.ForOfStatement;\n}\nexports.isLoop = isLoop;\n/**\n * Iterate over all tokens of `node`\n *\n * @description JsDoc comments are treated like regular comments and only visited if `skipTrivia` === false.\n *\n * @param node The node whose tokens should be visited\n * @param skipTrivia If set to false all trivia preceeding `node` or any of its children is included\n * @param cb Is called for every token of `node`. It gets the full text of the SourceFile and the position of the token within that text.\n * @param filter If provided, will be called for every Node and Token found. If it returns false `cb` will not be called for this subtree.\n */\nfunction forEachToken(node, skipTrivia, cb, filter) {\n    // this function will most likely be called with SourceFile anyways, so there is no need for an additional parameter\n    var sourceFile = node.getSourceFile();\n    var fullText = sourceFile.text;\n    var iterateFn = filter === undefined ? iterateChildren : iterateWithFilter;\n    var handleTrivia = skipTrivia ? undefined : createTriviaHandler(sourceFile, cb);\n    iterateFn(node);\n    // this function is used to save the if condition for the common case where no filter is provided\n    function iterateWithFilter(child) {\n        if (filter(child)) {\n            return iterateChildren(child);\n        }\n    }\n    function iterateChildren(child) {\n        if (child.kind < ts.SyntaxKind.FirstNode ||\n            // for backwards compatibility to typescript 2.0.10\n            // JsxText was no Token, but a Node in that version\n            child.kind === ts.SyntaxKind.JsxText) {\n            // we found a token, tokens have no children, stop recursing here\n            return callback(child);\n        }\n        /* Exclude everything contained in JsDoc, it will be handled with the other trivia anyway.\n         * When we would handle JsDoc tokens like regular ones, we would scan some trivia multiple times.\n         * Even worse, we would scan for trivia inside the JsDoc comment, which yields unexpected results.*/\n        if (child.kind !== ts.SyntaxKind.JSDocComment) {\n            // recurse into Node's children to find tokens\n            return child.getChildren(sourceFile).forEach(iterateFn);\n        }\n    }\n    function callback(token) {\n        var tokenStart = token.getStart(sourceFile);\n        if (!skipTrivia && tokenStart !== token.pos) {\n            // we only have to handle trivia before each token, because there is nothing after EndOfFileToken\n            handleTrivia(token.pos, tokenStart, token);\n        }\n        return cb(fullText, token.kind, { tokenStart: tokenStart, fullStart: token.pos, end: token.end }, token.parent);\n    }\n}\nexports.forEachToken = forEachToken;\nfunction createTriviaHandler(sourceFile, cb) {\n    var fullText = sourceFile.text;\n    var scanner = ts.createScanner(sourceFile.languageVersion, false, sourceFile.languageVariant, fullText);\n    /**\n     * Scan the specified range to get all trivia tokens.\n     * This includes trailing trivia of the last token and the leading trivia of the current token\n     */\n    function handleTrivia(start, end, token) {\n        var parent = token.parent;\n        // prevent false positives by not scanning inside JsxText\n        if (!canHaveLeadingTrivia(token.kind, parent)) {\n            return;\n        }\n        scanner.setTextPos(start);\n        var position;\n        // we only get here if start !== end, so we can scan at least one time\n        do {\n            var kind = scanner.scan();\n            position = scanner.getTextPos();\n            cb(fullText, kind, { tokenStart: scanner.getTokenPos(), end: position, fullStart: start }, parent);\n        } while (position < end);\n    }\n    return handleTrivia;\n}\n/** Iterate over all comments owned by `node` or its children */\nfunction forEachComment(node, cb) {\n    /* Visit all tokens and skip trivia.\n       Comment ranges between tokens are parsed without the need of a scanner.\n       forEachToken also does intentionally not pay attention to the correct comment ownership of nodes as it always\n       scans all trivia before each token, which could include trailing comments of the previous token.\n       Comment onwership is done right in this function*/\n    return forEachToken(node, true, function (fullText, tokenKind, pos, parent) {\n        // don't search for comments inside JsxText\n        if (canHaveLeadingTrivia(tokenKind, parent)) {\n            // Comments before the first token (pos.fullStart === 0) are all considered leading comments, so no need for special treatment\n            var comments = ts.getLeadingCommentRanges(fullText, pos.fullStart);\n            if (comments !== undefined) {\n                for (var _i = 0, comments_1 = comments; _i < comments_1.length; _i++) {\n                    var comment = comments_1[_i];\n                    cb(fullText, comment.kind, { fullStart: pos.fullStart, tokenStart: comment.pos, end: comment.end });\n                }\n            }\n        }\n        if (canHaveTrailingTrivia(tokenKind, parent)) {\n            var comments = ts.getTrailingCommentRanges(fullText, pos.end);\n            if (comments !== undefined) {\n                for (var _a = 0, comments_2 = comments; _a < comments_2.length; _a++) {\n                    var comment = comments_2[_a];\n                    cb(fullText, comment.kind, { fullStart: pos.fullStart, tokenStart: comment.pos, end: comment.end });\n                }\n            }\n        }\n    });\n}\nexports.forEachComment = forEachComment;\n/** Exclude leading positions that would lead to scanning for trivia inside JsxText */\nfunction canHaveLeadingTrivia(tokenKind, parent) {\n    if (tokenKind === ts.SyntaxKind.JsxText) {\n        return false; // there is no trivia before JsxText\n    }\n    if (tokenKind === ts.SyntaxKind.OpenBraceToken) {\n        // before a JsxExpression inside a JsxElement's body can only be other JsxChild, but no trivia\n        return parent.kind !== ts.SyntaxKind.JsxExpression || parent.parent.kind !== ts.SyntaxKind.JsxElement;\n    }\n    if (tokenKind === ts.SyntaxKind.LessThanToken) {\n        if (parent.kind === ts.SyntaxKind.JsxClosingElement) {\n            return false; // would be inside the element body\n        }\n        if (parent.kind === ts.SyntaxKind.JsxOpeningElement || parent.kind === ts.SyntaxKind.JsxSelfClosingElement) {\n            // there can only be leading trivia if we are at the end of the top level element\n            return parent.parent.parent.kind !== ts.SyntaxKind.JsxElement;\n        }\n    }\n    return true;\n}\n/** Exclude trailing positions that would lead to scanning for trivia inside JsxText */\nfunction canHaveTrailingTrivia(tokenKind, parent) {\n    if (tokenKind === ts.SyntaxKind.JsxText) {\n        return false; // there is no trivia after JsxText\n    }\n    if (tokenKind === ts.SyntaxKind.CloseBraceToken) {\n        // after a JsxExpression inside a JsxElement's body can only be other JsxChild, but no trivia\n        return parent.kind !== ts.SyntaxKind.JsxExpression || parent.parent.kind !== ts.SyntaxKind.JsxElement;\n    }\n    if (tokenKind === ts.SyntaxKind.GreaterThanToken) {\n        if (parent.kind === ts.SyntaxKind.JsxOpeningElement) {\n            return false; // would be inside the element\n        }\n        if (parent.kind === ts.SyntaxKind.JsxClosingElement || parent.kind === ts.SyntaxKind.JsxSelfClosingElement) {\n            // there can only be trailing trivia if we are at the end of the top level element\n            return parent.parent.parent.kind !== ts.SyntaxKind.JsxElement;\n        }\n    }\n    return true;\n}\n/**\n * Checks if there are any comments between `position` and the next non-trivia token\n *\n * @param text The text to scan\n * @param position The position inside `text` where to start scanning. Make sure that this is a valid start position.\n *                 This value is typically obtained from `node.getFullStart()` or `node.getEnd()`\n */\nfunction hasCommentAfterPosition(text, position) {\n    return ts.getTrailingCommentRanges(text, position) !== undefined ||\n        ts.getLeadingCommentRanges(text, position) !== undefined;\n}\nexports.hasCommentAfterPosition = hasCommentAfterPosition;\nfunction getEqualsKind(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.EqualsEqualsToken:\n            return { isPositive: true, isStrict: false };\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n            return { isPositive: true, isStrict: true };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n            return { isPositive: false, isStrict: false };\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n            return { isPositive: false, isStrict: true };\n        default:\n            return undefined;\n    }\n}\nexports.getEqualsKind = getEqualsKind;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/ruleLoader.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar configuration_1 = require(\"./configuration\");\nvar error_1 = require(\"./error\");\nvar utils_1 = require(\"./utils\");\nvar moduleDirectory = path.dirname(module.filename);\nvar CORE_RULES_DIRECTORY = path.resolve(moduleDirectory, \".\", \"rules\");\nvar cachedRules = new Map(); // null indicates that the rule was not found\nfunction loadRules(ruleOptionsList, enableDisableRuleMap, rulesDirectories, isJs) {\n    var rules = [];\n    var notFoundRules = [];\n    var notAllowedInJsRules = [];\n    for (var _i = 0, ruleOptionsList_1 = ruleOptionsList; _i < ruleOptionsList_1.length; _i++) {\n        var ruleOptions = ruleOptionsList_1[_i];\n        var ruleName = ruleOptions.ruleName;\n        var enableDisableRules = enableDisableRuleMap.get(ruleName);\n        if (ruleOptions.ruleSeverity !== \"off\" || enableDisableRuleMap) {\n            var Rule = findRule(ruleName, rulesDirectories);\n            if (Rule == null) {\n                notFoundRules.push(ruleName);\n            }\n            else {\n                if (isJs && Rule.metadata && Rule.metadata.typescriptOnly) {\n                    notAllowedInJsRules.push(ruleName);\n                }\n                else {\n                    var ruleSpecificList = enableDisableRules || [];\n                    ruleOptions.disabledIntervals = buildDisabledIntervalsFromSwitches(ruleSpecificList);\n                    rules.push(new Rule(ruleOptions));\n                    if (Rule.metadata && Rule.metadata.deprecationMessage) {\n                        error_1.showWarningOnce(Rule.metadata.ruleName + \" is deprecated. \" + Rule.metadata.deprecationMessage);\n                    }\n                }\n            }\n        }\n    }\n    if (notFoundRules.length > 0) {\n        var warning = (_a = [\"\\n            Could not find implementations for the following rules specified in the configuration:\\n                \", \"\\n            Try upgrading TSLint and/or ensuring that you have all necessary custom rules installed.\\n            If TSLint was recently upgraded, you may have old rules configured which need to be cleaned up.\\n        \"], _a.raw = [\"\\n            Could not find implementations for the following rules specified in the configuration:\\n                \", \"\\n            Try upgrading TSLint and/or ensuring that you have all necessary custom rules installed.\\n            If TSLint was recently upgraded, you may have old rules configured which need to be cleaned up.\\n        \"], utils_1.dedent(_a, notFoundRules.join(\"\\n                \")));\n        console.warn(warning);\n    }\n    if (notAllowedInJsRules.length > 0) {\n        var warning = (_b = [\"\\n            Following rules specified in configuration couldn't be applied to .js or .jsx files:\\n                \", \"\\n            Make sure to exclude them from \\\"jsRules\\\" section of your tslint.json.\\n        \"], _b.raw = [\"\\n            Following rules specified in configuration couldn't be applied to .js or .jsx files:\\n                \", \"\\n            Make sure to exclude them from \\\"jsRules\\\" section of your tslint.json.\\n        \"], utils_1.dedent(_b, notAllowedInJsRules.join(\"\\n                \")));\n        console.warn(warning);\n    }\n    if (rules.length === 0) {\n        console.warn(\"No valid rules have been specified\");\n    }\n    return rules;\n    var _a, _b;\n}\nexports.loadRules = loadRules;\nfunction findRule(name, rulesDirectories) {\n    var camelizedName = transformName(name);\n    var Rule;\n    // first check for core rules\n    Rule = loadCachedRule(CORE_RULES_DIRECTORY, camelizedName);\n    if (Rule == null) {\n        // then check for rules within the first level of rulesDirectory\n        for (var _i = 0, _a = utils_1.arrayify(rulesDirectories); _i < _a.length; _i++) {\n            var dir = _a[_i];\n            Rule = loadCachedRule(dir, camelizedName, true);\n            if (Rule != null) {\n                break;\n            }\n        }\n    }\n    return Rule;\n}\nexports.findRule = findRule;\nfunction transformName(name) {\n    // camelize strips out leading and trailing underscores and dashes, so make sure they aren't passed to camelize\n    // the regex matches the groups (leading underscores and dashes)(other characters)(trailing underscores and dashes)\n    var nameMatch = name.match(/^([-_]*)(.*?)([-_]*)$/);\n    if (nameMatch == null) {\n        return name + \"Rule\";\n    }\n    return nameMatch[1] + utils_1.camelize(nameMatch[2]) + nameMatch[3] + \"Rule\";\n}\n/**\n * @param directory - An absolute path to a directory of rules\n * @param ruleName - A name of a rule in filename format. ex) \"someLintRule\"\n */\nfunction loadRule(directory, ruleName) {\n    var fullPath = path.join(directory, ruleName);\n    if (fs.existsSync(fullPath + \".js\")) {\n        var ruleModule = require(fullPath);\n        if (ruleModule && ruleModule.Rule) {\n            return ruleModule.Rule;\n        }\n    }\n    return undefined;\n}\nfunction loadCachedRule(directory, ruleName, isCustomPath) {\n    if (isCustomPath === void 0) { isCustomPath = false; }\n    // use cached value if available\n    var fullPath = path.join(directory, ruleName);\n    var cachedRule = cachedRules.get(fullPath);\n    if (cachedRule !== undefined) {\n        return cachedRule;\n    }\n    // get absolute path\n    var absolutePath = directory;\n    if (isCustomPath) {\n        absolutePath = configuration_1.getRelativePath(directory);\n        if (absolutePath != null) {\n            if (!fs.existsSync(absolutePath)) {\n                throw new Error(\"Could not find custom rule directory: \" + directory);\n            }\n        }\n    }\n    var Rule = null;\n    if (absolutePath != null) {\n        Rule = loadRule(absolutePath, ruleName);\n    }\n    cachedRules.set(fullPath, Rule);\n    return Rule;\n}\n/**\n * creates disabled intervals for rule based on list of switchers for it\n * @param ruleSpecificList - contains all switchers for rule states sorted top-down and strictly alternating between enabled and disabled\n */\nfunction buildDisabledIntervalsFromSwitches(ruleSpecificList) {\n    var disabledIntervalList = [];\n    // starting from second element in the list since first is always enabled in position 0;\n    var i = 1;\n    while (i < ruleSpecificList.length) {\n        var startPosition = ruleSpecificList[i].position;\n        // rule enabled state is always alternating therefore we can use position of next switch as end of disabled interval\n        // set endPosition as Infinity in case when last switch for rule in a file is disabled\n        var endPosition = ruleSpecificList[i + 1] ? ruleSpecificList[i + 1].position : Infinity;\n        disabledIntervalList.push({\n            endPosition: endPosition,\n            startPosition: startPosition,\n        });\n        i += 2;\n    }\n    return disabledIntervalList;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./language/rule/abstractRule\"));\n__export(require(\"./language/rule/typedRule\"));\n__export(require(\"./language/rule/optionallyTypedRule\"));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/rule/abstractRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../utils\");\nvar walker_1 = require(\"../walker\");\nvar AbstractRule = (function () {\n    function AbstractRule(options) {\n        this.options = options;\n        this.ruleName = options.ruleName;\n        this.ruleArguments = options.ruleArguments;\n        this.ruleSeverity = options.ruleSeverity;\n    }\n    AbstractRule.prototype.getOptions = function () {\n        return this.options;\n    };\n    AbstractRule.prototype.applyWithWalker = function (walker) {\n        walker.walk(walker.getSourceFile());\n        return this.filterFailures(walker.getFailures());\n    };\n    AbstractRule.prototype.isEnabled = function () {\n        return this.ruleSeverity !== \"off\";\n    };\n    AbstractRule.prototype.applyWithFunction = function (sourceFile, walkFn, options) {\n        var ctx = new walker_1.WalkContext(sourceFile, this.ruleName, options);\n        walkFn(ctx);\n        return this.filterFailures(ctx.failures);\n    };\n    AbstractRule.prototype.filterFailures = function (failures) {\n        var result = [];\n        var _loop_1 = function (failure) {\n            // don't add failures for a rule if the failure intersects an interval where that rule is disabled\n            if (!utils_1.doesIntersect(failure, this_1.options.disabledIntervals) && !result.some(function (f) { return f.equals(failure); })) {\n                result.push(failure);\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, failures_1 = failures; _i < failures_1.length; _i++) {\n            var failure = failures_1[_i];\n            _loop_1(failure);\n        }\n        return result;\n    };\n    return AbstractRule;\n}());\nexports.AbstractRule = AbstractRule;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/index.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./blockScopeAwareRuleWalker\"));\n__export(require(\"./programAwareRuleWalker\"));\n__export(require(\"./ruleWalker\"));\n__export(require(\"./scopeAwareRuleWalker\"));\n__export(require(\"./syntaxWalker\"));\n__export(require(\"./walkContext\"));\n__export(require(\"./walker\"));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/blockScopeAwareRuleWalker.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar utils_1 = require(\"../utils\");\nvar scopeAwareRuleWalker_1 = require(\"./scopeAwareRuleWalker\");\n/**\n * An AST walker that is aware of block scopes in addition to regular scopes. Block scopes\n * are a superset of regular scopes (new block scopes are created more frequently in a program).\n */\nvar BlockScopeAwareRuleWalker = (function (_super) {\n    __extends(BlockScopeAwareRuleWalker, _super);\n    function BlockScopeAwareRuleWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        // initialize with global scope if file is not a module\n        _this.blockScopeStack = ts.isExternalModule(sourceFile) ? [] : [_this.createBlockScope(sourceFile)];\n        return _this;\n    }\n    // get all block scopes available at this depth\n    BlockScopeAwareRuleWalker.prototype.getAllBlockScopes = function () {\n        return this.blockScopeStack;\n    };\n    BlockScopeAwareRuleWalker.prototype.getCurrentBlockScope = function () {\n        return this.blockScopeStack[this.blockScopeStack.length - 1];\n    };\n    BlockScopeAwareRuleWalker.prototype.getCurrentBlockDepth = function () {\n        return this.blockScopeStack.length;\n    };\n    // callback notifier when a block scope begins\n    BlockScopeAwareRuleWalker.prototype.onBlockScopeStart = function () {\n        return;\n    };\n    // callback notifier when a block scope ends\n    BlockScopeAwareRuleWalker.prototype.onBlockScopeEnd = function () {\n        return;\n    };\n    BlockScopeAwareRuleWalker.prototype.findBlockScope = function (predicate) {\n        // look through block scopes from local -> global\n        for (var i = this.blockScopeStack.length - 1; i >= 0; i--) {\n            if (predicate(this.blockScopeStack[i])) {\n                return this.blockScopeStack[i];\n            }\n        }\n        return undefined;\n    };\n    BlockScopeAwareRuleWalker.prototype.visitNode = function (node) {\n        var isNewBlockScope = this.isBlockScopeBoundary(node);\n        if (isNewBlockScope) {\n            this.blockScopeStack.push(this.createBlockScope(node));\n            this.onBlockScopeStart();\n        }\n        _super.prototype.visitNode.call(this, node);\n        if (isNewBlockScope) {\n            this.onBlockScopeEnd();\n            this.blockScopeStack.pop();\n        }\n    };\n    BlockScopeAwareRuleWalker.prototype.isBlockScopeBoundary = function (node) {\n        return utils_1.isBlockScopeBoundary(node);\n    };\n    return BlockScopeAwareRuleWalker;\n}(scopeAwareRuleWalker_1.ScopeAwareRuleWalker));\nexports.BlockScopeAwareRuleWalker = BlockScopeAwareRuleWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/scopeAwareRuleWalker.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar utils_1 = require(\"../utils\");\nvar ruleWalker_1 = require(\"./ruleWalker\");\nvar ScopeAwareRuleWalker = (function (_super) {\n    __extends(ScopeAwareRuleWalker, _super);\n    function ScopeAwareRuleWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        // initialize with global scope if file is not a module\n        _this.scopeStack = ts.isExternalModule(sourceFile) ? [] : [_this.createScope(sourceFile)];\n        return _this;\n    }\n    ScopeAwareRuleWalker.prototype.getCurrentScope = function () {\n        return this.scopeStack[this.scopeStack.length - 1];\n    };\n    // get all scopes available at this depth\n    ScopeAwareRuleWalker.prototype.getAllScopes = function () {\n        return this.scopeStack;\n    };\n    ScopeAwareRuleWalker.prototype.getCurrentDepth = function () {\n        return this.scopeStack.length;\n    };\n    // callback notifier when a scope begins\n    ScopeAwareRuleWalker.prototype.onScopeStart = function () {\n        return;\n    };\n    // callback notifier when a scope ends\n    ScopeAwareRuleWalker.prototype.onScopeEnd = function () {\n        return;\n    };\n    ScopeAwareRuleWalker.prototype.visitNode = function (node) {\n        var isNewScope = this.isScopeBoundary(node);\n        if (isNewScope) {\n            this.scopeStack.push(this.createScope(node));\n            this.onScopeStart();\n        }\n        _super.prototype.visitNode.call(this, node);\n        if (isNewScope) {\n            this.onScopeEnd();\n            this.scopeStack.pop();\n        }\n    };\n    ScopeAwareRuleWalker.prototype.isScopeBoundary = function (node) {\n        return utils_1.isScopeBoundary(node);\n    };\n    return ScopeAwareRuleWalker;\n}(ruleWalker_1.RuleWalker));\nexports.ScopeAwareRuleWalker = ScopeAwareRuleWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/ruleWalker.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rule_1 = require(\"../rule/rule\");\nvar syntaxWalker_1 = require(\"./syntaxWalker\");\nvar RuleWalker = (function (_super) {\n    __extends(RuleWalker, _super);\n    function RuleWalker(sourceFile, options) {\n        var _this = _super.call(this) || this;\n        _this.sourceFile = sourceFile;\n        _this.failures = [];\n        _this.options = options.ruleArguments;\n        _this.limit = _this.sourceFile.getFullWidth();\n        _this.ruleName = options.ruleName;\n        return _this;\n    }\n    RuleWalker.prototype.getSourceFile = function () {\n        return this.sourceFile;\n    };\n    RuleWalker.prototype.getLineAndCharacterOfPosition = function (position) {\n        return this.sourceFile.getLineAndCharacterOfPosition(position);\n    };\n    RuleWalker.prototype.getFailures = function () {\n        return this.failures;\n    };\n    RuleWalker.prototype.getLimit = function () {\n        return this.limit;\n    };\n    RuleWalker.prototype.getOptions = function () {\n        return this.options;\n    };\n    RuleWalker.prototype.hasOption = function (option) {\n        if (this.options) {\n            return this.options.indexOf(option) !== -1;\n        }\n        else {\n            return false;\n        }\n    };\n    /** @deprecated Prefer `addFailureAt` and its variants. */\n    RuleWalker.prototype.createFailure = function (start, width, failure, fix) {\n        var from = (start > this.limit) ? this.limit : start;\n        var to = ((start + width) > this.limit) ? this.limit : (start + width);\n        return new rule_1.RuleFailure(this.sourceFile, from, to, failure, this.ruleName, fix);\n    };\n    /** @deprecated Prefer `addFailureAt` and its variants. */\n    RuleWalker.prototype.addFailure = function (failure) {\n        this.failures.push(failure);\n    };\n    /** Add a failure with any arbitrary span. Prefer `addFailureAtNode` if possible. */\n    RuleWalker.prototype.addFailureAt = function (start, width, failure, fix) {\n        this.addFailure(this.createFailure(start, width, failure, fix));\n    };\n    /** Like `addFailureAt` but uses start and end instead of start and width. */\n    RuleWalker.prototype.addFailureFromStartToEnd = function (start, end, failure, fix) {\n        this.addFailureAt(start, end - start, failure, fix);\n    };\n    /** Add a failure using a node's span. */\n    RuleWalker.prototype.addFailureAtNode = function (node, failure, fix) {\n        this.addFailureAt(node.getStart(this.sourceFile), node.getWidth(this.sourceFile), failure, fix);\n    };\n    RuleWalker.prototype.createReplacement = function (start, length, text) {\n        return new rule_1.Replacement(start, length, text);\n    };\n    RuleWalker.prototype.appendText = function (start, text) {\n        return this.createReplacement(start, 0, text);\n    };\n    RuleWalker.prototype.deleteText = function (start, length) {\n        return this.createReplacement(start, length, \"\");\n    };\n    RuleWalker.prototype.deleteFromTo = function (start, end) {\n        return this.createReplacement(start, end - start, \"\");\n    };\n    RuleWalker.prototype.getRuleName = function () {\n        return this.ruleName;\n    };\n    return RuleWalker;\n}(syntaxWalker_1.SyntaxWalker));\nexports.RuleWalker = RuleWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/syntaxWalker.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar SyntaxWalker = (function () {\n    function SyntaxWalker() {\n    }\n    SyntaxWalker.prototype.walk = function (node) {\n        this.visitNode(node);\n    };\n    SyntaxWalker.prototype.visitAnyKeyword = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitArrayType = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitArrowFunction = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitBinaryExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitBindingElement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitBindingPattern = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitBlock = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitBreakStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitCallExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitCallSignature = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitCaseClause = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitClassDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitClassExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitCatchClause = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitConditionalExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitConstructSignature = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitConstructorType = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitContinueStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitDebuggerStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitDefaultClause = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitDoStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitElementAccessExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitEndOfFileToken = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitEnumDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitExportAssignment = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitExpressionStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitForStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitForInStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitForOfStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitFunctionExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitFunctionType = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitGetAccessor = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitIdentifier = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitIfStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitImportDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitImportEqualsDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitIndexSignatureDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitJsxAttribute = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitJsxElement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitJsxExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitJsxSelfClosingElement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitJsxSpreadAttribute = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitLabeledStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitMethodDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitMethodSignature = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitModuleDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitNamedImports = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitNamespaceImport = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitNewExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitNonNullExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitNumericLiteral = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitParameterDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitPropertyAccessExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitPropertyAssignment = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitPropertyDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitPropertySignature = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitRegularExpressionLiteral = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitReturnStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitSetAccessor = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitSourceFile = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitStringLiteral = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitSwitchStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTemplateExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitThrowStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTryStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTupleType = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTypeAliasDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTypeAssertionExpression = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTypeLiteral = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitTypeReference = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitVariableDeclaration = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitVariableDeclarationList = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitVariableStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitWhileStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitWithStatement = function (node) {\n        this.walkChildren(node);\n    };\n    SyntaxWalker.prototype.visitNode = function (node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.AnyKeyword:\n                this.visitAnyKeyword(node);\n                break;\n            case ts.SyntaxKind.ArrayBindingPattern:\n                this.visitBindingPattern(node);\n                break;\n            case ts.SyntaxKind.ArrayLiteralExpression:\n                this.visitArrayLiteralExpression(node);\n                break;\n            case ts.SyntaxKind.ArrayType:\n                this.visitArrayType(node);\n                break;\n            case ts.SyntaxKind.ArrowFunction:\n                this.visitArrowFunction(node);\n                break;\n            case ts.SyntaxKind.BinaryExpression:\n                this.visitBinaryExpression(node);\n                break;\n            case ts.SyntaxKind.BindingElement:\n                this.visitBindingElement(node);\n                break;\n            case ts.SyntaxKind.Block:\n                this.visitBlock(node);\n                break;\n            case ts.SyntaxKind.BreakStatement:\n                this.visitBreakStatement(node);\n                break;\n            case ts.SyntaxKind.CallExpression:\n                this.visitCallExpression(node);\n                break;\n            case ts.SyntaxKind.CallSignature:\n                this.visitCallSignature(node);\n                break;\n            case ts.SyntaxKind.CaseClause:\n                this.visitCaseClause(node);\n                break;\n            case ts.SyntaxKind.ClassDeclaration:\n                this.visitClassDeclaration(node);\n                break;\n            case ts.SyntaxKind.ClassExpression:\n                this.visitClassExpression(node);\n                break;\n            case ts.SyntaxKind.CatchClause:\n                this.visitCatchClause(node);\n                break;\n            case ts.SyntaxKind.ConditionalExpression:\n                this.visitConditionalExpression(node);\n                break;\n            case ts.SyntaxKind.ConstructSignature:\n                this.visitConstructSignature(node);\n                break;\n            case ts.SyntaxKind.Constructor:\n                this.visitConstructorDeclaration(node);\n                break;\n            case ts.SyntaxKind.ConstructorType:\n                this.visitConstructorType(node);\n                break;\n            case ts.SyntaxKind.ContinueStatement:\n                this.visitContinueStatement(node);\n                break;\n            case ts.SyntaxKind.DebuggerStatement:\n                this.visitDebuggerStatement(node);\n                break;\n            case ts.SyntaxKind.DefaultClause:\n                this.visitDefaultClause(node);\n                break;\n            case ts.SyntaxKind.DoStatement:\n                this.visitDoStatement(node);\n                break;\n            case ts.SyntaxKind.ElementAccessExpression:\n                this.visitElementAccessExpression(node);\n                break;\n            case ts.SyntaxKind.EndOfFileToken:\n                this.visitEndOfFileToken(node);\n                break;\n            case ts.SyntaxKind.EnumDeclaration:\n                this.visitEnumDeclaration(node);\n                break;\n            case ts.SyntaxKind.ExportAssignment:\n                this.visitExportAssignment(node);\n                break;\n            case ts.SyntaxKind.ExpressionStatement:\n                this.visitExpressionStatement(node);\n                break;\n            case ts.SyntaxKind.ForStatement:\n                this.visitForStatement(node);\n                break;\n            case ts.SyntaxKind.ForInStatement:\n                this.visitForInStatement(node);\n                break;\n            case ts.SyntaxKind.ForOfStatement:\n                this.visitForOfStatement(node);\n                break;\n            case ts.SyntaxKind.FunctionDeclaration:\n                this.visitFunctionDeclaration(node);\n                break;\n            case ts.SyntaxKind.FunctionExpression:\n                this.visitFunctionExpression(node);\n                break;\n            case ts.SyntaxKind.FunctionType:\n                this.visitFunctionType(node);\n                break;\n            case ts.SyntaxKind.GetAccessor:\n                this.visitGetAccessor(node);\n                break;\n            case ts.SyntaxKind.Identifier:\n                this.visitIdentifier(node);\n                break;\n            case ts.SyntaxKind.IfStatement:\n                this.visitIfStatement(node);\n                break;\n            case ts.SyntaxKind.ImportDeclaration:\n                this.visitImportDeclaration(node);\n                break;\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n                this.visitImportEqualsDeclaration(node);\n                break;\n            case ts.SyntaxKind.IndexSignature:\n                this.visitIndexSignatureDeclaration(node);\n                break;\n            case ts.SyntaxKind.InterfaceDeclaration:\n                this.visitInterfaceDeclaration(node);\n                break;\n            case ts.SyntaxKind.JsxAttribute:\n                this.visitJsxAttribute(node);\n                break;\n            case ts.SyntaxKind.JsxElement:\n                this.visitJsxElement(node);\n                break;\n            case ts.SyntaxKind.JsxExpression:\n                this.visitJsxExpression(node);\n                break;\n            case ts.SyntaxKind.JsxSelfClosingElement:\n                this.visitJsxSelfClosingElement(node);\n                break;\n            case ts.SyntaxKind.JsxSpreadAttribute:\n                this.visitJsxSpreadAttribute(node);\n                break;\n            case ts.SyntaxKind.LabeledStatement:\n                this.visitLabeledStatement(node);\n                break;\n            case ts.SyntaxKind.MethodDeclaration:\n                this.visitMethodDeclaration(node);\n                break;\n            case ts.SyntaxKind.MethodSignature:\n                this.visitMethodSignature(node);\n                break;\n            case ts.SyntaxKind.ModuleDeclaration:\n                this.visitModuleDeclaration(node);\n                break;\n            case ts.SyntaxKind.NamedImports:\n                this.visitNamedImports(node);\n                break;\n            case ts.SyntaxKind.NamespaceImport:\n                this.visitNamespaceImport(node);\n                break;\n            case ts.SyntaxKind.NewExpression:\n                this.visitNewExpression(node);\n                break;\n            case ts.SyntaxKind.NonNullExpression:\n                this.visitNonNullExpression(node);\n                break;\n            case ts.SyntaxKind.NumericLiteral:\n                this.visitNumericLiteral(node);\n                break;\n            case ts.SyntaxKind.ObjectBindingPattern:\n                this.visitBindingPattern(node);\n                break;\n            case ts.SyntaxKind.ObjectLiteralExpression:\n                this.visitObjectLiteralExpression(node);\n                break;\n            case ts.SyntaxKind.Parameter:\n                this.visitParameterDeclaration(node);\n                break;\n            case ts.SyntaxKind.PostfixUnaryExpression:\n                this.visitPostfixUnaryExpression(node);\n                break;\n            case ts.SyntaxKind.PrefixUnaryExpression:\n                this.visitPrefixUnaryExpression(node);\n                break;\n            case ts.SyntaxKind.PropertyAccessExpression:\n                this.visitPropertyAccessExpression(node);\n                break;\n            case ts.SyntaxKind.PropertyAssignment:\n                this.visitPropertyAssignment(node);\n                break;\n            case ts.SyntaxKind.PropertyDeclaration:\n                this.visitPropertyDeclaration(node);\n                break;\n            case ts.SyntaxKind.PropertySignature:\n                this.visitPropertySignature(node);\n                break;\n            case ts.SyntaxKind.RegularExpressionLiteral:\n                this.visitRegularExpressionLiteral(node);\n                break;\n            case ts.SyntaxKind.ReturnStatement:\n                this.visitReturnStatement(node);\n                break;\n            case ts.SyntaxKind.SetAccessor:\n                this.visitSetAccessor(node);\n                break;\n            case ts.SyntaxKind.SourceFile:\n                this.visitSourceFile(node);\n                break;\n            case ts.SyntaxKind.StringLiteral:\n                this.visitStringLiteral(node);\n                break;\n            case ts.SyntaxKind.SwitchStatement:\n                this.visitSwitchStatement(node);\n                break;\n            case ts.SyntaxKind.TemplateExpression:\n                this.visitTemplateExpression(node);\n                break;\n            case ts.SyntaxKind.ThrowStatement:\n                this.visitThrowStatement(node);\n                break;\n            case ts.SyntaxKind.TryStatement:\n                this.visitTryStatement(node);\n                break;\n            case ts.SyntaxKind.TupleType:\n                this.visitTupleType(node);\n                break;\n            case ts.SyntaxKind.TypeAliasDeclaration:\n                this.visitTypeAliasDeclaration(node);\n                break;\n            case ts.SyntaxKind.TypeAssertionExpression:\n                this.visitTypeAssertionExpression(node);\n                break;\n            case ts.SyntaxKind.TypeLiteral:\n                this.visitTypeLiteral(node);\n                break;\n            case ts.SyntaxKind.TypeReference:\n                this.visitTypeReference(node);\n                break;\n            case ts.SyntaxKind.VariableDeclaration:\n                this.visitVariableDeclaration(node);\n                break;\n            case ts.SyntaxKind.VariableDeclarationList:\n                this.visitVariableDeclarationList(node);\n                break;\n            case ts.SyntaxKind.VariableStatement:\n                this.visitVariableStatement(node);\n                break;\n            case ts.SyntaxKind.WhileStatement:\n                this.visitWhileStatement(node);\n                break;\n            case ts.SyntaxKind.WithStatement:\n                this.visitWithStatement(node);\n                break;\n            default:\n                this.walkChildren(node);\n                break;\n        }\n    };\n    SyntaxWalker.prototype.walkChildren = function (node) {\n        var _this = this;\n        ts.forEachChild(node, function (child) { return _this.visitNode(child); });\n    };\n    return SyntaxWalker;\n}());\nexports.SyntaxWalker = SyntaxWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/programAwareRuleWalker.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ruleWalker_1 = require(\"./ruleWalker\");\nvar ProgramAwareRuleWalker = (function (_super) {\n    __extends(ProgramAwareRuleWalker, _super);\n    function ProgramAwareRuleWalker(sourceFile, options, program) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.program = program;\n        _this.typeChecker = program.getTypeChecker();\n        return _this;\n    }\n    ProgramAwareRuleWalker.prototype.getProgram = function () {\n        return this.program;\n    };\n    ProgramAwareRuleWalker.prototype.getTypeChecker = function () {\n        return this.typeChecker;\n    };\n    return ProgramAwareRuleWalker;\n}(ruleWalker_1.RuleWalker));\nexports.ProgramAwareRuleWalker = ProgramAwareRuleWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/walkContext.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rule_1 = require(\"../rule/rule\");\nvar WalkContext = (function () {\n    function WalkContext(sourceFile, ruleName, options) {\n        this.sourceFile = sourceFile;\n        this.ruleName = ruleName;\n        this.options = options;\n        this.failures = [];\n    }\n    /** Add a failure with any arbitrary span. Prefer `addFailureAtNode` if possible. */\n    WalkContext.prototype.addFailureAt = function (start, width, failure, fix) {\n        this.addFailure(start, start + width, failure, fix);\n    };\n    WalkContext.prototype.addFailure = function (start, end, failure, fix) {\n        var fileLength = this.sourceFile.end;\n        this.failures.push(new rule_1.RuleFailure(this.sourceFile, Math.min(start, fileLength), Math.min(end, fileLength), failure, this.ruleName, fix));\n    };\n    /** Add a failure using a node's span. */\n    WalkContext.prototype.addFailureAtNode = function (node, failure, fix) {\n        this.addFailure(node.getStart(this.sourceFile), node.getEnd(), failure, fix);\n    };\n    return WalkContext;\n}());\nexports.WalkContext = WalkContext;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/walker/walker.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar walkContext_1 = require(\"./walkContext\");\nvar AbstractWalker = (function (_super) {\n    __extends(AbstractWalker, _super);\n    function AbstractWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AbstractWalker.prototype.getSourceFile = function () {\n        return this.sourceFile;\n    };\n    AbstractWalker.prototype.getFailures = function () {\n        return this.failures;\n    };\n    return AbstractWalker;\n}(walkContext_1.WalkContext));\nexports.AbstractWalker = AbstractWalker;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/rule/typedRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractRule_1 = require(\"./abstractRule\");\nvar TypedRule = (function (_super) {\n    __extends(TypedRule, _super);\n    function TypedRule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TypedRule.prototype.apply = function () {\n        // if no program is given to the linter, throw an error\n        throw new Error(\"The '\" + this.ruleName + \"' rule requires type checking\");\n    };\n    return TypedRule;\n}(abstractRule_1.AbstractRule));\nexports.TypedRule = TypedRule;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/language/rule/optionallyTypedRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractRule_1 = require(\"./abstractRule\");\nvar OptionallyTypedRule = (function (_super) {\n    __extends(OptionallyTypedRule, _super);\n    function OptionallyTypedRule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return OptionallyTypedRule;\n}(abstractRule_1.AbstractRule));\nexports.OptionallyTypedRule = OptionallyTypedRule;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/test.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar colors = require(\"colors\");\nvar diff = require(\"diff\");\nvar fs = require(\"fs\");\nvar glob = require(\"glob\");\nvar path = require(\"path\");\nvar semver = require(\"semver\");\nvar ts = require(\"typescript\");\nvar rule_1 = require(\"./language/rule/rule\");\nvar Linter = require(\"./linter\");\nvar parse = require(\"./test/parse\");\nvar utils_1 = require(\"./utils\");\nvar MARKUP_FILE_EXTENSION = \".lint\";\nvar FIXES_FILE_EXTENSION = \".fix\";\nfunction runTests(patterns, rulesDirectory) {\n    var files = [];\n    for (var _i = 0, patterns_1 = patterns; _i < patterns_1.length; _i++) {\n        var pattern = patterns_1[_i];\n        files.push.apply(files, glob.sync(pattern + \"/tslint.json\"));\n    }\n    return files.map(function (directory) { return runTest(path.dirname(directory), rulesDirectory); });\n}\nexports.runTests = runTests;\nfunction runTest(testDirectory, rulesDirectory) {\n    // needed to get colors to show up when passing through Grunt\n    colors.enabled = true;\n    var filesToLint = glob.sync(path.join(testDirectory, \"**/*\" + MARKUP_FILE_EXTENSION));\n    var tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"tslint.json\"), \"\").results;\n    var tsConfig = path.join(testDirectory, \"tsconfig.json\");\n    var compilerOptions = { allowJs: true };\n    if (fs.existsSync(tsConfig)) {\n        var _a = ts.readConfigFile(tsConfig, ts.sys.readFile), config = _a.config, error = _a.error;\n        if (error) {\n            throw new Error(JSON.stringify(error));\n        }\n        var parseConfigHost = {\n            fileExists: fs.existsSync,\n            readDirectory: ts.sys.readDirectory,\n            readFile: function (file) { return fs.readFileSync(file, \"utf8\"); },\n            useCaseSensitiveFileNames: true,\n        };\n        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;\n    }\n    var results = { directory: testDirectory, results: {} };\n    var _loop_1 = function (fileToLint) {\n        var fileBasename = path.basename(fileToLint, MARKUP_FILE_EXTENSION);\n        var fileCompileName = fileBasename.replace(/\\.lint$/, \"\");\n        var fileText = fs.readFileSync(fileToLint, \"utf8\");\n        var tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);\n        if (tsVersionRequirement) {\n            var tsVersion = new semver.SemVer(ts.version);\n            // remove prerelease suffix when matching to allow testing with nightly builds\n            if (!semver.satisfies(tsVersion.major + \".\" + tsVersion.minor + \".\" + tsVersion.patch, tsVersionRequirement)) {\n                results.results[fileToLint] = {\n                    requirement: tsVersionRequirement,\n                    skipped: true,\n                };\n                return \"continue\";\n            }\n            // remove the first line from the file before continuing\n            var lineBreak = fileText.search(/\\n/);\n            if (lineBreak === -1) {\n                fileText = \"\";\n            }\n            else {\n                fileText = fileText.substr(lineBreak + 1);\n            }\n        }\n        var fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);\n        var errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);\n        var program = void 0;\n        if (tslintConfig !== undefined && tslintConfig.linterOptions && tslintConfig.linterOptions.typeCheck) {\n            var compilerHost = {\n                fileExists: function () { return true; },\n                getCanonicalFileName: function (filename) { return filename; },\n                getCurrentDirectory: function () { return \"\"; },\n                getDefaultLibFileName: function () { return ts.getDefaultLibFileName(compilerOptions); },\n                getDirectories: function (_path) { return []; },\n                getNewLine: function () { return \"\\n\"; },\n                getSourceFile: function (filenameToGet) {\n                    var target = compilerOptions.target === undefined ? ts.ScriptTarget.ES5 : compilerOptions.target;\n                    if (filenameToGet === ts.getDefaultLibFileName(compilerOptions)) {\n                        var fileContent = fs.readFileSync(ts.getDefaultLibFilePath(compilerOptions)).toString();\n                        return ts.createSourceFile(filenameToGet, fileContent, target);\n                    }\n                    else if (filenameToGet === fileCompileName) {\n                        return ts.createSourceFile(fileBasename, fileTextWithoutMarkup, target, true);\n                    }\n                    else if (fs.existsSync(path.resolve(path.dirname(fileToLint), filenameToGet))) {\n                        var text = fs.readFileSync(path.resolve(path.dirname(fileToLint), filenameToGet), { encoding: \"utf-8\" });\n                        return ts.createSourceFile(filenameToGet, text, target, true);\n                    }\n                    throw new Error(\"Couldn't get source file '\" + filenameToGet + \"'\");\n                },\n                readFile: function (x) { return x; },\n                useCaseSensitiveFileNames: function () { return true; },\n                writeFile: function () { return null; },\n            };\n            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);\n            // perform type checking on the program, updating nodes with symbol table references\n            ts.getPreEmitDiagnostics(program);\n        }\n        var lintOptions = {\n            fix: false,\n            formatter: \"prose\",\n            formattersDirectory: \"\",\n            rulesDirectory: rulesDirectory,\n        };\n        var linter = new Linter(lintOptions, program);\n        linter.lint(fileBasename, fileTextWithoutMarkup, tslintConfig);\n        var failures = linter.getResult().failures;\n        var errorsFromLinter = failures.map(function (failure) {\n            var startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();\n            return {\n                endPos: {\n                    col: endLineAndCharacter.character,\n                    line: endLineAndCharacter.line,\n                },\n                message: failure.getFailure(),\n                startPos: {\n                    col: startLineAndCharacter.character,\n                    line: startLineAndCharacter.line,\n                },\n            };\n        });\n        // test against fixed files\n        var fixedFileText = \"\";\n        var newFileText = \"\";\n        try {\n            var fixedFile = fileToLint.replace(/\\.lint$/, FIXES_FILE_EXTENSION);\n            var stat = fs.statSync(fixedFile);\n            if (stat.isFile()) {\n                fixedFileText = fs.readFileSync(fixedFile, \"utf8\");\n                var fixes = utils_1.mapDefined(failures, function (f) { return f.getFix(); });\n                newFileText = rule_1.Replacement.applyFixes(fileTextWithoutMarkup, fixes);\n            }\n        }\n        catch (e) {\n            fixedFileText = \"\";\n            newFileText = \"\";\n        }\n        results.results[fileToLint] = {\n            errorsFromLinter: errorsFromLinter,\n            errorsFromMarkup: errorsFromMarkup,\n            fixesFromLinter: newFileText,\n            fixesFromMarkup: fixedFileText,\n            markupFromLinter: parse.createMarkupFromErrors(fileTextWithoutMarkup, errorsFromMarkup),\n            markupFromMarkup: parse.createMarkupFromErrors(fileTextWithoutMarkup, errorsFromLinter),\n            skipped: false,\n        };\n    };\n    for (var _i = 0, filesToLint_1 = filesToLint; _i < filesToLint_1.length; _i++) {\n        var fileToLint = filesToLint_1[_i];\n        _loop_1(fileToLint);\n    }\n    return results;\n}\nexports.runTest = runTest;\nfunction consoleTestResultsHandler(testResults) {\n    var didAllTestsPass = true;\n    for (var _i = 0, testResults_1 = testResults; _i < testResults_1.length; _i++) {\n        var testResult = testResults_1[_i];\n        if (!consoleTestResultHandler(testResult)) {\n            didAllTestsPass = false;\n        }\n    }\n    return didAllTestsPass;\n}\nexports.consoleTestResultsHandler = consoleTestResultsHandler;\nfunction consoleTestResultHandler(testResult) {\n    var didAllTestsPass = true;\n    for (var _i = 0, _a = Object.keys(testResult.results); _i < _a.length; _i++) {\n        var fileName = _a[_i];\n        var results = testResult.results[fileName];\n        process.stdout.write(fileName + \":\");\n        /* tslint:disable:no-console */\n        if (results.skipped) {\n            console.log(colors.yellow(\" Skipped, requires typescript \" + results.requirement));\n        }\n        else {\n            var markupDiffResults = diff.diffLines(results.markupFromMarkup, results.markupFromLinter);\n            var fixesDiffResults = diff.diffLines(results.fixesFromLinter, results.fixesFromMarkup);\n            var didMarkupTestPass = !markupDiffResults.some(function (diff) { return !!diff.added || !!diff.removed; });\n            var didFixesTestPass = !fixesDiffResults.some(function (diff) { return !!diff.added || !!diff.removed; });\n            if (didMarkupTestPass && didFixesTestPass) {\n                console.log(colors.green(\" Passed\"));\n            }\n            else {\n                console.log(colors.red(\" Failed!\"));\n                didAllTestsPass = false;\n                if (!didMarkupTestPass) {\n                    displayDiffResults(markupDiffResults, MARKUP_FILE_EXTENSION);\n                }\n                if (!didFixesTestPass) {\n                    displayDiffResults(fixesDiffResults, FIXES_FILE_EXTENSION);\n                }\n            }\n        }\n        /* tslint:enable:no-console */\n    }\n    return didAllTestsPass;\n}\nexports.consoleTestResultHandler = consoleTestResultHandler;\nfunction displayDiffResults(diffResults, extension) {\n    /* tslint:disable:no-console */\n    console.log(colors.green(\"Expected (from \" + extension + \" file)\"));\n    console.log(colors.red(\"Actual (from TSLint)\"));\n    for (var _i = 0, diffResults_1 = diffResults; _i < diffResults_1.length; _i++) {\n        var diffResult = diffResults_1[_i];\n        var color = colors.grey;\n        if (diffResult.added) {\n            color = colors.green.underline;\n        }\n        else if (diffResult.removed) {\n            color = colors.red.underline;\n        }\n        process.stdout.write(color(diffResult.value));\n    }\n    /* tslint:enable:no-console */\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/test/parse.js":"/*\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lines_1 = require(\"./lines\");\nvar lintError_1 = require(\"./lintError\");\nfunction getTypescriptVersionRequirement(text) {\n    var lines = text.split(/\\r?\\n/);\n    var firstLine = lines_1.parseLine(lines[0]);\n    if (firstLine instanceof lines_1.MessageSubstitutionLine && firstLine.key === \"typescript\") {\n        return firstLine.message;\n    }\n    return undefined;\n}\nexports.getTypescriptVersionRequirement = getTypescriptVersionRequirement;\n/**\n * Takes the full text of a .lint file and returns the contents of the file\n * with all error markup removed\n */\nfunction removeErrorMarkup(text) {\n    var textWithMarkup = text.split(\"\\n\");\n    var lines = textWithMarkup.map(lines_1.parseLine);\n    var codeText = lines.filter(function (line) { return (line instanceof lines_1.CodeLine); }).map(function (line) { return line.contents; });\n    return codeText.join(\"\\n\");\n}\nexports.removeErrorMarkup = removeErrorMarkup;\n/* tslint:disable:object-literal-sort-keys */\n/**\n * Takes the full text of a .lint file and returns an array of LintErrors\n * corresponding to the error markup in the file.\n */\nfunction parseErrorsFromMarkup(text) {\n    var textWithMarkup = text.split(\"\\n\");\n    var lines = textWithMarkup.map(lines_1.parseLine);\n    if (lines.length > 0 && !(lines[0] instanceof lines_1.CodeLine)) {\n        throw lintError_1.lintSyntaxError(\"text cannot start with an error mark line.\");\n    }\n    var messageSubstitutionLines = lines.filter(function (l) { return l instanceof lines_1.MessageSubstitutionLine; });\n    var messageSubstitutions = new Map(messageSubstitutionLines.map(function (_a) {\n        var key = _a.key, message = _a.message;\n        return [key, message];\n    }));\n    // errorLineForCodeLine[5] contains all the ErrorLine objects associated with the 5th line of code, for example\n    var errorLinesForCodeLines = createCodeLineNoToErrorsMap(lines);\n    var lintErrors = [];\n    function addError(errorLine, errorStartPos, lineNo) {\n        lintErrors.push({\n            startPos: errorStartPos,\n            endPos: { line: lineNo, col: errorLine.endCol },\n            message: messageSubstitutions.get(errorLine.message) || errorLine.message,\n        });\n    }\n    // for each line of code...\n    errorLinesForCodeLines.forEach(function (errorLinesForLineOfCode, lineNo) {\n        // for each error marking on that line...\n        while (errorLinesForLineOfCode.length > 0) {\n            var errorLine = errorLinesForLineOfCode.shift();\n            var errorStartPos = { line: lineNo, col: errorLine.startCol };\n            // if the error starts and ends on this line, add it now to list of errors\n            if (errorLine instanceof lines_1.EndErrorLine) {\n                addError(errorLine, errorStartPos, lineNo);\n                // if the error is the start of a multiline error\n            }\n            else if (errorLine instanceof lines_1.MultilineErrorLine) {\n                // iterate through the MultilineErrorLines until we get to an EndErrorLine\n                for (var nextLineNo = lineNo + 1;; ++nextLineNo) {\n                    if (!isValidErrorMarkupContinuation(errorLinesForCodeLines, nextLineNo)) {\n                        throw lintError_1.lintSyntaxError(\"Error mark starting at \" + errorStartPos.line + \":\" + errorStartPos.col + \" does not end correctly.\");\n                    }\n                    else {\n                        var nextErrorLine = errorLinesForCodeLines[nextLineNo].shift();\n                        // if end of multiline error, add it it list of errors\n                        if (nextErrorLine instanceof lines_1.EndErrorLine) {\n                            addError(nextErrorLine, errorStartPos, nextLineNo);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    });\n    lintErrors.sort(lintError_1.errorComparator);\n    return lintErrors;\n}\nexports.parseErrorsFromMarkup = parseErrorsFromMarkup;\nfunction createMarkupFromErrors(code, lintErrors) {\n    lintErrors.sort(lintError_1.errorComparator);\n    var codeText = code.split(\"\\n\");\n    var errorLinesForCodeText = codeText.map(function () { return []; });\n    for (var _i = 0, lintErrors_1 = lintErrors; _i < lintErrors_1.length; _i++) {\n        var error = lintErrors_1[_i];\n        var startPos = error.startPos, endPos = error.endPos, message = error.message;\n        if (startPos.line === endPos.line) {\n            // single line error\n            errorLinesForCodeText[startPos.line].push(new lines_1.EndErrorLine(startPos.col, endPos.col, message));\n        }\n        else {\n            // multiline error\n            errorLinesForCodeText[startPos.line].push(new lines_1.MultilineErrorLine(startPos.col));\n            for (var lineNo = startPos.line + 1; lineNo < endPos.line; ++lineNo) {\n                errorLinesForCodeText[lineNo].push(new lines_1.MultilineErrorLine(0));\n            }\n            errorLinesForCodeText[endPos.line].push(new lines_1.EndErrorLine(0, endPos.col, message));\n        }\n    }\n    var finalText = combineCodeTextAndErrorLines(codeText, errorLinesForCodeText);\n    return finalText.join(\"\\n\");\n}\nexports.createMarkupFromErrors = createMarkupFromErrors;\n/* tslint:enable:object-literal-sort-keys */\nfunction combineCodeTextAndErrorLines(codeText, errorLinesForCodeText) {\n    return codeText.reduce(function (resultText, code, i) {\n        resultText.push(code);\n        var errorPrintLines = errorLinesForCodeText[i].map(function (line) { return lines_1.printLine(line, code); }).filter(function (line) { return line !== null; });\n        resultText.push.apply(resultText, errorPrintLines);\n        return resultText;\n    }, []);\n}\nfunction createCodeLineNoToErrorsMap(lines) {\n    var errorLinesForCodeLine = [];\n    for (var _i = 0, lines_2 = lines; _i < lines_2.length; _i++) {\n        var line = lines_2[_i];\n        if (line instanceof lines_1.CodeLine) {\n            errorLinesForCodeLine.push([]);\n        }\n        else if (line instanceof lines_1.ErrorLine) {\n            errorLinesForCodeLine[errorLinesForCodeLine.length - 1].push(line);\n        }\n    }\n    return errorLinesForCodeLine;\n}\nfunction isValidErrorMarkupContinuation(errorLinesForCodeLines, lineNo) {\n    return lineNo < errorLinesForCodeLines.length\n        && errorLinesForCodeLines[lineNo].length !== 0\n        && errorLinesForCodeLines[lineNo][0].startCol === 0;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/test/lines.js":"/*\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Use classes here instead of interfaces because we want runtime type data\nvar Line = (function () {\n    function Line() {\n    }\n    return Line;\n}());\nexports.Line = Line;\nvar CodeLine = (function (_super) {\n    __extends(CodeLine, _super);\n    function CodeLine(contents) {\n        var _this = _super.call(this) || this;\n        _this.contents = contents;\n        return _this;\n    }\n    return CodeLine;\n}(Line));\nexports.CodeLine = CodeLine;\nvar MessageSubstitutionLine = (function (_super) {\n    __extends(MessageSubstitutionLine, _super);\n    function MessageSubstitutionLine(key, message) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.message = message;\n        return _this;\n    }\n    return MessageSubstitutionLine;\n}(Line));\nexports.MessageSubstitutionLine = MessageSubstitutionLine;\nvar ErrorLine = (function (_super) {\n    __extends(ErrorLine, _super);\n    function ErrorLine(startCol) {\n        var _this = _super.call(this) || this;\n        _this.startCol = startCol;\n        return _this;\n    }\n    return ErrorLine;\n}(Line));\nexports.ErrorLine = ErrorLine;\nvar MultilineErrorLine = (function (_super) {\n    __extends(MultilineErrorLine, _super);\n    function MultilineErrorLine(startCol) {\n        return _super.call(this, startCol) || this;\n    }\n    return MultilineErrorLine;\n}(ErrorLine));\nexports.MultilineErrorLine = MultilineErrorLine;\nvar EndErrorLine = (function (_super) {\n    __extends(EndErrorLine, _super);\n    function EndErrorLine(startCol, endCol, message) {\n        var _this = _super.call(this, startCol) || this;\n        _this.endCol = endCol;\n        _this.message = message;\n        return _this;\n    }\n    return EndErrorLine;\n}(ErrorLine));\nexports.EndErrorLine = EndErrorLine;\n// example matches (between the quotes):\n// \"    ~~~~~~~~\"\nvar multilineErrorRegex = /^\\s*(~+|~nil)$/;\n// \"    ~~~~~~~~~   [some error message]\"\nvar endErrorRegex = /^\\s*(~+|~nil)\\s*\\[(.+)\\]\\s*$/;\n// \"[shortcut]: full messages goes here!!  \"\nvar messageSubstitutionRegex = /^\\[([\\w\\-\\_]+?)]: \\s*(.+?)\\s*$/;\nexports.ZERO_LENGTH_ERROR = \"~nil\";\n/**\n * Maps a line of text from a .lint file to an appropriate Line object\n */\nfunction parseLine(text) {\n    var multilineErrorMatch = text.match(multilineErrorRegex);\n    if (multilineErrorMatch != null) {\n        var startErrorCol = text.indexOf(\"~\");\n        return new MultilineErrorLine(startErrorCol);\n    }\n    var endErrorMatch = text.match(endErrorRegex);\n    if (endErrorMatch != null) {\n        var squiggles = endErrorMatch[1], message = endErrorMatch[2];\n        var startErrorCol = text.indexOf(\"~\");\n        var zeroLengthError = (squiggles === exports.ZERO_LENGTH_ERROR);\n        var endErrorCol = zeroLengthError ? startErrorCol : text.lastIndexOf(\"~\") + 1;\n        return new EndErrorLine(startErrorCol, endErrorCol, message);\n    }\n    var messageSubstitutionMatch = text.match(messageSubstitutionRegex);\n    if (messageSubstitutionMatch != null) {\n        var key = messageSubstitutionMatch[1], message = messageSubstitutionMatch[2];\n        return new MessageSubstitutionLine(key, message);\n    }\n    // line doesn't match any syntax for error markup, so it's a line of code to be linted\n    return new CodeLine(text);\n}\nexports.parseLine = parseLine;\n/**\n * Maps a Line object to a matching line of text that could be in a .lint file.\n * This is almost the inverse of parseLine.\n * If you ran `printLine(parseLine(someText), code)`, the whitespace in the result may be different than in someText\n * @param line - A Line object to convert to text\n * @param code - If line represents error markup, this is the line of code preceding the markup.\n *               Otherwise, this parameter is not required.\n */\nfunction printLine(line, code) {\n    if (line instanceof ErrorLine) {\n        if (code == null) {\n            throw new Error(\"Must supply argument for code parameter when line is an ErrorLine\");\n        }\n        var leadingSpaces = \" \".repeat(line.startCol);\n        if (line instanceof MultilineErrorLine) {\n            // special case for when the line of code is simply a newline.\n            // use \"~nil\" to indicate the error continues on that line\n            if (code.length === 0 && line.startCol === 0) {\n                return exports.ZERO_LENGTH_ERROR;\n            }\n            var tildes = \"~\".repeat(code.length - leadingSpaces.length);\n            return \"\" + leadingSpaces + tildes;\n        }\n        else if (line instanceof EndErrorLine) {\n            var tildes = \"~\".repeat(line.endCol - line.startCol);\n            if (code.length < line.endCol) {\n                // Better than crashing in String.repeat\n                throw new Error(\"Bad error marker at \" + JSON.stringify(line));\n            }\n            var endSpaces = \" \".repeat(code.length - line.endCol);\n            if (tildes.length === 0) {\n                tildes = exports.ZERO_LENGTH_ERROR;\n                // because we add \"~nil\" we need four less spaces than normal at the end\n                // always make sure we have at least one space though\n                endSpaces = endSpaces.substring(0, Math.max(endSpaces.length - 4, 1));\n            }\n            return \"\" + leadingSpaces + tildes + endSpaces + \" [\" + line.message + \"]\";\n        }\n    }\n    else if (line instanceof MessageSubstitutionLine) {\n        return \"[\" + line.key + \"]: \" + line.message;\n    }\n    else if (line instanceof CodeLine) {\n        return line.contents;\n    }\n    return null;\n}\nexports.printLine = printLine;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/test/lintError.js":"/*\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar error_1 = require(\"../error\");\nfunction errorComparator(err1, err2) {\n    if (err1.startPos.line !== err2.startPos.line) {\n        return err1.startPos.line - err2.startPos.line;\n    }\n    else if (err1.startPos.col !== err2.startPos.col) {\n        return err1.startPos.col - err2.startPos.col;\n    }\n    else if (err1.endPos.line !== err2.endPos.line) {\n        return err1.endPos.line - err2.endPos.line;\n    }\n    else if (err1.endPos.col !== err2.endPos.col) {\n        return err1.endPos.col - err2.endPos.col;\n    }\n    else {\n        return err1.message.localeCompare(err2.message);\n    }\n}\nexports.errorComparator = errorComparator;\nfunction lintSyntaxError(message) {\n    return new error_1.Error(\"Lint File Syntax Error: \" + message);\n}\nexports.lintSyntaxError = lintSyntaxError;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/runner.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\nvar glob = require(\"glob\");\nvar path = require(\"path\");\nvar ts = require(\"typescript\");\nvar configuration_1 = require(\"./configuration\");\nvar error_1 = require(\"./error\");\nvar Linter = require(\"./linter\");\nvar test_1 = require(\"./test\");\nvar Runner = (function () {\n    function Runner(options, outputStream) {\n        this.options = options;\n        this.outputStream = outputStream;\n    }\n    Runner.trimSingleQuotes = function (str) {\n        return str.replace(/^'|'$/g, \"\");\n    };\n    Runner.prototype.run = function (onComplete) {\n        if (this.options.version) {\n            this.outputStream.write(Linter.VERSION + \"\\n\");\n            return onComplete(0);\n        }\n        if (this.options.init) {\n            if (fs.existsSync(configuration_1.CONFIG_FILENAME)) {\n                console.error(\"Cannot generate \" + configuration_1.CONFIG_FILENAME + \": file already exists\");\n                return onComplete(1);\n            }\n            var tslintJSON = JSON.stringify(configuration_1.DEFAULT_CONFIG, undefined, \"    \");\n            fs.writeFileSync(configuration_1.CONFIG_FILENAME, tslintJSON);\n            return onComplete(0);\n        }\n        if (this.options.test) {\n            var results = test_1.runTests((this.options.files || []).map(Runner.trimSingleQuotes), this.options.rulesDirectory);\n            var didAllTestsPass = test_1.consoleTestResultsHandler(results);\n            return onComplete(didAllTestsPass ? 0 : 1);\n        }\n        // when provided, it should point to an existing location\n        if (this.options.config && !fs.existsSync(this.options.config)) {\n            console.error(\"Invalid option for configuration: \" + this.options.config);\n            return onComplete(1);\n        }\n        // if both files and tsconfig are present, use files\n        var files = this.options.files === undefined ? [] : this.options.files;\n        var program;\n        if (this.options.project != null) {\n            if (!fs.existsSync(this.options.project)) {\n                console.error(\"Invalid option for project: \" + this.options.project);\n                return onComplete(1);\n            }\n            program = Linter.createProgram(this.options.project);\n            if (files.length === 0) {\n                files = Linter.getFileNames(program);\n            }\n            if (this.options.typeCheck) {\n                // if type checking, run the type checker\n                var diagnostics = ts.getPreEmitDiagnostics(program);\n                if (diagnostics.length > 0) {\n                    var messages = diagnostics.map(function (diag) {\n                        // emit any error messages\n                        var message = ts.DiagnosticCategory[diag.category];\n                        if (diag.file) {\n                            var _a = diag.file.getLineAndCharacterOfPosition(diag.start), line = _a.line, character = _a.character;\n                            message += \" at \" + diag.file.fileName + \":\" + (line + 1) + \":\" + (character + 1) + \":\";\n                        }\n                        message += \" \" + ts.flattenDiagnosticMessageText(diag.messageText, \"\\n\");\n                        return message;\n                    });\n                    console.error(messages.join(\"\\n\"));\n                    return onComplete(this.options.force ? 0 : 1);\n                }\n            }\n            else {\n                // if not type checking, we don't need to pass in a program object\n                program = undefined;\n            }\n        }\n        else if (this.options.typeCheck) {\n            console.error(\"--project must be specified in order to enable type checking.\");\n            return onComplete(1);\n        }\n        var ignorePatterns = [];\n        if (this.options.exclude) {\n            var excludeArguments = Array.isArray(this.options.exclude) ? this.options.exclude : [this.options.exclude];\n            ignorePatterns = excludeArguments.map(Runner.trimSingleQuotes);\n        }\n        files = files\n            .map(Runner.trimSingleQuotes)\n            .map(function (file) { return glob.sync(file, { ignore: ignorePatterns, nodir: true }); })\n            .reduce(function (a, b) { return a.concat(b); }, []);\n        try {\n            this.processFiles(onComplete, files, program);\n        }\n        catch (error) {\n            if (error.name === error_1.FatalError.NAME) {\n                console.error(error.message);\n                return onComplete(1);\n            }\n            // rethrow unhandled error\n            throw error;\n        }\n    };\n    Runner.prototype.processFiles = function (onComplete, files, program) {\n        var _this = this;\n        var possibleConfigAbsolutePath = this.options.config != null ? path.resolve(this.options.config) : null;\n        var linter = new Linter({\n            fix: !!this.options.fix,\n            formatter: this.options.format,\n            formattersDirectory: this.options.formattersDirectory || \"\",\n            rulesDirectory: this.options.rulesDirectory || \"\",\n        }, program);\n        var lastFolder;\n        var configFile;\n        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {\n            var file = files_1[_i];\n            if (!fs.existsSync(file)) {\n                console.error(\"Unable to open file: \" + file);\n                return onComplete(1);\n            }\n            var buffer = new Buffer(256);\n            var fd = fs.openSync(file, \"r\");\n            try {\n                fs.readSync(fd, buffer, 0, 256, 0);\n                if (buffer.readInt8(0, true) === 0x47 && buffer.readInt8(188, true) === 0x47) {\n                    // MPEG transport streams use the '.ts' file extension. They use 0x47 as the frame\n                    // separator, repeating every 188 bytes. It is unlikely to find that pattern in\n                    // TypeScript source, so tslint ignores files with the specific pattern.\n                    console.warn(file + \": ignoring MPEG transport stream\");\n                    continue;\n                }\n            }\n            finally {\n                fs.closeSync(fd);\n            }\n            var contents = fs.readFileSync(file, \"utf8\");\n            var folder = path.dirname(file);\n            if (lastFolder !== folder) {\n                configFile = configuration_1.findConfiguration(possibleConfigAbsolutePath, folder).results;\n                lastFolder = folder;\n            }\n            linter.lint(file, contents, configFile);\n        }\n        var lintResult = linter.getResult();\n        this.outputStream.write(lintResult.output, function () {\n            if (_this.options.force || lintResult.errorCount === 0) {\n                onComplete(0);\n            }\n            else {\n                onComplete(2);\n            }\n        });\n    };\n    return Runner;\n}());\nexports.Runner = Runner;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/tslint-cli.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\nvar optimist = require(\"optimist\");\nvar runner_1 = require(\"./runner\");\nvar processed = optimist\n    .usage(\"Usage: $0 [options] file ...\")\n    .check(function (argv) {\n    // at least one of file, help, version, project or unqualified argument must be present\n    if (!(argv.h || argv.i || argv.test || argv.v || argv.project || argv._.length > 0)) {\n        // throw a string, otherwise a call stack is printed for this message\n        // tslint:disable-next-line:no-string-throw\n        throw \"Missing files\";\n    }\n    if (argv.f) {\n        // throw a string, otherwise a call stack is printed for this message\n        // tslint:disable-next-line:no-string-throw\n        throw \"-f option is no longer available. Supply files directly to the tslint command instead.\";\n    }\n})\n    .options({\n    \"c\": {\n        alias: \"config\",\n        describe: \"configuration file\",\n        type: \"string\",\n    },\n    \"e\": {\n        alias: \"exclude\",\n        describe: \"exclude globs from path expansion\",\n        type: \"string\",\n    },\n    \"fix\": {\n        describe: \"fixes linting errors for select rules (this may overwrite linted files)\",\n        type: \"boolean\",\n    },\n    \"force\": {\n        describe: \"return status code 0 even if there are lint errors\",\n        type: \"boolean\",\n    },\n    \"h\": {\n        alias: \"help\",\n        describe: \"display detailed help\",\n        type: \"boolean\",\n    },\n    \"i\": {\n        alias: \"init\",\n        describe: \"generate a tslint.json config file in the current working directory\",\n        type: \"boolean\",\n    },\n    \"o\": {\n        alias: \"out\",\n        describe: \"output file\",\n        type: \"string\",\n    },\n    \"p\": {\n        alias: \"project\",\n        describe: \"tsconfig.json file\",\n        type: \"string\",\n    },\n    \"r\": {\n        alias: \"rules-dir\",\n        describe: \"rules directory\",\n        type: \"string\",\n    },\n    \"s\": {\n        alias: \"formatters-dir\",\n        describe: \"formatters directory\",\n        type: \"string\",\n    },\n    \"t\": {\n        alias: \"format\",\n        default: \"prose\",\n        describe: \"output format (prose, json, stylish, verbose, pmd, msbuild, checkstyle, vso, fileslist, codeFrame)\",\n        type: \"string\",\n    },\n    \"test\": {\n        describe: \"test that tslint produces the correct output for the specified directory\",\n        type: \"boolean\",\n    },\n    \"type-check\": {\n        describe: \"enable type checking when linting a project\",\n        type: \"boolean\",\n    },\n    \"v\": {\n        alias: \"version\",\n        describe: \"current version\",\n        type: \"boolean\",\n    },\n});\nvar argv = processed.argv;\nvar outputStream;\nif (argv.o != null) {\n    outputStream = fs.createWriteStream(argv.o, {\n        flags: \"w+\",\n        mode: 420,\n    });\n}\nelse {\n    outputStream = process.stdout;\n}\nif (argv.help) {\n    outputStream.write(processed.help());\n    var outputString = \"\\ntslint accepts the following commandline options:\\n\\n    -c, --config:\\n        The location of the configuration file that tslint will use to\\n        determine which rules are activated and what options to provide\\n        to the rules. If no option is specified, the config file named\\n        tslint.json is used, so long as it exists in the path.\\n        The format of the file is { rules: { /* rules list */ } },\\n        where /* rules list */ is a key: value comma-seperated list of\\n        rulename: rule-options pairs. Rule-options can be either a\\n        boolean true/false value denoting whether the rule is used or not,\\n        or a list [boolean, ...] where the boolean provides the same role\\n        as in the non-list case, and the rest of the list are options passed\\n        to the rule that will determine what it checks for (such as number\\n        of characters for the max-line-length rule, or what functions to ban\\n        for the ban rule).\\n\\n    -e, --exclude:\\n        A filename or glob which indicates files to exclude from linting.\\n        This option can be supplied multiple times if you need multiple\\n        globs to indicate which files to exclude.\\n\\n    --fix:\\n        Fixes linting errors for select rules. This may overwrite linted files.\\n\\n    --force:\\n        Return status code 0 even if there are any lint errors.\\n        Useful while running as npm script.\\n\\n    -i, --init:\\n        Generates a tslint.json config file in the current working directory.\\n\\n    -o, --out:\\n        A filename to output the results to. By default, tslint outputs to\\n        stdout, which is usually the console where you're running it from.\\n\\n    -r, --rules-dir:\\n        An additional rules directory, for user-created rules.\\n        tslint will always check its default rules directory, in\\n        node_modules/tslint/lib/rules, before checking the user-provided\\n        rules directory, so rules in the user-provided rules directory\\n        with the same name as the base rules will not be loaded.\\n\\n    -s, --formatters-dir:\\n        An additional formatters directory, for user-created formatters.\\n        Formatters are files that will format the tslint output, before\\n        writing it to stdout or the file passed in --out. The default\\n        directory, node_modules/tslint/build/formatters, will always be\\n        checked first, so user-created formatters with the same names\\n        as the base formatters will not be loaded.\\n\\n    -t, --format:\\n        The formatter to use to format the results of the linter before\\n        outputting it to stdout or the file passed in --out. The core\\n        formatters are prose (human readable), json (machine readable)\\n        and verbose. prose is the default if this option is not used.\\n        Other built-in options include pmd, msbuild, checkstyle, and vso.\\n        Additional formatters can be added and used if the --formatters-dir\\n        option is set.\\n\\n    --test:\\n        Runs tslint on matched directories and checks if tslint outputs\\n        match the expected output in .lint files. Automatically loads the\\n        tslint.json files in the directories as the configuration file for\\n        the tests. See the full tslint documentation for more details on how\\n        this can be used to test custom rules.\\n\\n    -p, --project:\\n        The location of a tsconfig.json file that will be used to determine which\\n        files will be linted.\\n\\n    --type-check\\n        Enables the type checker when running linting rules. --project must be\\n        specified in order to enable type checking.\\n\\n    -v, --version:\\n        The current version of tslint.\\n\\n    -h, --help:\\n        Prints this help message.\\n\";\n    outputStream.write(outputString);\n    process.exit(0);\n}\nvar options = {\n    config: argv.c,\n    exclude: argv.exclude,\n    files: argv._,\n    fix: argv.fix,\n    force: argv.force,\n    format: argv.t,\n    formattersDirectory: argv.s,\n    init: argv.init,\n    out: argv.out,\n    project: argv.p,\n    rulesDirectory: argv.r,\n    test: argv.test,\n    typeCheck: argv[\"type-check\"],\n    version: argv.v,\n};\nnew runner_1.Runner(options, outputStream)\n    .run(function (status) { return process.exit(status); });\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/configs/all.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"path\");\nvar ruleLoader_1 = require(\"../ruleLoader\");\n// tslint:disable object-literal-sort-keys\n// tslint:disable object-literal-key-quotes\nexports.rules = {\n    // TypeScript Specific\n    \"adjacent-overload-signatures\": true,\n    \"ban-types\": {\n        options: [\n            [\"Object\", \"Avoid using the `Object` type. Did you mean `object`?\"],\n            [\"Function\", \"Avoid using the `Function` type. Prefer a specific function type, like `() => void`.\"],\n            [\"Boolean\", \"Avoid using the `Boolean` type. Did you mean `boolean`?\"],\n            [\"Number\", \"Avoid using the `Number` type. Did you mean `number`?\"],\n            [\"String\", \"Avoid using the `String` type. Did you mean `string`?\"],\n            [\"Symbol\", \"Avoid using the `Symbol` type. Did you mean `symbol`?\"],\n        ],\n    },\n    \"member-access\": [true, \"check-accessor\", \"check-constructor\"],\n    \"member-ordering\": [true, {\n            \"order\": \"statics-first\",\n            \"alphabetize\": true,\n        }],\n    \"no-any\": true,\n    \"no-empty-interface\": true,\n    \"no-import-side-effect\": true,\n    // Technically this is not the strictest setting, but don't want to conflict with \"typedef\"\n    \"no-inferrable-types\": [true, \"ignore-params\"],\n    \"no-internal-module\": true,\n    \"no-magic-numbers\": true,\n    \"no-namespace\": true,\n    \"no-non-null-assertion\": true,\n    \"no-reference\": true,\n    \"no-var-requires\": true,\n    \"only-arrow-functions\": true,\n    \"prefer-for-of\": true,\n    \"promise-function-async\": true,\n    \"typedef\": [\n        true,\n        \"call-signature\",\n        \"arrow-call-signature\",\n        \"parameter\",\n        \"arrow-parameter\",\n        \"property-declaration\",\n        \"variable-declaration\",\n        \"member-variable-declaration\",\n    ],\n    \"typedef-whitespace\": [true, {\n            \"call-signature\": \"nospace\",\n            \"index-signature\": \"nospace\",\n            \"parameter\": \"nospace\",\n            \"property-declaration\": \"nospace\",\n            \"variable-declaration\": \"nospace\",\n        }, {\n            \"call-signature\": \"onespace\",\n            \"index-signature\": \"onespace\",\n            \"parameter\": \"onespace\",\n            \"property-declaration\": \"onespace\",\n            \"variable-declaration\": \"onespace\",\n        }],\n    \"unified-signatures\": true,\n    // Functionality\n    \"await-promise\": true,\n    // \"ban\": no sensible default\n    \"curly\": true,\n    \"forin\": true,\n    // \"import-blacklist\": no sensible default\n    \"label-position\": true,\n    \"no-arg\": true,\n    \"no-bitwise\": true,\n    \"no-conditional-assignment\": true,\n    \"no-console\": true,\n    \"no-construct\": true,\n    \"no-debugger\": true,\n    \"no-duplicate-super\": true,\n    \"no-duplicate-variable\": true,\n    \"no-empty\": true,\n    \"no-eval\": true,\n    \"no-floating-promises\": true,\n    \"no-for-in-array\": true,\n    \"no-inferred-empty-object-type\": true,\n    \"no-invalid-template-strings\": true,\n    // \"no-invalid-this\": Won't this be deprecated?\n    \"no-misused-new\": true,\n    \"no-null-keyword\": true,\n    \"no-shadowed-variable\": true,\n    \"no-string-literal\": true,\n    \"no-string-throw\": true,\n    \"no-sparse-arrays\": true,\n    \"no-unbound-method\": true,\n    \"no-unsafe-any\": true,\n    \"no-unsafe-finally\": true,\n    \"no-unused-expression\": true,\n    \"no-unused-variable\": true,\n    \"no-use-before-declare\": true,\n    \"no-var-keyword\": true,\n    \"no-void-expression\": true,\n    \"radix\": true,\n    \"restrict-plus-operands\": true,\n    \"strict-boolean-expressions\": true,\n    \"strict-type-predicates\": true,\n    \"switch-default\": true,\n    \"triple-equals\": true,\n    \"use-isnan\": true,\n    // Maintainability\n    \"cyclomatic-complexity\": true,\n    \"eofline\": true,\n    \"indent\": [true, \"spaces\"],\n    \"linebreak-style\": [true, \"LF\"],\n    \"max-classes-per-file\": [true, 1],\n    \"max-file-line-count\": [true, 1000],\n    \"max-line-length\": [true, 120],\n    \"no-default-export\": true,\n    \"no-mergeable-namespace\": true,\n    \"no-require-imports\": true,\n    \"no-trailing-whitespace\": true,\n    \"object-literal-sort-keys\": true,\n    \"prefer-const\": true,\n    \"trailing-comma\": [true, {\n            \"multiline\": \"always\",\n            \"singleline\": \"never\",\n        }],\n    // Style\n    \"align\": [true,\n        \"parameters\",\n        \"arguments\",\n        \"statements\",\n    ],\n    \"array-type\": [true, \"array-simple\"],\n    \"arrow-parens\": true,\n    \"arrow-return-shorthand\": [true, \"multiline\"],\n    \"callable-types\": true,\n    \"class-name\": true,\n    \"comment-format\": [\n        true,\n        \"check-space\",\n        \"check-uppercase\",\n    ],\n    \"completed-docs\": true,\n    // \"file-header\": No sensible default\n    \"import-spacing\": true,\n    \"interface-name\": true,\n    \"interface-over-type-literal\": true,\n    \"jsdoc-format\": true,\n    \"match-default-export-name\": true,\n    \"new-parens\": true,\n    \"newline-before-return\": true,\n    \"no-angle-bracket-type-assertion\": true,\n    \"no-boolean-literal-compare\": true,\n    \"no-consecutive-blank-lines\": true,\n    \"no-parameter-properties\": true,\n    \"no-reference-import\": true,\n    \"no-unnecessary-callback-wrapper\": true,\n    \"no-unnecessary-initializer\": true,\n    \"no-unnecessary-qualifier\": true,\n    \"object-literal-key-quotes\": [true, \"consistent-as-needed\"],\n    \"object-literal-shorthand\": true,\n    \"one-line\": [true,\n        \"check-catch\",\n        \"check-else\",\n        \"check-finally\",\n        \"check-open-brace\",\n        \"check-whitespace\",\n    ],\n    \"one-variable-per-declaration\": true,\n    \"ordered-imports\": [true, {\n            \"import-sources-order\": \"case-insensitive\",\n            \"named-imports-order\": \"case-insensitive\",\n        }],\n    \"prefer-function-over-method\": true,\n    \"prefer-method-signature\": true,\n    \"prefer-template\": true,\n    \"quotemark\": [true, \"double\", \"avoid-escape\"],\n    \"return-undefined\": true,\n    \"semicolon\": [true, \"always\"],\n    \"space-before-function-paren\": [true, {\n            \"anonymous\": \"never\",\n            \"asyncArrow\": \"always\",\n            \"constructor\": \"never\",\n            \"method\": \"never\",\n            \"named\": \"never\",\n        }],\n    \"variable-name\": [\n        true,\n        \"ban-keywords\",\n        \"check-format\",\n    ],\n    \"whitespace\": [\n        true,\n        \"check-branch\",\n        \"check-decl\",\n        \"check-operator\",\n        \"check-module\",\n        \"check-separator\",\n        \"check-type\",\n        \"check-typecast\",\n        \"check-preblock\",\n    ],\n};\nexports.RULES_EXCLUDED_FROM_ALL_CONFIG = [\"ban\", \"fileHeader\", \"importBlacklist\", \"noInvalidThis\", \"noSwitchCaseFallThrough\", \"typeofCompare\"];\n// Exclude typescript-only rules from jsRules, otherwise it's identical.\nexports.jsRules = {};\nfor (var key in exports.rules) {\n    if (!Object.prototype.hasOwnProperty.call(exports.rules, key)) {\n        continue;\n    }\n    var Rule = ruleLoader_1.findRule(key, path_1.join(__dirname, \"..\", \"rules\"));\n    if (!Rule.metadata.typescriptOnly) {\n        exports.jsRules[key] = exports.rules[key];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/adjacentOverloadSignaturesRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new AdjacentOverloadSignaturesWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"adjacent-overload-signatures\",\n    description: \"Enforces function overloads to be consecutive.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    rationale: \"Improves readability and organization by grouping naturally related items together.\",\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (name) {\n    return \"All '\" + name + \"' signatures should be adjacent\";\n};\nexports.Rule = Rule;\nvar AdjacentOverloadSignaturesWalker = (function (_super) {\n    __extends(AdjacentOverloadSignaturesWalker, _super);\n    function AdjacentOverloadSignaturesWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AdjacentOverloadSignaturesWalker.prototype.visitSourceFile = function (node) {\n        this.visitStatements(node.statements);\n        _super.prototype.visitSourceFile.call(this, node);\n    };\n    AdjacentOverloadSignaturesWalker.prototype.visitModuleDeclaration = function (node) {\n        var body = node.body;\n        if (body && body.kind === ts.SyntaxKind.ModuleBlock) {\n            this.visitStatements(body.statements);\n        }\n        _super.prototype.visitModuleDeclaration.call(this, node);\n    };\n    AdjacentOverloadSignaturesWalker.prototype.visitInterfaceDeclaration = function (node) {\n        this.checkOverloadsAdjacent(node.members, getOverloadIfSignature);\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    AdjacentOverloadSignaturesWalker.prototype.visitClassDeclaration = function (node) {\n        this.visitMembers(node.members);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    AdjacentOverloadSignaturesWalker.prototype.visitTypeLiteral = function (node) {\n        this.visitMembers(node.members);\n        _super.prototype.visitTypeLiteral.call(this, node);\n    };\n    AdjacentOverloadSignaturesWalker.prototype.visitStatements = function (statements) {\n        this.checkOverloadsAdjacent(statements, function (statement) {\n            if (statement.kind === ts.SyntaxKind.FunctionDeclaration) {\n                var name = statement.name;\n                return name && { name: name.text, key: name.text };\n            }\n            else {\n                return undefined;\n            }\n        });\n    };\n    AdjacentOverloadSignaturesWalker.prototype.visitMembers = function (members) {\n        this.checkOverloadsAdjacent(members, getOverloadIfSignature);\n    };\n    /** 'getOverloadName' may return undefined for nodes that cannot be overloads, e.g. a `const` declaration. */\n    AdjacentOverloadSignaturesWalker.prototype.checkOverloadsAdjacent = function (overloads, getOverload) {\n        var lastKey;\n        var seen = new Set();\n        for (var _i = 0, overloads_1 = overloads; _i < overloads_1.length; _i++) {\n            var node = overloads_1[_i];\n            var overload = getOverload(node);\n            if (overload) {\n                var name = overload.name, key = overload.key;\n                if (seen.has(key) && lastKey !== key) {\n                    this.addFailureAtNode(node, Rule.FAILURE_STRING_FACTORY(name));\n                }\n                seen.add(key);\n                lastKey = key;\n            }\n            else {\n                lastKey = undefined;\n            }\n        }\n    };\n    return AdjacentOverloadSignaturesWalker;\n}(Lint.RuleWalker));\nfunction getOverloadKey(node) {\n    var o = getOverload(node);\n    return o && o.key;\n}\nexports.getOverloadKey = getOverloadKey;\nfunction getOverloadIfSignature(node) {\n    return utils.isSignatureDeclaration(node) ? getOverload(node) : undefined;\n}\nfunction getOverload(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ConstructSignature:\n        case ts.SyntaxKind.Constructor:\n            return { name: \"constructor\", key: \"constructor\" };\n        case ts.SyntaxKind.CallSignature:\n            return { name: \"()\", key: \"()\" };\n        default:\n    }\n    if (node.name === undefined) {\n        return undefined;\n    }\n    var propertyInfo = getPropertyInfo(node.name);\n    if (!propertyInfo) {\n        return undefined;\n    }\n    var name = propertyInfo.name, computed = propertyInfo.computed;\n    var isStatic = Lint.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword);\n    var key = (computed ? \"0\" : \"1\") + (isStatic ? \"0\" : \"1\") + name;\n    return { name: name, key: key };\n}\nfunction getPropertyInfo(name) {\n    switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n            return { name: name.text };\n        case ts.SyntaxKind.ComputedPropertyName:\n            var expression = name.expression;\n            return utils.isLiteralExpression(expression) ? { name: expression.text } : { name: expression.getText(), computed: true };\n        default:\n            return utils.isLiteralExpression(name) ? { name: name.text } : undefined;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/banTypesRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (typeName, messageAddition) {\n        return \"Don't use '\" + typeName + \"' as a type.\" +\n            (messageAddition ? \" \" + messageAddition : \"\");\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new BanTypeWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"ban-types\",\n    description: (_a = [\"\\n            Bans specific types from being used. Does not ban the\\n            corresponding runtime objects from being used.\"], _a.raw = [\"\\n            Bans specific types from being used. Does not ban the\\n            corresponding runtime objects from being used.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"list\",\n        listType: {\n            type: \"array\",\n            items: { type: \"string\" },\n            minLength: 1,\n            maxLength: 2,\n        },\n    },\n    optionsDescription: (_b = [\"\\n            A list of `[\\\"regex\\\", \\\"optional explanation here\\\"]`, which bans\\n            types that match `regex`\"], _b.raw = [\"\\n            A list of \\\\`[\\\"regex\\\", \\\"optional explanation here\\\"]\\\\`, which bans\\n            types that match \\\\`regex\\\\`\"], Lint.Utils.dedent(_b)),\n    optionExamples: [\"[true, [\\\"Object\\\", \\\"Use {} instead.\\\"], [\\\"String\\\"]]\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar BanTypeWalker = (function (_super) {\n    __extends(BanTypeWalker, _super);\n    function BanTypeWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.bans = options.ruleArguments;\n        return _this;\n    }\n    BanTypeWalker.prototype.visitTypeReference = function (node) {\n        var typeName = node.typeName.getText();\n        var ban = this.bans.find(function (_a) {\n            var bannedType = _a[0];\n            return typeName.match(\"^\" + bannedType + \"$\") != null;\n        });\n        if (ban) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING_FACTORY(typeName, ban[1]));\n        }\n        _super.prototype.visitTypeReference.call(this, node);\n    };\n    return BanTypeWalker;\n}(Lint.RuleWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/memberAccessRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_NO_PUBLIC = \"no-public\";\nvar OPTION_CHECK_ACCESSOR = \"check-accessor\";\nvar OPTION_CHECK_CONSTRUCTOR = \"check-constructor\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.FAILURE_STRING_FACTORY = function (memberType, memberName) {\n        memberName = memberName === undefined ? \"\" : \" '\" + memberName + \"'\";\n        return \"The \" + memberType + memberName + \" must be marked either 'private', 'public', or 'protected'\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var options = this.ruleArguments;\n        var noPublic = options.indexOf(OPTION_NO_PUBLIC) !== -1;\n        var checkAccessor = options.indexOf(OPTION_CHECK_ACCESSOR) !== -1;\n        var checkConstructor = options.indexOf(OPTION_CHECK_CONSTRUCTOR) !== -1;\n        if (noPublic) {\n            if (checkAccessor || checkConstructor) {\n                throw new Error(\"If 'no-public' is present, it should be the only option.\");\n            }\n            checkAccessor = checkConstructor = true;\n        }\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, noPublic, checkAccessor, checkConstructor); });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"member-access\",\n    description: \"Requires explicit visibility declarations for class members.\",\n    rationale: \"Explicit visibility declarations can make code more readable and accessible for those new to TS.\",\n    optionsDescription: (_a = [\"\\n            These arguments may be optionally provided:\\n\\n            * `\\\"no-public\\\"` forbids public accessibility to be specified, because this is the default.\\n            * `\\\"check-accessor\\\"` enforces explicit visibility on get/set accessors\\n            * `\\\"check-constructor\\\"`  enforces explicit visibility on constructors\"], _a.raw = [\"\\n            These arguments may be optionally provided:\\n\\n            * \\\\`\\\"no-public\\\"\\\\` forbids public accessibility to be specified, because this is the default.\\n            * \\\\`\\\"check-accessor\\\"\\\\` enforces explicit visibility on get/set accessors\\n            * \\\\`\\\"check-constructor\\\"\\\\`  enforces explicit visibility on constructors\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_NO_PUBLIC, OPTION_CHECK_ACCESSOR, OPTION_CHECK_CONSTRUCTOR],\n        },\n        minLength: 0,\n        maxLength: 3,\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + OPTION_NO_PUBLIC + \"\\\"]\", \"[true, \\\"\" + OPTION_CHECK_ACCESSOR + \"\\\"]\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_NO_PUBLIC = \"'public' is implicit.\";\nexports.Rule = Rule;\nfunction walk(ctx, noPublic, checkAccessor, checkConstructor) {\n    return ts.forEachChild(ctx.sourceFile, function recur(node) {\n        if (tsutils_1.isClassLikeDeclaration(node)) {\n            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {\n                var child = _a[_i];\n                if (shouldCheck(child)) {\n                    check(child);\n                }\n            }\n        }\n        return ts.forEachChild(node, recur);\n    });\n    function shouldCheck(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.Constructor:\n                return checkConstructor;\n            case ts.SyntaxKind.GetAccessor:\n            case ts.SyntaxKind.SetAccessor:\n                return checkAccessor;\n            case ts.SyntaxKind.MethodDeclaration:\n            case ts.SyntaxKind.PropertyDeclaration:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function check(node) {\n        if (Lint.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword)) {\n            return;\n        }\n        var isPublic = Lint.hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword);\n        if (noPublic && isPublic) {\n            var publicKeyword = node.modifiers.find(function (m) { return m.kind === ts.SyntaxKind.PublicKeyword; });\n            ctx.addFailureAtNode(publicKeyword, Rule.FAILURE_STRING_NO_PUBLIC);\n        }\n        if (!noPublic && !isPublic) {\n            var nameNode = tsutils_1.isConstructorDeclaration(node) ? tsutils_1.getChildOfKind(node, ts.SyntaxKind.ConstructorKeyword) : node.name || node;\n            var memberName = node.name && tsutils_1.isIdentifier(node.name) ? node.name.text : undefined;\n            ctx.addFailureAtNode(nameNode, Rule.FAILURE_STRING_FACTORY(memberType(node), memberName));\n        }\n    }\n}\nfunction memberType(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.MethodDeclaration:\n            return \"class method\";\n        case ts.SyntaxKind.PropertyDeclaration:\n            return \"class property\";\n        case ts.SyntaxKind.Constructor:\n            return \"class constructor\";\n        case ts.SyntaxKind.GetAccessor:\n            return \"get property accessor\";\n        case ts.SyntaxKind.SetAccessor:\n            return \"set property accessor\";\n        default:\n            throw new Error(\"unhandled node type \" + ts.SyntaxKind[node.kind]);\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/memberOrderingRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../utils\");\nvar OPTION_ORDER = \"order\";\nvar OPTION_ALPHABETIZE = \"alphabetize\";\nvar MemberKind;\n(function (MemberKind) {\n    MemberKind[MemberKind[\"publicStaticField\"] = 0] = \"publicStaticField\";\n    MemberKind[MemberKind[\"publicStaticMethod\"] = 1] = \"publicStaticMethod\";\n    MemberKind[MemberKind[\"protectedStaticField\"] = 2] = \"protectedStaticField\";\n    MemberKind[MemberKind[\"protectedStaticMethod\"] = 3] = \"protectedStaticMethod\";\n    MemberKind[MemberKind[\"privateStaticField\"] = 4] = \"privateStaticField\";\n    MemberKind[MemberKind[\"privateStaticMethod\"] = 5] = \"privateStaticMethod\";\n    MemberKind[MemberKind[\"publicInstanceField\"] = 6] = \"publicInstanceField\";\n    MemberKind[MemberKind[\"protectedInstanceField\"] = 7] = \"protectedInstanceField\";\n    MemberKind[MemberKind[\"privateInstanceField\"] = 8] = \"privateInstanceField\";\n    MemberKind[MemberKind[\"publicConstructor\"] = 9] = \"publicConstructor\";\n    MemberKind[MemberKind[\"protectedConstructor\"] = 10] = \"protectedConstructor\";\n    MemberKind[MemberKind[\"privateConstructor\"] = 11] = \"privateConstructor\";\n    MemberKind[MemberKind[\"publicInstanceMethod\"] = 12] = \"publicInstanceMethod\";\n    MemberKind[MemberKind[\"protectedInstanceMethod\"] = 13] = \"protectedInstanceMethod\";\n    MemberKind[MemberKind[\"privateInstanceMethod\"] = 14] = \"privateInstanceMethod\";\n})(MemberKind || (MemberKind = {}));\nvar PRESETS = new Map([\n    [\"fields-first\", [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"private-static-field\",\n            \"public-instance-field\",\n            \"protected-instance-field\",\n            \"private-instance-field\",\n            \"constructor\",\n            \"public-static-method\",\n            \"protected-static-method\",\n            \"private-static-method\",\n            \"public-instance-method\",\n            \"protected-instance-method\",\n            \"private-instance-method\",\n        ]],\n    [\"instance-sandwich\", [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"private-static-field\",\n            \"public-instance-field\",\n            \"protected-instance-field\",\n            \"private-instance-field\",\n            \"constructor\",\n            \"public-instance-method\",\n            \"protected-instance-method\",\n            \"private-instance-method\",\n            \"public-static-method\",\n            \"protected-static-method\",\n            \"private-static-method\",\n        ]],\n    [\"statics-first\", [\n            \"public-static-field\",\n            \"public-static-method\",\n            \"protected-static-field\",\n            \"protected-static-method\",\n            \"private-static-field\",\n            \"private-static-method\",\n            \"public-instance-field\",\n            \"protected-instance-field\",\n            \"private-instance-field\",\n            \"constructor\",\n            \"public-instance-method\",\n            \"protected-instance-method\",\n            \"private-instance-method\",\n        ]],\n]);\nvar PRESET_NAMES = Array.from(PRESETS.keys());\nvar allMemberKindNames = utils_1.mapDefined(Object.keys(MemberKind), function (key) {\n    var mk = MemberKind[key];\n    return typeof mk === \"number\" ? MemberKind[mk].replace(/[A-Z]/g, function (cap) { return \"-\" + cap.toLowerCase(); }) : undefined;\n});\nfunction namesMarkdown(names) {\n    return names.map(function (name) { return \"* `\" + name + \"`\"; }).join(\"\\n    \");\n}\nvar optionsDescription = (_a = [\"\\n    One argument, which is an object, must be provided. It should contain an `order` property.\\n    The `order` property should have a value of one of the following strings:\\n\\n    \", \"\\n\\n    Alternatively, the value for `order` maybe be an array consisting of the following strings:\\n\\n    \", \"\\n\\n    You can also omit the access modifier to refer to \\\"public-\\\", \\\"protected-\\\", and \\\"private-\\\" all at once; for example, \\\"static-field\\\".\\n\\n    You can also make your own categories by using an object instead of a string:\\n\\n        {\\n            \\\"name\\\": \\\"static non-private\\\",\\n            \\\"kinds\\\": [\\n                \\\"public-static-field\\\",\\n                \\\"protected-static-field\\\",\\n                \\\"public-static-method\\\",\\n                \\\"protected-static-method\\\"\\n            ]\\n        }\\n\\n    The '\", \"' option will enforce that members within the same category should be alphabetically sorted by name.\"], _a.raw = [\"\\n    One argument, which is an object, must be provided. It should contain an \\\\`order\\\\` property.\\n    The \\\\`order\\\\` property should have a value of one of the following strings:\\n\\n    \", \"\\n\\n    Alternatively, the value for \\\\`order\\\\` maybe be an array consisting of the following strings:\\n\\n    \", \"\\n\\n    You can also omit the access modifier to refer to \\\"public-\\\", \\\"protected-\\\", and \\\"private-\\\" all at once; for example, \\\"static-field\\\".\\n\\n    You can also make your own categories by using an object instead of a string:\\n\\n        {\\n            \\\"name\\\": \\\"static non-private\\\",\\n            \\\"kinds\\\": [\\n                \\\"public-static-field\\\",\\n                \\\"protected-static-field\\\",\\n                \\\"public-static-method\\\",\\n                \\\"protected-static-method\\\"\\n            ]\\n        }\\n\\n    The '\", \"' option will enforce that members within the same category should be alphabetically sorted by name.\"], Lint.Utils.dedent(_a, namesMarkdown(PRESET_NAMES), namesMarkdown(allMemberKindNames), OPTION_ALPHABETIZE));\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.FAILURE_STRING_ALPHABETIZE = function (prevName, curName) {\n        return show(curName) + \" should come alphabetically before \" + show(prevName);\n        function show(s) {\n            return s === \"\" ? \"Computed property\" : \"'\" + s + \"'\";\n        }\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new MemberOrderingWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"member-ordering\",\n    description: \"Enforces member ordering.\",\n    rationale: \"A consistent ordering for class members can make classes easier to read, navigate, and edit.\",\n    optionsDescription: optionsDescription,\n    options: {\n        type: \"object\",\n        properties: {\n            order: {\n                oneOf: [{\n                        type: \"string\",\n                        enum: PRESET_NAMES,\n                    }, {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            enum: allMemberKindNames,\n                        },\n                        maxLength: 13,\n                    }],\n            },\n        },\n        additionalProperties: false,\n    },\n    optionExamples: [\n        '[true, { \"order\": \"fields-first\" }]',\n        (_b = [\"\\n                [true, {\\n                    \\\"order\\\": [\\n                        \\\"static-field\\\",\\n                        \\\"instance-field\\\",\\n                        \\\"constructor\\\",\\n                        \\\"public-instance-method\\\",\\n                        \\\"protected-instance-method\\\",\\n                        \\\"private-instance-method\\\"\\n                    ]\\n                }]\"], _b.raw = [\"\\n                [true, {\\n                    \\\"order\\\": [\\n                        \\\"static-field\\\",\\n                        \\\"instance-field\\\",\\n                        \\\"constructor\\\",\\n                        \\\"public-instance-method\\\",\\n                        \\\"protected-instance-method\\\",\\n                        \\\"private-instance-method\\\"\\n                    ]\\n                }]\"], Lint.Utils.dedent(_b)),\n        (_c = [\"\\n                [true, {\\n                    \\\"order\\\": [\\n                        {\\n                            \\\"name\\\": \\\"static non-private\\\",\\n                            \\\"kinds\\\": [\\n                                \\\"public-static-field\\\",\\n                                \\\"protected-static-field\\\",\\n                                \\\"public-static-method\\\",\\n                                \\\"protected-static-method\\\"\\n                            ]\\n                        },\\n                        \\\"constructor\\\"\\n                    ]\\n                }]\"], _c.raw = [\"\\n                [true, {\\n                    \\\"order\\\": [\\n                        {\\n                            \\\"name\\\": \\\"static non-private\\\",\\n                            \\\"kinds\\\": [\\n                                \\\"public-static-field\\\",\\n                                \\\"protected-static-field\\\",\\n                                \\\"public-static-method\\\",\\n                                \\\"protected-static-method\\\"\\n                            ]\\n                        },\\n                        \\\"constructor\\\"\\n                    ]\\n                }]\"], Lint.Utils.dedent(_c)),\n    ],\n    type: \"typescript\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nvar MemberOrderingWalker = (function (_super) {\n    __extends(MemberOrderingWalker, _super);\n    function MemberOrderingWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.opts = parseOptions(_this.getOptions());\n        return _this;\n    }\n    MemberOrderingWalker.prototype.visitClassDeclaration = function (node) {\n        this.visitMembers(node.members);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    MemberOrderingWalker.prototype.visitClassExpression = function (node) {\n        this.visitMembers(node.members);\n        _super.prototype.visitClassExpression.call(this, node);\n    };\n    MemberOrderingWalker.prototype.visitInterfaceDeclaration = function (node) {\n        this.visitMembers(node.members);\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    MemberOrderingWalker.prototype.visitTypeLiteral = function (node) {\n        this.visitMembers(node.members);\n        _super.prototype.visitTypeLiteral.call(this, node);\n    };\n    MemberOrderingWalker.prototype.visitMembers = function (members) {\n        var prevRank = -1;\n        var prevName;\n        for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n            var member = members_1[_i];\n            var rank = this.memberRank(member);\n            if (rank === -1) {\n                // no explicit ordering for this kind of node specified, so continue\n                continue;\n            }\n            if (rank < prevRank) {\n                var nodeType = this.rankName(rank);\n                var prevNodeType = this.rankName(prevRank);\n                var lowerRank = this.findLowerRank(members, rank);\n                var locationHint = lowerRank !== -1\n                    ? \"after \" + this.rankName(lowerRank) + \"s\"\n                    : \"at the beginning of the class/interface\";\n                var errorLine1 = \"Declaration of \" + nodeType + \" not allowed after declaration of \" + prevNodeType + \". \" +\n                    (\"Instead, this should come \" + locationHint + \".\");\n                this.addFailureAtNode(member, errorLine1);\n            }\n            else {\n                if (this.opts.alphabetize && member.name) {\n                    if (rank !== prevRank) {\n                        // No alphabetical ordering between different ranks\n                        prevName = undefined;\n                    }\n                    var curName = nameString(member.name);\n                    if (prevName !== undefined && caseInsensitiveLess(curName, prevName)) {\n                        this.addFailureAtNode(member.name, Rule.FAILURE_STRING_ALPHABETIZE(this.findLowerName(members, rank, curName), curName));\n                    }\n                    else {\n                        prevName = curName;\n                    }\n                }\n                // keep track of last good node\n                prevRank = rank;\n            }\n        }\n    };\n    /** Finds the lowest name higher than 'targetName'. */\n    MemberOrderingWalker.prototype.findLowerName = function (members, targetRank, targetName) {\n        for (var _i = 0, members_2 = members; _i < members_2.length; _i++) {\n            var member = members_2[_i];\n            if (!member.name || this.memberRank(member) !== targetRank) {\n                continue;\n            }\n            var name = nameString(member.name);\n            if (caseInsensitiveLess(targetName, name)) {\n                return name;\n            }\n        }\n        throw new Error(\"Expected to find a name\");\n    };\n    /** Finds the highest existing rank lower than `targetRank`. */\n    MemberOrderingWalker.prototype.findLowerRank = function (members, targetRank) {\n        var max = -1;\n        for (var _i = 0, members_3 = members; _i < members_3.length; _i++) {\n            var member = members_3[_i];\n            var rank = this.memberRank(member);\n            if (rank !== -1 && rank < targetRank) {\n                max = Math.max(max, rank);\n            }\n        }\n        return max;\n    };\n    MemberOrderingWalker.prototype.memberRank = function (member) {\n        var optionName = getMemberKind(member);\n        if (optionName === undefined) {\n            return -1;\n        }\n        return this.opts.order.findIndex(function (category) { return category.has(optionName); });\n    };\n    MemberOrderingWalker.prototype.rankName = function (rank) {\n        return this.opts.order[rank].name;\n    };\n    return MemberOrderingWalker;\n}(Lint.RuleWalker));\nexports.MemberOrderingWalker = MemberOrderingWalker;\nfunction caseInsensitiveLess(a, b) {\n    return a.toLowerCase() < b.toLowerCase();\n}\nfunction memberKindForConstructor(access) {\n    return MemberKind[access + \"Constructor\"];\n}\nfunction memberKindForMethodOrField(access, membership, kind) {\n    return MemberKind[access + membership + kind];\n}\nvar allAccess = [\"public\", \"protected\", \"private\"];\nfunction memberKindFromName(name) {\n    var kind = MemberKind[Lint.Utils.camelize(name)];\n    return typeof kind === \"number\" ? [kind] : allAccess.map(addModifier);\n    function addModifier(modifier) {\n        var modifiedKind = MemberKind[Lint.Utils.camelize(modifier + \"-\" + name)];\n        if (typeof modifiedKind !== \"number\") {\n            throw new Error(\"Bad member kind: \" + name);\n        }\n        return modifiedKind;\n    }\n}\nfunction getMemberKind(member) {\n    var accessLevel = hasModifier(ts.SyntaxKind.PrivateKeyword) ? \"private\"\n        : hasModifier(ts.SyntaxKind.ProtectedKeyword) ? \"protected\"\n            : \"public\";\n    switch (member.kind) {\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.ConstructSignature:\n            return memberKindForConstructor(accessLevel);\n        case ts.SyntaxKind.PropertyDeclaration:\n        case ts.SyntaxKind.PropertySignature:\n            return methodOrField(isFunctionLiteral(member.initializer));\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.MethodSignature:\n            return methodOrField(true);\n        default:\n            return undefined;\n    }\n    function methodOrField(isMethod) {\n        var membership = hasModifier(ts.SyntaxKind.StaticKeyword) ? \"Static\" : \"Instance\";\n        return memberKindForMethodOrField(accessLevel, membership, isMethod ? \"Method\" : \"Field\");\n    }\n    function hasModifier(kind) {\n        return Lint.hasModifier(member.modifiers, kind);\n    }\n}\nvar MemberCategory = (function () {\n    function MemberCategory(name, kinds) {\n        this.name = name;\n        this.kinds = kinds;\n    }\n    MemberCategory.prototype.has = function (kind) { return this.kinds.has(kind); };\n    return MemberCategory;\n}());\nfunction parseOptions(options) {\n    var _a = getOptionsJson(options), orderJson = _a.order, alphabetize = _a.alphabetize;\n    var order = orderJson.map(function (cat) { return typeof cat === \"string\"\n        ? new MemberCategory(cat.replace(/-/g, \" \"), new Set(memberKindFromName(cat)))\n        : new MemberCategory(cat.name, new Set(utils_1.flatMap(cat.kinds, memberKindFromName))); });\n    return { order: order, alphabetize: alphabetize };\n}\nfunction getOptionsJson(allOptions) {\n    if (allOptions == null || allOptions.length === 0 || allOptions[0] == null) {\n        throw new Error(\"Got empty options\");\n    }\n    var firstOption = allOptions[0];\n    if (typeof firstOption !== \"object\") {\n        // Undocumented direct string option. Deprecate eventually.\n        return { order: convertFromOldStyleOptions(allOptions), alphabetize: false }; // presume allOptions to be string[]\n    }\n    return { order: categoryFromOption(firstOption[OPTION_ORDER]), alphabetize: !!firstOption[OPTION_ALPHABETIZE] };\n}\nfunction categoryFromOption(orderOption) {\n    if (Array.isArray(orderOption)) {\n        return orderOption;\n    }\n    var preset = PRESETS.get(orderOption);\n    if (!preset) {\n        throw new Error(\"Bad order: \" + JSON.stringify(orderOption));\n    }\n    return preset;\n}\n/**\n * Convert from undocumented old-style options.\n * This is designed to mimic the old behavior and should be removed eventually.\n */\nfunction convertFromOldStyleOptions(options) {\n    var categories = [{ name: \"member\", kinds: allMemberKindNames }];\n    if (hasOption(\"variables-before-functions\")) {\n        categories = splitOldStyleOptions(categories, function (kind) { return kind.includes(\"field\"); }, \"field\", \"method\");\n    }\n    if (hasOption(\"static-before-instance\")) {\n        categories = splitOldStyleOptions(categories, function (kind) { return kind.includes(\"static\"); }, \"static\", \"instance\");\n    }\n    if (hasOption(\"public-before-private\")) {\n        // 'protected' is considered public\n        categories = splitOldStyleOptions(categories, function (kind) { return !kind.includes(\"private\"); }, \"public\", \"private\");\n    }\n    return categories;\n    function hasOption(x) {\n        return options.indexOf(x) !== -1;\n    }\n}\nfunction splitOldStyleOptions(categories, filter, a, b) {\n    var newCategories = [];\n    var _loop_1 = function (cat) {\n        var yes = [];\n        var no = [];\n        for (var _i = 0, _a = cat.kinds; _i < _a.length; _i++) {\n            var kind = _a[_i];\n            if (filter(kind)) {\n                yes.push(kind);\n            }\n            else {\n                no.push(kind);\n            }\n        }\n        var augmentName = function (s) {\n            if (a === \"field\") {\n                // Replace \"member\" with \"field\"/\"method\" instead of augmenting.\n                return s;\n            }\n            return s + \" \" + cat.name;\n        };\n        newCategories.push({ name: augmentName(a), kinds: yes });\n        newCategories.push({ name: augmentName(b), kinds: no });\n    };\n    for (var _i = 0, categories_1 = categories; _i < categories_1.length; _i++) {\n        var cat = categories_1[_i];\n        _loop_1(cat);\n    }\n    return newCategories;\n}\nfunction isFunctionLiteral(node) {\n    switch (node && node.kind) {\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.FunctionExpression:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction nameString(name) {\n    switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.NumericLiteral:\n            return name.text;\n        default:\n            return \"\";\n    }\n}\nvar _a, _b, _c;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noAnyRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-any\",\n    description: \"Disallows usages of `any` as a type declaration.\",\n    hasFix: true,\n    rationale: \"Using `any` as a type declaration nullifies the compile-time benefits of the type system.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Type declaration of 'any' loses type-safety. \" +\n    \"Consider replacing it with a more precise type, the empty type ('{}'), \" +\n    \"or suppress this occurrence.\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.AnyKeyword) {\n            var start = node.end - 3;\n            return ctx.addFailure(start, node.end, Rule.FAILURE_STRING, new Lint.Replacement(start, 3, \"{}\"));\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noEmptyInterfaceRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-empty-interface\",\n    description: \"Forbids empty interfaces.\",\n    rationale: \"An empty interface is equivalent to its supertype (or `{}`).\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"An empty interface is equivalent to `{}`.\";\nRule.FAILURE_STRING_FOR_EXTENDS = \"An interface declaring no members is equivalent to its supertype.\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isInterfaceDeclaration(node) &&\n            node.members.length === 0 &&\n            (node.heritageClauses === undefined ||\n                node.heritageClauses[0].types === undefined ||\n                // allow interfaces that extend 2 or more interfaces\n                node.heritageClauses[0].types.length < 2)) {\n            return ctx.addFailureAtNode(node.name, node.heritageClauses ? Rule.FAILURE_STRING_FOR_EXTENDS : Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noImportSideEffectRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar Lint = require(\"../index\");\nvar OPTION_IGNORE_MODULE = \"ignore-module\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var patternConfig = this.ruleArguments[this.ruleArguments.length - 1];\n        var ignorePattern = patternConfig && new RegExp(patternConfig[OPTION_IGNORE_MODULE]);\n        return this.applyWithFunction(sourceFile, walk, ignorePattern);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    description: \"Avoid import statements with side-effect.\",\n    optionExamples: [\"true\", \"[true, { \\\"\" + OPTION_IGNORE_MODULE + \"\\\": \\\"(\\\\.html|\\\\.css)$\\\" }]\"],\n    options: {\n        items: {\n            properties: {\n                \"ignore-module\": {\n                    type: \"string\",\n                },\n            },\n            type: \"object\",\n        },\n        maxLength: 1,\n        minLength: 0,\n        type: \"array\",\n    },\n    optionsDescription: (_a = [\"\\n            One argument may be optionally provided:\\n\\n            * `\", \"` allows to specify a regex and ignore modules which it matches.\"], _a.raw = [\"\\n            One argument may be optionally provided:\\n\\n            * \\\\`\", \"\\\\` allows to specify a regex and ignore modules which it matches.\"], Lint.Utils.dedent(_a, OPTION_IGNORE_MODULE)),\n    rationale: \"Imports with side effects may have behavior which is hard for static verification.\",\n    ruleName: \"no-import-side-effect\",\n    type: \"typescript\",\n    typescriptOnly: false,\n};\nRule.FAILURE_STRING = \"import with explicit side-effect\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var ignorePattern = ctx.options, sourceFile = ctx.sourceFile;\n    for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {\n        var statement = _a[_i];\n        if (!utils.isImportDeclaration(statement)) {\n            continue;\n        }\n        var importClause = statement.importClause, moduleSpecifier = statement.moduleSpecifier;\n        if (importClause || !utils.isStringLiteral(moduleSpecifier)) {\n            continue;\n        }\n        if (!ignorePattern || !ignorePattern.test(moduleSpecifier.text)) {\n            ctx.addFailureAtNode(statement, Rule.FAILURE_STRING);\n        }\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noInferrableTypesRule.js":"/**\n * @license\n * Copyright 2015 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_IGNORE_PARMS = \"ignore-params\";\nvar OPTION_IGNORE_PROPERTIES = \"ignore-properties\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoInferrableTypesWalker(sourceFile, this.ruleName, {\n            ignoreParameters: this.ruleArguments.indexOf(OPTION_IGNORE_PARMS) !== -1,\n            ignoreProperties: this.ruleArguments.indexOf(OPTION_IGNORE_PROPERTIES) !== -1,\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-inferrable-types\",\n    description: \"Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean.\",\n    rationale: \"Explicit types where they can be easily inferred by the compiler make code more verbose.\",\n    optionsDescription: (_a = [\"\\n            Two arguments may be optionally provided:\\n\\n            * `\", \"` allows specifying an inferrable type annotation for function params.\\n            This can be useful when combining with the `typedef` rule.\\n            * `\", \"` allows specifying an inferrable type annotation for class properties.\"], _a.raw = [\"\\n            Two arguments may be optionally provided:\\n\\n            * \\\\`\", \"\\\\` allows specifying an inferrable type annotation for function params.\\n            This can be useful when combining with the \\\\`typedef\\\\` rule.\\n            * \\\\`\", \"\\\\` allows specifying an inferrable type annotation for class properties.\"], Lint.Utils.dedent(_a, OPTION_IGNORE_PARMS, OPTION_IGNORE_PROPERTIES)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_IGNORE_PARMS, OPTION_IGNORE_PROPERTIES],\n        },\n        minLength: 0,\n        maxLength: 2,\n    },\n    hasFix: true,\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"\" + OPTION_IGNORE_PARMS + \"\\\"]\",\n        \"[true, \\\"\" + OPTION_IGNORE_PARMS + \"\\\", \\\"\" + OPTION_IGNORE_PROPERTIES + \"\\\"]\",\n    ],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (type) {\n    return \"Type \" + type + \" trivially inferred from a \" + type + \" literal, remove type annotation\";\n};\nexports.Rule = Rule;\nvar NoInferrableTypesWalker = (function (_super) {\n    __extends(NoInferrableTypesWalker, _super);\n    function NoInferrableTypesWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoInferrableTypesWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            switch (node.kind) {\n                case ts.SyntaxKind.Parameter:\n                    if (!_this.options.ignoreParameters &&\n                        !tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.ReadonlyKeyword) &&\n                        // \"ignore-properties\" also works for parameter properties\n                        (!_this.options.ignoreProperties || !tsutils_1.hasAccessModifier(node))) {\n                        _this.checkDeclaration(node);\n                    }\n                    break;\n                case ts.SyntaxKind.PropertyDeclaration:\n                    if (_this.options.ignoreProperties ||\n                        tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.ReadonlyKeyword)) {\n                        break;\n                    }\n                /* falls through*/\n                case ts.SyntaxKind.VariableDeclaration:\n                    _this.checkDeclaration(node);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    NoInferrableTypesWalker.prototype.checkDeclaration = function (node) {\n        if (node.type != null && node.initializer != null) {\n            var failure = null;\n            switch (node.type.kind) {\n                case ts.SyntaxKind.BooleanKeyword:\n                    if (node.initializer.kind === ts.SyntaxKind.TrueKeyword || node.initializer.kind === ts.SyntaxKind.FalseKeyword) {\n                        failure = \"boolean\";\n                    }\n                    break;\n                case ts.SyntaxKind.NumberKeyword:\n                    if (node.initializer.kind === ts.SyntaxKind.NumericLiteral) {\n                        failure = \"number\";\n                    }\n                    break;\n                case ts.SyntaxKind.StringKeyword:\n                    switch (node.initializer.kind) {\n                        case ts.SyntaxKind.StringLiteral:\n                        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n                        case ts.SyntaxKind.TemplateExpression:\n                            failure = \"string\";\n                            break;\n                        default:\n                            break;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            if (failure != null) {\n                this.addFailureAtNode(node.type, Rule.FAILURE_STRING_FACTORY(failure), Lint.Replacement.deleteFromTo(node.name.end, node.type.end));\n            }\n        }\n    };\n    return NoInferrableTypesWalker;\n}(Lint.AbstractWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noInternalModuleRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoInternalModuleWalker(sourceFile, this.ruleName, undefined));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-internal-module\",\n    description: \"Disallows internal `module`\",\n    rationale: \"Using `module` leads to a confusion of concepts with external modules. Use the newer `namespace` keyword instead.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"The internal 'module' syntax is deprecated, use the 'namespace' keyword instead.\";\nexports.Rule = Rule;\nvar NoInternalModuleWalker = (function (_super) {\n    __extends(NoInternalModuleWalker, _super);\n    function NoInternalModuleWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoInternalModuleWalker.prototype.walk = function (sourceFile) {\n        return this.checkStatements(sourceFile.statements);\n    };\n    NoInternalModuleWalker.prototype.checkStatements = function (statements) {\n        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {\n            var statement = statements_1[_i];\n            if (statement.kind === ts.SyntaxKind.ModuleDeclaration) {\n                this.checkModuleDeclaration(statement);\n            }\n        }\n    };\n    NoInternalModuleWalker.prototype.checkModuleDeclaration = function (node, nested) {\n        if (!nested &&\n            node.name.kind === ts.SyntaxKind.Identifier &&\n            // augmenting global uses a special syntax that is allowed\n            // see https://github.com/Microsoft/TypeScript/pull/6213\n            node.name.text !== \"global\") {\n            var moduleKeyword = tsutils_1.getChildOfKind(node, ts.SyntaxKind.ModuleKeyword, this.sourceFile);\n            if (moduleKeyword) {\n                this.addFailureAtNode(moduleKeyword, Rule.FAILURE_STRING);\n            }\n        }\n        if (node.body !== undefined) {\n            switch (node.body.kind) {\n                case ts.SyntaxKind.ModuleBlock:\n                    return this.checkStatements(node.body.statements);\n                case ts.SyntaxKind.ModuleDeclaration:\n                    return this.checkModuleDeclaration(node.body, true);\n            }\n        }\n    };\n    return NoInternalModuleWalker;\n}(Lint.AbstractWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noMagicNumbersRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var allowedNumbers = this.ruleArguments.length > 0 ? this.ruleArguments : Rule.DEFAULT_ALLOWED;\n        return this.applyWithWalker(new NoMagicNumbersWalker(sourceFile, this.ruleName, new Set(allowedNumbers.map(String))));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-magic-numbers\",\n    description: (_a = [\"\\n            Disallows the use constant number values outside of variable assignments.\\n            When no list of allowed values is specified, -1, 0 and 1 are allowed by default.\"], _a.raw = [\"\\n            Disallows the use constant number values outside of variable assignments.\\n            When no list of allowed values is specified, -1, 0 and 1 are allowed by default.\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            Magic numbers should be avoided as they often lack documentation, forcing\\n            them to be stored in variables gives them implicit documentation.\"], _b.raw = [\"\\n            Magic numbers should be avoided as they often lack documentation, forcing\\n            them to be stored in variables gives them implicit documentation.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: \"A list of allowed numbers.\",\n    options: {\n        type: \"array\",\n        items: {\n            type: \"number\",\n        },\n        minLength: 1,\n    },\n    optionExamples: [\"true\", \"[true, 1, 2, 3]\"],\n    type: \"typescript\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"'magic numbers' are not allowed\";\nRule.ALLOWED_NODES = new Set([\n    ts.SyntaxKind.ExportAssignment,\n    ts.SyntaxKind.FirstAssignment,\n    ts.SyntaxKind.LastAssignment,\n    ts.SyntaxKind.PropertyAssignment,\n    ts.SyntaxKind.ShorthandPropertyAssignment,\n    ts.SyntaxKind.VariableDeclaration,\n    ts.SyntaxKind.VariableDeclarationList,\n    ts.SyntaxKind.EnumMember,\n    ts.SyntaxKind.PropertyDeclaration,\n    ts.SyntaxKind.Parameter,\n]);\nRule.DEFAULT_ALLOWED = [-1, 0, 1];\nexports.Rule = Rule;\nvar NoMagicNumbersWalker = (function (_super) {\n    __extends(NoMagicNumbersWalker, _super);\n    function NoMagicNumbersWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoMagicNumbersWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (node.kind === ts.SyntaxKind.NumericLiteral) {\n                return _this.checkNumericLiteral(node, node.text);\n            }\n            if (tsutils_1.isPrefixUnaryExpression(node) &&\n                node.operator === ts.SyntaxKind.MinusToken &&\n                node.operand.kind === ts.SyntaxKind.NumericLiteral) {\n                return _this.checkNumericLiteral(node, \"-\" + node.operand.text);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    NoMagicNumbersWalker.prototype.checkNumericLiteral = function (node, num) {\n        if (!Rule.ALLOWED_NODES.has(node.parent.kind) && !this.options.has(num)) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n    };\n    return NoMagicNumbersWalker;\n}(Lint.AbstractWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noNamespaceRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_DECLARATIONS = \"allow-declarations\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, {\n            allowDeclarations: this.ruleArguments.indexOf(OPTION_ALLOW_DECLARATIONS) !== -1,\n        });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-namespace\",\n    description: \"Disallows use of internal \\`module\\`s and \\`namespace\\`s.\",\n    descriptionDetails: \"This rule still allows the use of `declare module ... {}`\",\n    rationale: (_a = [\"\\n            ES6-style external modules are the standard way to modularize code.\\n            Using `module {}` and `namespace {}` are outdated ways to organize TypeScript code.\"], _a.raw = [\"\\n            ES6-style external modules are the standard way to modularize code.\\n            Using \\\\`module {}\\\\` and \\\\`namespace {}\\\\` are outdated ways to organize TypeScript code.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: (_b = [\"\\n            One argument may be optionally provided:\\n\\n            * `\", \"` allows `declare namespace ... {}` to describe external APIs.\"], _b.raw = [\"\\n            One argument may be optionally provided:\\n\\n            * \\\\`\", \"\\\\` allows \\\\`declare namespace ... {}\\\\` to describe external APIs.\"], Lint.Utils.dedent(_b, OPTION_ALLOW_DECLARATIONS)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_ALLOW_DECLARATIONS],\n        },\n        minLength: 0,\n        maxLength: 1,\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + OPTION_ALLOW_DECLARATIONS + \"\\\"]\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"'namespace' and 'module' are disallowed\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    // Ignore all .d.ts files by returning and not walking their ASTs.\n    // .d.ts declarations do not have the Ambient flag set, but are still declarations.\n    if (ctx.sourceFile.isDeclarationFile && ctx.options.allowDeclarations) {\n        return;\n    }\n    for (var _i = 0, _a = ctx.sourceFile.statements; _i < _a.length; _i++) {\n        var node = _a[_i];\n        if (node.kind === ts.SyntaxKind.ModuleDeclaration) {\n            if (node.name.kind !== ts.SyntaxKind.StringLiteral &&\n                (!ctx.options.allowDeclarations || !tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword))) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n    }\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noNonNullAssertionRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoNonNullAssertionWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-non-null-assertion\",\n    description: \"Disallows non-null assertions.\",\n    rationale: \"Using non-null assertion cancels the benefits of the strict null checking mode.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Forbidden non null assertion\";\nexports.Rule = Rule;\nvar NoNonNullAssertionWalker = (function (_super) {\n    __extends(NoNonNullAssertionWalker, _super);\n    function NoNonNullAssertionWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoNonNullAssertionWalker.prototype.visitNonNullExpression = function (node) {\n        this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        _super.prototype.visitNonNullExpression.call(this, node);\n    };\n    return NoNonNullAssertionWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noReferenceRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-reference\",\n    description: \"Disallows `/// <reference path=>` imports (use ES6-style imports instead).\",\n    rationale: (_a = [\"\\n            Using `/// <reference path=>` comments to load other files is outdated.\\n            Use ES6-style imports to reference other files.\"], _a.raw = [\"\\n            Using \\\\`/// <reference path=>\\\\` comments to load other files is outdated.\\n            Use ES6-style imports to reference other files.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"<reference> is not allowed, use imports\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    for (var _i = 0, _a = ctx.sourceFile.referencedFiles; _i < _a.length; _i++) {\n        var ref = _a[_i];\n        ctx.addFailure(ref.pos, ref.end, Rule.FAILURE_STRING);\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noVarRequiresRule.js":"/**\n * @license\n * Copyright 2014 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var requiresWalker = new NoVarRequiresWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(requiresWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-var-requires\",\n    description: \"Disallows the use of require statements except in import statements.\",\n    descriptionDetails: (_a = [\"\\n            In other words, the use of forms such as `var module = require(\\\"module\\\")` are banned.\\n            Instead use ES6 style imports or `import foo = require('foo')` imports.\"], _a.raw = [\"\\n            In other words, the use of forms such as \\\\`var module = require(\\\"module\\\")\\\\` are banned.\\n            Instead use ES6 style imports or \\\\`import foo = require('foo')\\\\` imports.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"require statement not part of an import statement\";\nexports.Rule = Rule;\nvar NoVarRequiresWalker = (function (_super) {\n    __extends(NoVarRequiresWalker, _super);\n    function NoVarRequiresWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoVarRequiresWalker.prototype.createScope = function () {\n        return {};\n    };\n    NoVarRequiresWalker.prototype.visitCallExpression = function (node) {\n        var expression = node.expression;\n        if (this.getCurrentDepth() <= 1 && expression.kind === ts.SyntaxKind.Identifier) {\n            var identifierName = expression.text;\n            if (identifierName === \"require\") {\n                // if we're calling (invoking) require, then it's not part of an import statement\n                this.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    return NoVarRequiresWalker;\n}(Lint.ScopeAwareRuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/onlyArrowFunctionsRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_DECLARATIONS = \"allow-declarations\";\nvar OPTION_ALLOW_NAMED_FUNCTIONS = \"allow-named-functions\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, parseOptions(this.ruleArguments));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"only-arrow-functions\",\n    description: \"Disallows traditional (non-arrow) function expressions.\",\n    rationale: \"Traditional functions don't bind lexical scope, which can lead to unexpected behavior when accessing 'this'.\",\n    optionsDescription: (_a = [\"\\n            Two arguments may be optionally provided:\\n\\n            * `\\\"\", \"\\\"` allows standalone function declarations.\\n            * `\\\"\", \"\\\"` allows the expression `function foo() {}` but not `function() {}`.\\n        \"], _a.raw = [\"\\n            Two arguments may be optionally provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` allows standalone function declarations.\\n            * \\\\`\\\"\", \"\\\"\\\\` allows the expression \\\\`function foo() {}\\\\` but not \\\\`function() {}\\\\`.\\n        \"], Lint.Utils.dedent(_a, OPTION_ALLOW_DECLARATIONS, OPTION_ALLOW_NAMED_FUNCTIONS)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_ALLOW_DECLARATIONS, OPTION_ALLOW_NAMED_FUNCTIONS],\n        },\n        minLength: 0,\n        maxLength: 1,\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + OPTION_ALLOW_DECLARATIONS + \"\\\", \\\"\" + OPTION_ALLOW_NAMED_FUNCTIONS + \"\\\"]\"],\n    type: \"typescript\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"non-arrow functions are forbidden\";\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments) {\n    return {\n        allowDeclarations: hasOption(OPTION_ALLOW_DECLARATIONS),\n        allowNamedFunctions: hasOption(OPTION_ALLOW_NAMED_FUNCTIONS),\n    };\n    function hasOption(name) {\n        return ruleArguments.indexOf(name) !== -1;\n    }\n}\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, _a = ctx.options, allowDeclarations = _a.allowDeclarations, allowNamedFunctions = _a.allowNamedFunctions;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.FunctionDeclaration:\n                if (allowDeclarations) {\n                    break;\n                }\n            // falls through\n            case ts.SyntaxKind.FunctionExpression: {\n                var f = node;\n                if (!(allowNamedFunctions && f.name) && !functionIsExempt(f)) {\n                    ctx.addFailureAtNode(Lint.childOfKind(node, ts.SyntaxKind.FunctionKeyword), Rule.FAILURE_STRING);\n                }\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n/** Generator functions and functions using `this` are allowed. */\nfunction functionIsExempt(node) {\n    return node.asteriskToken || hasThisParameter(node) || node.body && usesThisInBody(node.body);\n}\nfunction hasThisParameter(node) {\n    var first = node.parameters[0];\n    return first && first.name.kind === ts.SyntaxKind.Identifier &&\n        first.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword;\n}\nfunction usesThisInBody(node) {\n    return node.kind === ts.SyntaxKind.ThisKeyword || !utils.hasOwnThisReference(node) && ts.forEachChild(node, usesThisInBody);\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/preferForOfRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../language/utils\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"prefer-for-of\",\n    description: \"Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated.\",\n    rationale: \"A for(... of ...) loop is easier to implement and read when the index is not needed.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Expected a 'for-of' loop instead of a 'for' loop with this simple iteration\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile;\n    var scopes = [];\n    return ts.forEachChild(sourceFile, cb);\n    function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ForStatement:\n                return visitForStatement(node);\n            case ts.SyntaxKind.Identifier:\n                return visitIdentifier(node);\n            default:\n                return ts.forEachChild(node, cb);\n        }\n    }\n    function visitForStatement(node) {\n        var arrayNodeInfo = getForLoopHeaderInfo(node);\n        if (!arrayNodeInfo) {\n            return ts.forEachChild(node, cb);\n        }\n        var indexVariable = arrayNodeInfo.indexVariable, arrayExpr = arrayNodeInfo.arrayExpr;\n        var indexVariableName = indexVariable.text;\n        // store `for` loop state\n        var state = { indexVariableName: indexVariableName, arrayExpr: arrayExpr, onlyArrayReadAccess: true };\n        scopes.push(state);\n        ts.forEachChild(node.statement, cb);\n        scopes.pop();\n        if (state.onlyArrayReadAccess) {\n            ctx.addFailure(node.getStart(), node.statement.getFullStart(), Rule.FAILURE_STRING);\n        }\n    }\n    function visitIdentifier(node) {\n        var state = getStateForVariable(node.text);\n        if (state !== undefined && state.onlyArrayReadAccess && isNonSimpleIncrementorUse(node, state.arrayExpr, sourceFile)) {\n            state.onlyArrayReadAccess = false;\n        }\n    }\n    function getStateForVariable(name) {\n        for (var i = scopes.length - 1; i >= 0; i--) {\n            var scope = scopes[i];\n            if (scope.indexVariableName === name) {\n                return scope;\n            }\n        }\n        return undefined;\n    }\n}\nfunction isNonSimpleIncrementorUse(node, arrayExpr, sourceFile) {\n    // check if iterator is used for something other than reading data from array\n    var elementAccess = node.parent;\n    var accessParent = elementAccess.parent;\n    return !utils.isElementAccessExpression(elementAccess)\n        || utils_1.isAssignment(accessParent)\n        || accessParent.kind === ts.SyntaxKind.DeleteExpression\n        || !nodeEquals(arrayExpr, utils_1.unwrapParentheses(elementAccess.expression), sourceFile);\n}\nfunction nodeEquals(a, b, sourceFile) {\n    return a.getText(sourceFile) === b.getText(sourceFile);\n}\n// returns the iterator and array of a `for` loop if the `for` loop is basic.\nfunction getForLoopHeaderInfo(forLoop) {\n    var initializer = forLoop.initializer, condition = forLoop.condition, incrementor = forLoop.incrementor;\n    if (!initializer || !condition || !incrementor) {\n        return undefined;\n    }\n    // Must start with `var i = 0;` or `let i = 0;`\n    if (!utils.isVariableDeclarationList(initializer) || initializer.declarations.length !== 1) {\n        return undefined;\n    }\n    var _a = initializer.declarations[0], indexVariable = _a.name, indexInit = _a.initializer;\n    if (indexVariable.kind !== ts.SyntaxKind.Identifier || indexInit === undefined || !isNumber(indexInit, \"0\")) {\n        return undefined;\n    }\n    // Must end with `i++`\n    if (!isIncremented(incrementor, indexVariable.text)) {\n        return undefined;\n    }\n    // Condition must be `i < arr.length;`\n    if (!utils.isBinaryExpression(condition)) {\n        return undefined;\n    }\n    var left = condition.left, operatorToken = condition.operatorToken, right = condition.right;\n    if (!isIdentifierNamed(left, indexVariable.text) ||\n        operatorToken.kind !== ts.SyntaxKind.LessThanToken ||\n        !utils.isPropertyAccessExpression(right)) {\n        return undefined;\n    }\n    var arrayExpr = right.expression, name = right.name;\n    if (name.text !== \"length\") {\n        return undefined;\n    }\n    return { indexVariable: indexVariable, arrayExpr: arrayExpr };\n}\nfunction isIncremented(node, indexVariableName) {\n    switch (node.kind) {\n        case ts.SyntaxKind.PrefixUnaryExpression:\n        case ts.SyntaxKind.PostfixUnaryExpression: {\n            var _a = node, operator = _a.operator, operand = _a.operand;\n            // `++x` or `x++`\n            return operator === ts.SyntaxKind.PlusPlusToken && isVar(operand);\n        }\n        case ts.SyntaxKind.BinaryExpression:\n            var _b = node, operatorToken = _b.operatorToken, updatedVar = _b.left, rhs = _b.right;\n            if (!isVar(updatedVar)) {\n                return false;\n            }\n            switch (operatorToken.kind) {\n                case ts.SyntaxKind.PlusEqualsToken:\n                    // x += 1\n                    return isOne(rhs);\n                case ts.SyntaxKind.EqualsToken: {\n                    if (!utils.isBinaryExpression(rhs)) {\n                        return false;\n                    }\n                    var rhsOp = rhs.operatorToken, left = rhs.left, right = rhs.right;\n                    // `x = 1 + x` or `x = x + 1`\n                    return rhsOp.kind === ts.SyntaxKind.PlusToken && (isVar(left) && isOne(right) || isOne(left) && isVar(right));\n                }\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n    function isVar(id) {\n        return isIdentifierNamed(id, indexVariableName);\n    }\n}\nfunction isIdentifierNamed(node, text) {\n    return utils.isIdentifier(node) && node.text === text;\n}\nfunction isOne(node) {\n    return isNumber(node, \"1\");\n}\nfunction isNumber(node, value) {\n    return utils.isNumericLiteral(node) && node.text === value;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/promiseFunctionAsyncRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new PromiseAsyncWalker(sourceFile, this.getOptions(), program));\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"promise-function-async\",\n    description: \"Requires any function or method that returns a promise to be marked async.\",\n    rationale: (_a = [\"\\n            Ensures that each function is only capable of 1) returning a rejected promise, or 2)\\n            throwing an Error object. In contrast, non-`async` `Promise`-returning functions\\n            are technically capable of either. This practice removes a requirement for consuming\\n            code to handle both cases.\\n        \"], _a.raw = [\"\\n            Ensures that each function is only capable of 1) returning a rejected promise, or 2)\\n            throwing an Error object. In contrast, non-\\\\`async\\\\` \\\\`Promise\\\\`-returning functions\\n            are technically capable of either. This practice removes a requirement for consuming\\n            code to handle both cases.\\n        \"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: false,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"functions that return promises must be async\";\nexports.Rule = Rule;\nvar PromiseAsyncWalker = (function (_super) {\n    __extends(PromiseAsyncWalker, _super);\n    function PromiseAsyncWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PromiseAsyncWalker.prototype.visitArrowFunction = function (node) {\n        this.handleDeclaration(node);\n        _super.prototype.visitArrowFunction.call(this, node);\n    };\n    PromiseAsyncWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.handleDeclaration(node);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    PromiseAsyncWalker.prototype.visitFunctionExpression = function (node) {\n        this.handleDeclaration(node);\n        _super.prototype.visitFunctionExpression.call(this, node);\n    };\n    PromiseAsyncWalker.prototype.visitMethodDeclaration = function (node) {\n        this.handleDeclaration(node);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    PromiseAsyncWalker.prototype.handleDeclaration = function (node) {\n        var tc = this.getTypeChecker();\n        var signature = tc.getTypeAtLocation(node).getCallSignatures()[0];\n        var returnType = tc.typeToString(tc.getReturnTypeOfSignature(signature));\n        var isAsync = Lint.hasModifier(node.modifiers, ts.SyntaxKind.AsyncKeyword);\n        var isPromise = returnType.indexOf(\"Promise<\") === 0;\n        var signatureEnd = node.body != null\n            ? node.body.getStart() - node.getStart() - 1\n            : node.getWidth();\n        if (isPromise && !isAsync) {\n            this.addFailureAt(node.getStart(), signatureEnd, Rule.FAILURE_STRING);\n        }\n    };\n    return PromiseAsyncWalker;\n}(Lint.ProgramAwareRuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/typedefRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new TypedefWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"typedef\",\n    description: \"Requires type definitions to exist.\",\n    optionsDescription: (_a = [\"\\n            Several arguments may be optionally provided:\\n\\n            * `\\\"call-signature\\\"` checks return type of functions.\\n            * `\\\"arrow-call-signature\\\"` checks return type of arrow functions.\\n            * `\\\"parameter\\\"` checks type specifier of function parameters for non-arrow functions.\\n            * `\\\"arrow-parameter\\\"` checks type specifier of function parameters for arrow functions.\\n            * `\\\"property-declaration\\\"` checks return types of interface properties.\\n            * `\\\"variable-declaration\\\"` checks non-binding variable declarations.\\n            * `\\\"member-variable-declaration\\\"` checks member variable declarations.\\n            * `\\\"object-destructuring\\\"` checks object destructuring declarations.\\n            * `\\\"array-destructuring\\\"` checks array destructuring declarations.\"], _a.raw = [\"\\n            Several arguments may be optionally provided:\\n\\n            * \\\\`\\\"call-signature\\\"\\\\` checks return type of functions.\\n            * \\\\`\\\"arrow-call-signature\\\"\\\\` checks return type of arrow functions.\\n            * \\\\`\\\"parameter\\\"\\\\` checks type specifier of function parameters for non-arrow functions.\\n            * \\\\`\\\"arrow-parameter\\\"\\\\` checks type specifier of function parameters for arrow functions.\\n            * \\\\`\\\"property-declaration\\\"\\\\` checks return types of interface properties.\\n            * \\\\`\\\"variable-declaration\\\"\\\\` checks non-binding variable declarations.\\n            * \\\\`\\\"member-variable-declaration\\\"\\\\` checks member variable declarations.\\n            * \\\\`\\\"object-destructuring\\\"\\\\` checks object destructuring declarations.\\n            * \\\\`\\\"array-destructuring\\\"\\\\` checks array destructuring declarations.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [\n                \"call-signature\",\n                \"arrow-call-signature\",\n                \"parameter\",\n                \"arrow-parameter\",\n                \"property-declaration\",\n                \"variable-declaration\",\n                \"member-variable-declaration\",\n                \"object-destructuring\",\n                \"array-destructuring\",\n            ],\n        },\n        minLength: 0,\n        maxLength: 7,\n    },\n    optionExamples: ['[true, \"call-signature\", \"parameter\", \"member-variable-declaration\"]'],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"missing type declaration\";\nexports.Rule = Rule;\nvar TypedefWalker = (function (_super) {\n    __extends(TypedefWalker, _super);\n    function TypedefWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TypedefWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.handleCallSignature(node);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    TypedefWalker.prototype.visitFunctionExpression = function (node) {\n        this.handleCallSignature(node);\n        _super.prototype.visitFunctionExpression.call(this, node);\n    };\n    TypedefWalker.prototype.visitArrowFunction = function (node) {\n        var location = (node.parameters != null) ? node.parameters.end : null;\n        if (location != null\n            && node.parent !== undefined\n            && node.parent.kind !== ts.SyntaxKind.CallExpression\n            && !isTypedPropertyDeclaration(node.parent)) {\n            this.checkTypeAnnotation(\"arrow-call-signature\", location, node.type, node.name);\n        }\n        _super.prototype.visitArrowFunction.call(this, node);\n    };\n    TypedefWalker.prototype.visitGetAccessor = function (node) {\n        this.handleCallSignature(node);\n        _super.prototype.visitGetAccessor.call(this, node);\n    };\n    TypedefWalker.prototype.visitMethodDeclaration = function (node) {\n        this.handleCallSignature(node);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    TypedefWalker.prototype.visitMethodSignature = function (node) {\n        this.handleCallSignature(node);\n        _super.prototype.visitMethodSignature.call(this, node);\n    };\n    TypedefWalker.prototype.visitObjectLiteralExpression = function (node) {\n        for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {\n            var property = _a[_i];\n            switch (property.kind) {\n                case ts.SyntaxKind.PropertyAssignment:\n                    this.visitPropertyAssignment(property);\n                    break;\n                case ts.SyntaxKind.MethodDeclaration:\n                    this.visitMethodDeclaration(property);\n                    break;\n                case ts.SyntaxKind.GetAccessor:\n                    this.visitGetAccessor(property);\n                    break;\n                case ts.SyntaxKind.SetAccessor:\n                    this.visitSetAccessor(property);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n    TypedefWalker.prototype.visitParameterDeclaration = function (node) {\n        // a parameter's \"type\" could be a specific string value, for example `fn(option: \"someOption\", anotherOption: number)`\n        if ((node.type == null || node.type.kind !== ts.SyntaxKind.StringLiteral)\n            && node.parent !== undefined\n            && node.parent.parent !== undefined) {\n            var isArrowFunction = node.parent.kind === ts.SyntaxKind.ArrowFunction;\n            var optionName = null;\n            if (isArrowFunction && isTypedPropertyDeclaration(node.parent.parent)) {\n                // leave optionName as null and don't perform check\n            }\n            else if (isArrowFunction && utils.isPropertyDeclaration(node.parent.parent)) {\n                optionName = \"member-variable-declaration\";\n            }\n            else if (isArrowFunction) {\n                optionName = \"arrow-parameter\";\n            }\n            else {\n                optionName = \"parameter\";\n            }\n            if (optionName !== null) {\n                this.checkTypeAnnotation(optionName, node.getEnd(), node.type, node.name);\n            }\n        }\n        _super.prototype.visitParameterDeclaration.call(this, node);\n    };\n    TypedefWalker.prototype.visitPropertyAssignment = function (node) {\n        switch (node.initializer.kind) {\n            case ts.SyntaxKind.ArrowFunction:\n            case ts.SyntaxKind.FunctionExpression:\n                this.handleCallSignature(node.initializer);\n                break;\n            default:\n                break;\n        }\n        _super.prototype.visitPropertyAssignment.call(this, node);\n    };\n    TypedefWalker.prototype.visitPropertyDeclaration = function (node) {\n        var optionName = \"member-variable-declaration\";\n        // If this is an arrow function, it doesn't need to have a typedef on the property declaration\n        // as the typedefs can be on the function's parameters instead\n        var performCheck = !(node.initializer != null && node.initializer.kind === ts.SyntaxKind.ArrowFunction && node.type == null);\n        if (performCheck) {\n            this.checkTypeAnnotation(optionName, node.name.getEnd(), node.type, node.name);\n        }\n        _super.prototype.visitPropertyDeclaration.call(this, node);\n    };\n    TypedefWalker.prototype.visitPropertySignature = function (node) {\n        var optionName = \"property-declaration\";\n        this.checkTypeAnnotation(optionName, node.name.getEnd(), node.type, node.name);\n        _super.prototype.visitPropertySignature.call(this, node);\n    };\n    TypedefWalker.prototype.visitSetAccessor = function (node) {\n        this.handleCallSignature(node);\n        _super.prototype.visitSetAccessor.call(this, node);\n    };\n    TypedefWalker.prototype.visitVariableDeclaration = function (node) {\n        // variable declarations should always have a grandparent, but check that to be on the safe side.\n        // catch statements will be the parent of the variable declaration\n        // for-in/for-of loops will be the gradparent of the variable declaration\n        if (node.parent != null && node.parent.parent != null\n            && node.parent.kind !== ts.SyntaxKind.CatchClause\n            && node.parent.parent.kind !== ts.SyntaxKind.ForInStatement\n            && node.parent.parent.kind !== ts.SyntaxKind.ForOfStatement) {\n            var rule = void 0;\n            switch (node.name.kind) {\n                case ts.SyntaxKind.ObjectBindingPattern:\n                    rule = \"object-destructuring\";\n                    break;\n                case ts.SyntaxKind.ArrayBindingPattern:\n                    rule = \"array-destructuring\";\n                    break;\n                default:\n                    rule = \"variable-declaration\";\n                    break;\n            }\n            this.checkTypeAnnotation(rule, node.name.getEnd(), node.type, node.name);\n        }\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    TypedefWalker.prototype.handleCallSignature = function (node) {\n        var location = (node.parameters != null) ? node.parameters.end : null;\n        // set accessors can't have a return type.\n        if (location != null && node.kind !== ts.SyntaxKind.SetAccessor && node.kind !== ts.SyntaxKind.ArrowFunction) {\n            this.checkTypeAnnotation(\"call-signature\", location, node.type, node.name);\n        }\n    };\n    TypedefWalker.prototype.checkTypeAnnotation = function (option, location, typeAnnotation, name) {\n        if (this.hasOption(option) && typeAnnotation == null) {\n            this.addFailureAt(location, 1, \"expected \" + option + getName(name, \": '\", \"'\") + \" to have a typedef\");\n        }\n    };\n    return TypedefWalker;\n}(Lint.RuleWalker));\nfunction getName(name, prefix, suffix) {\n    var ns = \"\";\n    if (name != null) {\n        switch (name.kind) {\n            case ts.SyntaxKind.Identifier:\n                ns = name.text;\n                break;\n            case ts.SyntaxKind.BindingElement:\n                ns = getName(name.name);\n                break;\n            case ts.SyntaxKind.ArrayBindingPattern:\n                ns = \"[ \" + name.elements.map(function (n) { return getName(n); }).join(\", \") + \" ]\";\n                break;\n            case ts.SyntaxKind.ObjectBindingPattern:\n                ns = \"{ \" + name.elements.map(function (n) { return getName(n); }).join(\", \") + \" }\";\n                break;\n            default:\n                break;\n        }\n    }\n    return ns ? \"\" + (prefix || \"\") + ns + (suffix || \"\") : \"\";\n}\nfunction isTypedPropertyDeclaration(node) {\n    return utils.isPropertyDeclaration(node) && node.type != null;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/typedefWhitespaceRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\n/* tslint:disable:object-literal-sort-keys */\nvar SPACE_OPTIONS = {\n    type: \"string\",\n    enum: [\"nospace\", \"onespace\", \"space\"],\n};\nvar SPACE_OBJECT = {\n    type: \"object\",\n    properties: {\n        \"call-signature\": SPACE_OPTIONS,\n        \"index-signature\": SPACE_OPTIONS,\n        \"parameter\": SPACE_OPTIONS,\n        \"property-declaration\": SPACE_OPTIONS,\n        \"variable-declaration\": SPACE_OPTIONS,\n    },\n    additionalProperties: false,\n};\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new TypedefWhitespaceWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: \"typedef-whitespace\",\n    description: \"Requires or disallows whitespace for type definitions.\",\n    descriptionDetails: \"Determines if a space is required or not before the colon in a type specifier.\",\n    optionsDescription: (_a = [\"\\n            Two arguments which are both objects.\\n            The first argument specifies how much space should be to the _left_ of a typedef colon.\\n            The second argument specifies how much space should be to the _right_ of a typedef colon.\\n            Each key should have a value of `\\\"space\\\"` or `\\\"nospace\\\"`.\\n            Possible keys are:\\n\\n            * `\\\"call-signature\\\"` checks return type of functions.\\n            * `\\\"index-signature\\\"` checks index type specifier of indexers.\\n            * `\\\"parameter\\\"` checks function parameters.\\n            * `\\\"property-declaration\\\"` checks object property declarations.\\n            * `\\\"variable-declaration\\\"` checks variable declaration.\"], _a.raw = [\"\\n            Two arguments which are both objects.\\n            The first argument specifies how much space should be to the _left_ of a typedef colon.\\n            The second argument specifies how much space should be to the _right_ of a typedef colon.\\n            Each key should have a value of \\\\`\\\"space\\\"\\\\` or \\\\`\\\"nospace\\\"\\\\`.\\n            Possible keys are:\\n\\n            * \\\\`\\\"call-signature\\\"\\\\` checks return type of functions.\\n            * \\\\`\\\"index-signature\\\"\\\\` checks index type specifier of indexers.\\n            * \\\\`\\\"parameter\\\"\\\\` checks function parameters.\\n            * \\\\`\\\"property-declaration\\\"\\\\` checks object property declarations.\\n            * \\\\`\\\"variable-declaration\\\"\\\\` checks variable declaration.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: [SPACE_OBJECT, SPACE_OBJECT],\n        additionalItems: false,\n    },\n    optionExamples: [(_b = [\"\\n            [\\n              true,\\n              {\\n                \\\"call-signature\\\": \\\"nospace\\\",\\n                \\\"index-signature\\\": \\\"nospace\\\",\\n                \\\"parameter\\\": \\\"nospace\\\",\\n                \\\"property-declaration\\\": \\\"nospace\\\",\\n                \\\"variable-declaration\\\": \\\"nospace\\\"\\n              },\\n              {\\n                \\\"call-signature\\\": \\\"onespace\\\",\\n                \\\"index-signature\\\": \\\"onespace\\\",\\n                \\\"parameter\\\": \\\"onespace\\\",\\n                \\\"property-declaration\\\": \\\"onespace\\\",\\n                \\\"variable-declaration\\\": \\\"onespace\\\"\\n              }\\n            ]\"], _b.raw = [\"\\n            [\\n              true,\\n              {\\n                \\\"call-signature\\\": \\\"nospace\\\",\\n                \\\"index-signature\\\": \\\"nospace\\\",\\n                \\\"parameter\\\": \\\"nospace\\\",\\n                \\\"property-declaration\\\": \\\"nospace\\\",\\n                \\\"variable-declaration\\\": \\\"nospace\\\"\\n              },\\n              {\\n                \\\"call-signature\\\": \\\"onespace\\\",\\n                \\\"index-signature\\\": \\\"onespace\\\",\\n                \\\"parameter\\\": \\\"onespace\\\",\\n                \\\"property-declaration\\\": \\\"onespace\\\",\\n                \\\"variable-declaration\\\": \\\"onespace\\\"\\n              }\\n            ]\"], Lint.Utils.dedent(_b)),],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar TypedefWhitespaceWalker = (function (_super) {\n    __extends(TypedefWhitespaceWalker, _super);\n    function TypedefWhitespaceWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TypedefWhitespaceWalker.getColonPosition = function (node) {\n        var colon = Lint.childOfKind(node, ts.SyntaxKind.ColonToken);\n        return colon && colon.getStart();\n    };\n    TypedefWhitespaceWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.checkSpace(\"call-signature\", node, node.type);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitFunctionExpression = function (node) {\n        this.checkSpace(\"call-signature\", node, node.type);\n        _super.prototype.visitFunctionExpression.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitGetAccessor = function (node) {\n        this.checkSpace(\"call-signature\", node, node.type);\n        _super.prototype.visitGetAccessor.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitIndexSignatureDeclaration = function (node) {\n        this.checkSpace(\"index-signature\", node, node.type);\n        _super.prototype.visitIndexSignatureDeclaration.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitMethodDeclaration = function (node) {\n        this.checkSpace(\"call-signature\", node, node.type);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitMethodSignature = function (node) {\n        this.checkSpace(\"call-signature\", node, node.type);\n        _super.prototype.visitMethodSignature.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitParameterDeclaration = function (node) {\n        this.checkSpace(\"parameter\", node, node.type);\n        _super.prototype.visitParameterDeclaration.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitPropertyDeclaration = function (node) {\n        this.checkSpace(\"property-declaration\", node, node.type);\n        _super.prototype.visitPropertyDeclaration.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitPropertySignature = function (node) {\n        this.checkSpace(\"property-declaration\", node, node.type);\n        _super.prototype.visitPropertySignature.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitSetAccessor = function (node) {\n        this.checkSpace(\"call-signature\", node, node.type);\n        _super.prototype.visitSetAccessor.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.visitVariableDeclaration = function (node) {\n        this.checkSpace(\"variable-declaration\", node, node.type);\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    TypedefWhitespaceWalker.prototype.checkSpace = function (option, node, typeNode) {\n        if (this.hasOption(option) && typeNode != null) {\n            var colonPosition = TypedefWhitespaceWalker.getColonPosition(node);\n            if (colonPosition !== undefined) {\n                var scanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, node.getText());\n                this.checkLeft(option, node, scanner, colonPosition);\n                this.checkRight(option, node, scanner, colonPosition);\n            }\n        }\n    };\n    TypedefWhitespaceWalker.prototype.hasOption = function (option) {\n        return this.hasLeftOption(option) || this.hasRightOption(option);\n    };\n    TypedefWhitespaceWalker.prototype.hasLeftOption = function (option) {\n        var allOptions = this.getOptions();\n        if (allOptions == null || allOptions.length === 0) {\n            return false;\n        }\n        var options = allOptions[0];\n        return options != null && options[option] != null;\n    };\n    TypedefWhitespaceWalker.prototype.hasRightOption = function (option) {\n        var allOptions = this.getOptions();\n        if (allOptions == null || allOptions.length < 2) {\n            return false;\n        }\n        var options = allOptions[1];\n        return options != null && options[option] != null;\n    };\n    TypedefWhitespaceWalker.prototype.getLeftOption = function (option) {\n        if (!this.hasLeftOption(option)) {\n            return null;\n        }\n        var allOptions = this.getOptions();\n        var options = allOptions[0];\n        return options[option];\n    };\n    TypedefWhitespaceWalker.prototype.getRightOption = function (option) {\n        if (!this.hasRightOption(option)) {\n            return null;\n        }\n        var allOptions = this.getOptions();\n        var options = allOptions[1];\n        return options[option];\n    };\n    TypedefWhitespaceWalker.prototype.checkLeft = function (option, node, scanner, colonPosition) {\n        if (this.hasLeftOption(option)) {\n            var positionToCheck = colonPosition - 1 - node.getStart();\n            var hasLeadingWhitespace = void 0;\n            if (positionToCheck < 0) {\n                hasLeadingWhitespace = false;\n            }\n            else {\n                scanner.setTextPos(positionToCheck);\n                hasLeadingWhitespace = scanner.scan() === ts.SyntaxKind.WhitespaceTrivia;\n            }\n            positionToCheck = colonPosition - 2 - node.getStart();\n            var hasSeveralLeadingWhitespaces = void 0;\n            if (positionToCheck < 0) {\n                hasSeveralLeadingWhitespaces = false;\n            }\n            else {\n                scanner.setTextPos(positionToCheck);\n                hasSeveralLeadingWhitespaces = hasLeadingWhitespace &&\n                    scanner.scan() === ts.SyntaxKind.WhitespaceTrivia;\n            }\n            var optionValue = this.getLeftOption(option);\n            var message = \"expected \" + optionValue + \" before colon in \" + option;\n            this.performFailureCheck(optionValue, hasLeadingWhitespace, hasSeveralLeadingWhitespaces, colonPosition - 1, message);\n        }\n    };\n    TypedefWhitespaceWalker.prototype.checkRight = function (option, node, scanner, colonPosition) {\n        if (this.hasRightOption(option)) {\n            var positionToCheck = colonPosition + 1 - node.getStart();\n            // Don't enforce trailing spaces on newlines\n            // (https://github.com/palantir/tslint/issues/1354)\n            scanner.setTextPos(positionToCheck);\n            var kind = scanner.scan();\n            if (kind === ts.SyntaxKind.NewLineTrivia) {\n                return;\n            }\n            var hasTrailingWhitespace = void 0;\n            if (positionToCheck >= node.getWidth()) {\n                hasTrailingWhitespace = false;\n            }\n            else {\n                hasTrailingWhitespace = kind === ts.SyntaxKind.WhitespaceTrivia;\n            }\n            positionToCheck = colonPosition + 2 - node.getStart();\n            var hasSeveralTrailingWhitespaces = void 0;\n            if (positionToCheck >= node.getWidth()) {\n                hasSeveralTrailingWhitespaces = false;\n            }\n            else {\n                scanner.setTextPos(positionToCheck);\n                hasSeveralTrailingWhitespaces = hasTrailingWhitespace &&\n                    scanner.scan() === ts.SyntaxKind.WhitespaceTrivia;\n            }\n            var optionValue = this.getRightOption(option);\n            var message = \"expected \" + optionValue + \" after colon in \" + option;\n            this.performFailureCheck(optionValue, hasTrailingWhitespace, hasSeveralTrailingWhitespaces, colonPosition + 1, message);\n        }\n    };\n    TypedefWhitespaceWalker.prototype.performFailureCheck = function (optionValue, hasWS, hasSeveralWS, failurePos, message) {\n        // has several spaces but should have one or none\n        var isFailure = hasSeveralWS &&\n            (optionValue === \"onespace\" || optionValue === \"nospace\");\n        // has at least one space but should have none\n        isFailure = isFailure || hasWS && optionValue === \"nospace\";\n        // has no space but should have at least one\n        isFailure = isFailure || !hasWS &&\n            (optionValue === \"onespace\" || optionValue === \"space\");\n        if (isFailure) {\n            this.addFailureAt(failurePos, 1, message);\n        }\n    };\n    return TypedefWhitespaceWalker;\n}(Lint.RuleWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/unifiedSignaturesRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../utils\");\nvar adjacentOverloadSignaturesRule_1 = require(\"./adjacentOverloadSignaturesRule\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_OMITTING_SINGLE_PARAMETER = function (otherLine) {\n        return this.FAILURE_STRING_START(otherLine) + \" with an optional parameter.\";\n    };\n    Rule.FAILURE_STRING_OMITTING_REST_PARAMETER = function (otherLine) {\n        return this.FAILURE_STRING_START(otherLine) + \" with a rest parameter.\";\n    };\n    Rule.FAILURE_STRING_SINGLE_PARAMETER_DIFFERENCE = function (otherLine, type1, type2) {\n        return this.FAILURE_STRING_START(otherLine) + \" taking `\" + type1 + \" | \" + type2 + \"`.\";\n    };\n    Rule.FAILURE_STRING_START = function (otherLine) {\n        // For only 2 overloads we don't need to specify which is the other one.\n        var overloads = otherLine === undefined ? \"These overloads\" : \"This overload and the one on line \" + otherLine;\n        return overloads + \" can be combined into one signature\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"unified-signatures\",\n    description: \"Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"typescript\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitSourceFile = function (node) {\n        this.checkStatements(node.statements);\n        _super.prototype.visitSourceFile.call(this, node);\n    };\n    Walker.prototype.visitModuleDeclaration = function (node) {\n        var body = node.body;\n        if (body && body.kind === ts.SyntaxKind.ModuleBlock) {\n            this.checkStatements(body.statements);\n        }\n        _super.prototype.visitModuleDeclaration.call(this, node);\n    };\n    Walker.prototype.visitInterfaceDeclaration = function (node) {\n        this.checkMembers(node.members, node.typeParameters);\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    Walker.prototype.visitClassDeclaration = function (node) {\n        this.checkMembers(node.members, node.typeParameters);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    Walker.prototype.visitTypeLiteral = function (node) {\n        this.checkMembers(node.members);\n        _super.prototype.visitTypeLiteral.call(this, node);\n    };\n    Walker.prototype.checkStatements = function (statements) {\n        this.checkOverloads(statements, function (statement) {\n            if (statement.kind === ts.SyntaxKind.FunctionDeclaration) {\n                var fn = statement;\n                if (fn.body) {\n                    return undefined;\n                }\n                return fn.name && { signature: fn, key: fn.name.text };\n            }\n            else {\n                return undefined;\n            }\n        });\n    };\n    Walker.prototype.checkMembers = function (members, typeParameters) {\n        this.checkOverloads(members, getOverloadName, typeParameters);\n        function getOverloadName(member) {\n            if (!utils.isSignatureDeclaration(member) || member.body) {\n                return undefined;\n            }\n            var key = adjacentOverloadSignaturesRule_1.getOverloadKey(member);\n            return key === undefined ? undefined : { signature: member, key: key };\n        }\n    };\n    Walker.prototype.checkOverloads = function (signatures, getOverload, typeParameters) {\n        var _this = this;\n        var isTypeParameter = getIsTypeParameter(typeParameters);\n        for (var _i = 0, _a = collectOverloads(signatures, getOverload); _i < _a.length; _i++) {\n            var overloads = _a[_i];\n            if (overloads.length === 2) {\n                this.compareSignatures(overloads[0], overloads[1], isTypeParameter, /*only2*/ true);\n            }\n            else {\n                forEachPair(overloads, function (a, b) {\n                    _this.compareSignatures(a, b, isTypeParameter, /*only2*/ false);\n                });\n            }\n        }\n    };\n    Walker.prototype.compareSignatures = function (a, b, isTypeParameter, only2) {\n        if (!signaturesCanBeUnified(a, b, isTypeParameter)) {\n            return;\n        }\n        if (a.parameters.length === b.parameters.length) {\n            var params = signaturesDifferBySingleParameter(a.parameters, b.parameters);\n            if (params) {\n                var p0 = params[0], p1 = params[1];\n                var lineOfOtherOverload = only2 ? undefined : this.getLine(p0);\n                this.addFailureAtNode(p1, Rule.FAILURE_STRING_SINGLE_PARAMETER_DIFFERENCE(lineOfOtherOverload, typeText(p0), typeText(p1)));\n            }\n        }\n        else {\n            var diff = signaturesDifferByOptionalOrRestParameter(a.parameters, b.parameters);\n            if (diff) {\n                var extraParameter = diff[0], signatureWithExtraParameter = diff[1];\n                var lineOfOtherOverload = only2 ? undefined : this.getLine(signatureWithExtraParameter === a.parameters ? b : a);\n                this.addFailureAtNode(extraParameter, extraParameter.dotDotDotToken\n                    ? Rule.FAILURE_STRING_OMITTING_REST_PARAMETER(lineOfOtherOverload)\n                    : Rule.FAILURE_STRING_OMITTING_SINGLE_PARAMETER(lineOfOtherOverload));\n            }\n        }\n    };\n    Walker.prototype.getLine = function (node) {\n        return this.getLineAndCharacterOfPosition(node.getStart()).line + 1;\n    };\n    return Walker;\n}(Lint.RuleWalker));\nfunction typeText(_a) {\n    var type = _a.type;\n    return type === undefined ? \"any\" : type.getText();\n}\nfunction signaturesCanBeUnified(a, b, isTypeParameter) {\n    // Must return the same type.\n    return typesAreEqual(a.type, b.type) &&\n        // Must take the same type parameters.\n        utils_1.arraysAreEqual(a.typeParameters, b.typeParameters, typeParametersAreEqual) &&\n        // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.\n        signatureUsesTypeParameter(a, isTypeParameter) === signatureUsesTypeParameter(b, isTypeParameter);\n}\n/** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */\nfunction signaturesDifferBySingleParameter(types1, types2) {\n    var index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);\n    if (index === undefined) {\n        return undefined;\n    }\n    // If remaining arrays are equal, the signatures differ by just one parameter type\n    if (!utils_1.arraysAreEqual(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {\n        return undefined;\n    }\n    var a = types1[index];\n    var b = types2[index];\n    return parametersHaveEqualSigils(a, b) ? [a, b] : undefined;\n}\n/**\n * Detect `a(): void` and `a(x: number): void`.\n * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.\n */\nfunction signaturesDifferByOptionalOrRestParameter(types1, types2) {\n    var minLength = Math.min(types1.length, types2.length);\n    var longer = types1.length < types2.length ? types2 : types1;\n    var shorter = types1.length < types2.length ? types1 : types2;\n    // If one is has 2+ parameters more than the other, they must all be optional/rest.\n    // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)\n    // Not allowed: f() and f(x, y)\n    for (var i = minLength + 1; i < longer.length; i++) {\n        if (!parameterMayBeMissing(longer[i])) {\n            return undefined;\n        }\n    }\n    for (var i = 0; i < minLength; i++) {\n        if (!typesAreEqual(types1[i].type, types2[i].type)) {\n            return undefined;\n        }\n    }\n    if (minLength > 0 && shorter[minLength - 1].dotDotDotToken) {\n        return undefined;\n    }\n    return [longer[longer.length - 1], longer];\n}\n/** Given type parameters, returns a function to test whether a type is one of those parameters. */\nfunction getIsTypeParameter(typeParameters) {\n    if (!typeParameters) {\n        return function () { return false; };\n    }\n    var set = new Set();\n    for (var _i = 0, typeParameters_1 = typeParameters; _i < typeParameters_1.length; _i++) {\n        var t = typeParameters_1[_i];\n        set.add(t.getText());\n    }\n    return function (typeName) { return set.has(typeName); };\n}\n/** True if any of the outer type parameters are used in a signature. */\nfunction signatureUsesTypeParameter(sig, isTypeParameter) {\n    return sig.parameters.some(function (p) { return p.type !== undefined && typeContainsTypeParameter(p.type); });\n    function typeContainsTypeParameter(type) {\n        if (type.kind === ts.SyntaxKind.TypeReference) {\n            var name = type.typeName;\n            if (name.kind === ts.SyntaxKind.Identifier && isTypeParameter(name.text)) {\n                return true;\n            }\n        }\n        return !!ts.forEachChild(type, typeContainsTypeParameter);\n    }\n}\n/**\n * Given all signatures, collects an array of arrays of signatures which are all overloads.\n * Does not rely on overloads being adjacent. This is similar to code in adjacentOverloadSignaturesRule.ts, but not the same.\n */\nfunction collectOverloads(nodes, getOverload) {\n    var map = new Map();\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var sig = nodes_1[_i];\n        var overload = getOverload(sig);\n        if (!overload) {\n            continue;\n        }\n        var signature = overload.signature, key = overload.key;\n        var overloads = map.get(key);\n        if (overloads) {\n            overloads.push(signature);\n        }\n        else {\n            map.set(key, [signature]);\n        }\n    }\n    return Array.from(map.values());\n}\nfunction parametersAreEqual(a, b) {\n    return parametersHaveEqualSigils(a, b) && typesAreEqual(a.type, b.type);\n}\n/** True for optional/rest parameters. */\nfunction parameterMayBeMissing(p) {\n    return !!p.dotDotDotToken || !!p.questionToken;\n}\n/** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */\nfunction parametersHaveEqualSigils(a, b) {\n    return !!a.dotDotDotToken === !!b.dotDotDotToken && !!a.questionToken === !!b.questionToken;\n}\nfunction typeParametersAreEqual(a, b) {\n    return a.name.text === b.name.text && typesAreEqual(a.constraint, b.constraint);\n}\nfunction typesAreEqual(a, b) {\n    // TODO: Could traverse AST so that formatting differences don't affect this.\n    return a === b || !!a && !!b && a.getText() === b.getText();\n}\n/** Returns the first index where `a` and `b` differ. */\nfunction getIndexOfFirstDifference(a, b, equal) {\n    for (var i = 0; i < a.length && i < b.length; i++) {\n        if (!equal(a[i], b[i])) {\n            return i;\n        }\n    }\n    return undefined;\n}\n/** Calls `action` for every pair of values in `values`. */\nfunction forEachPair(values, action) {\n    for (var i = 0; i < values.length; i++) {\n        for (var j = i + 1; j < values.length; j++) {\n            action(values[i], values[j]);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/awaitPromiseRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (srcFile, program) {\n        return this.applyWithWalker(new Walker(srcFile, this.getOptions(), program));\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"await-promise\",\n    description: \"Warns for an awaited value that is not a Promise.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"'await' of non-Promise.\";\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitNode = function (node) {\n        if (node.kind === ts.SyntaxKind.AwaitExpression &&\n            !couldBePromise(this.getTypeChecker().getTypeAtLocation(node.expression))) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitNode.call(this, node);\n    };\n    return Walker;\n}(Lint.ProgramAwareRuleWalker));\nfunction couldBePromise(type) {\n    if (Lint.isTypeFlagSet(type, ts.TypeFlags.Any) || isPromiseType(type)) {\n        return true;\n    }\n    if (isUnionType(type)) {\n        return type.types.some(isPromiseType);\n    }\n    var bases = type.getBaseTypes();\n    return bases !== undefined && bases.some(couldBePromise);\n}\nfunction isPromiseType(type) {\n    var target = type.target;\n    var symbol = target && target.symbol;\n    return !!symbol && symbol.name === \"Promise\";\n}\nfunction isUnionType(type) {\n    return Lint.isTypeFlagSet(type, ts.TypeFlags.Union);\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/curlyRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_IGNORE_SAME_LINE = \"ignore-same-line\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new CurlyWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"curly\",\n    description: \"Enforces braces for `if`/`for`/`do`/`while` statements.\",\n    rationale: (_a = [\"\\n            ```ts\\n            if (foo === bar)\\n                foo++;\\n                bar++;\\n            ```\\n\\n            In the code above, the author almost certainly meant for both `foo++` and `bar++`\\n            to be executed only if `foo === bar`. However, he forgot braces and `bar++` will be executed\\n            no matter what. This rule could prevent such a mistake.\"], _a.raw = [\"\\n            \\\\`\\\\`\\\\`ts\\n            if (foo === bar)\\n                foo++;\\n                bar++;\\n            \\\\`\\\\`\\\\`\\n\\n            In the code above, the author almost certainly meant for both \\\\`foo++\\\\` and \\\\`bar++\\\\`\\n            to be executed only if \\\\`foo === bar\\\\`. However, he forgot braces and \\\\`bar++\\\\` will be executed\\n            no matter what. This rule could prevent such a mistake.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: (_b = [\"\\n            The rule may be set to `true`, or to the following:\\n\\n            * `\\\"\", \"\\\"` skips checking braces for control-flow statements\\n            that are on one line and start on the same line as their control-flow keyword\\n        \"], _b.raw = [\"\\n            The rule may be set to \\\\`true\\\\`, or to the following:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` skips checking braces for control-flow statements\\n            that are on one line and start on the same line as their control-flow keyword\\n        \"], Lint.Utils.dedent(_b, OPTION_IGNORE_SAME_LINE)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [\n                OPTION_IGNORE_SAME_LINE,\n            ],\n        },\n    },\n    optionExamples: [\"true\", '[true, \"ignore-same-line\"]'],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.DO_FAILURE_STRING = \"do statements must be braced\";\nRule.ELSE_FAILURE_STRING = \"else statements must be braced\";\nRule.FOR_FAILURE_STRING = \"for statements must be braced\";\nRule.IF_FAILURE_STRING = \"if statements must be braced\";\nRule.WHILE_FAILURE_STRING = \"while statements must be braced\";\nexports.Rule = Rule;\nvar CurlyWalker = (function (_super) {\n    __extends(CurlyWalker, _super);\n    function CurlyWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        var args = _this.getOptions();\n        _this.optionIgnoreSameLine = args.indexOf(OPTION_IGNORE_SAME_LINE) > -1;\n        return _this;\n    }\n    CurlyWalker.prototype.visitForInStatement = function (node) {\n        if (!isStatementBraced(node.statement)\n            && this.areBracketsRequired(node, node.statement)) {\n            this.addFailureAtNode(node, Rule.FOR_FAILURE_STRING);\n        }\n        _super.prototype.visitForInStatement.call(this, node);\n    };\n    CurlyWalker.prototype.visitForOfStatement = function (node) {\n        if (!isStatementBraced(node.statement)\n            && this.areBracketsRequired(node, node.statement)) {\n            this.addFailureAtNode(node, Rule.FOR_FAILURE_STRING);\n        }\n        _super.prototype.visitForOfStatement.call(this, node);\n    };\n    CurlyWalker.prototype.visitForStatement = function (node) {\n        if (!isStatementBraced(node.statement)\n            && this.areBracketsRequired(node, node.statement)) {\n            this.addFailureAtNode(node, Rule.FOR_FAILURE_STRING);\n        }\n        _super.prototype.visitForStatement.call(this, node);\n    };\n    CurlyWalker.prototype.visitIfStatement = function (node) {\n        if (!isStatementBraced(node.thenStatement)\n            && this.areBracketsRequired(node, node.thenStatement)) {\n            this.addFailureFromStartToEnd(node.getStart(), node.thenStatement.getEnd(), Rule.IF_FAILURE_STRING);\n        }\n        if (node.elseStatement != null\n            && node.elseStatement.kind !== ts.SyntaxKind.IfStatement\n            && !isStatementBraced(node.elseStatement)) {\n            // find the else keyword to check placement (and to place the error appropriately)\n            var elseKeywordNode = Lint.childOfKind(node, ts.SyntaxKind.ElseKeyword);\n            if (this.areBracketsRequired(elseKeywordNode, node.elseStatement)) {\n                this.addFailureFromStartToEnd(elseKeywordNode.getStart(), node.elseStatement.getEnd(), Rule.ELSE_FAILURE_STRING);\n            }\n        }\n        _super.prototype.visitIfStatement.call(this, node);\n    };\n    CurlyWalker.prototype.visitDoStatement = function (node) {\n        if (!isStatementBraced(node.statement)\n            && this.areBracketsRequired(node, node.statement)) {\n            this.addFailureAtNode(node, Rule.DO_FAILURE_STRING);\n        }\n        _super.prototype.visitDoStatement.call(this, node);\n    };\n    CurlyWalker.prototype.visitWhileStatement = function (node) {\n        if (!isStatementBraced(node.statement)\n            && this.areBracketsRequired(node, node.statement)) {\n            this.addFailureAtNode(node, Rule.WHILE_FAILURE_STRING);\n        }\n        _super.prototype.visitWhileStatement.call(this, node);\n    };\n    CurlyWalker.prototype.areBracketsRequired = function (keywordNode, queryStatement) {\n        // Brackets are required if the node & statement don't fit any configured exceptions\n        return !(this.optionIgnoreSameLine && areOnSameLine(keywordNode, queryStatement));\n    };\n    return CurlyWalker;\n}(Lint.RuleWalker));\nfunction isStatementBraced(node) {\n    return node.kind === ts.SyntaxKind.Block;\n}\nfunction areOnSameLine(node, statement) {\n    var file = node.getSourceFile();\n    var nodeStartPos = file.getLineAndCharacterOfPosition(node.getStart());\n    var statementStartPos = file.getLineAndCharacterOfPosition(statement.getStart());\n    var statementEndPos = file.getLineAndCharacterOfPosition(statement.getEnd());\n    return nodeStartPos.line === statementStartPos.line\n        && nodeStartPos.line === statementEndPos.line;\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/forinRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ForInWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"forin\",\n    description: \"Requires a `for ... in` statement to be filtered with an `if` statement.\",\n    rationale: (_a = [\"\\n            ```ts\\n            for (let key in someObject) {\\n                if (someObject.hasOwnProperty(key)) {\\n                    // code here\\n                }\\n            }\\n            ```\\n            Prevents accidental iteration over properties inherited from an object's prototype.\\n            See [MDN's `for...in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)\\n            documentation for more information about `for...in` loops.\"], _a.raw = [\"\\n            \\\\`\\\\`\\\\`ts\\n            for (let key in someObject) {\\n                if (someObject.hasOwnProperty(key)) {\\n                    // code here\\n                }\\n            }\\n            \\\\`\\\\`\\\\`\\n            Prevents accidental iteration over properties inherited from an object's prototype.\\n            See [MDN's \\\\`for...in\\\\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)\\n            documentation for more information about \\\\`for...in\\\\` loops.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"for (... in ...) statements must be filtered with an if statement\";\nexports.Rule = Rule;\nvar ForInWalker = (function (_super) {\n    __extends(ForInWalker, _super);\n    function ForInWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ForInWalker.prototype.visitForInStatement = function (node) {\n        this.handleForInStatement(node);\n        _super.prototype.visitForInStatement.call(this, node);\n    };\n    ForInWalker.prototype.handleForInStatement = function (node) {\n        var statement = node.statement;\n        var statementKind = node.statement.kind;\n        // a direct if statement under a for...in is valid\n        if (statementKind === ts.SyntaxKind.IfStatement) {\n            return;\n        }\n        // if there is a block, verify that it has a single if statement or starts with if (..) continue;\n        if (statementKind === ts.SyntaxKind.Block) {\n            var blockNode = statement;\n            var blockStatements = blockNode.statements;\n            if (blockStatements.length >= 1) {\n                var firstBlockStatement = blockStatements[0];\n                if (firstBlockStatement.kind === ts.SyntaxKind.IfStatement) {\n                    // if this \"if\" statement is the only statement within the block\n                    if (blockStatements.length === 1) {\n                        return;\n                    }\n                    // if this \"if\" statement has a single continue block\n                    var ifStatement = firstBlockStatement.thenStatement;\n                    if (nodeIsContinue(ifStatement)) {\n                        return;\n                    }\n                }\n            }\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING);\n    };\n    return ForInWalker;\n}(Lint.RuleWalker));\nfunction nodeIsContinue(node) {\n    var kind = node.kind;\n    if (kind === ts.SyntaxKind.ContinueStatement) {\n        return true;\n    }\n    if (kind === ts.SyntaxKind.Block) {\n        var blockStatements = node.statements;\n        if (blockStatements.length === 1 && blockStatements[0].kind === ts.SyntaxKind.ContinueStatement) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/labelPositionRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new LabelPositionWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"label-position\",\n    description: \"Only allows labels in sensible locations.\",\n    descriptionDetails: \"This rule only allows labels to be on `do/for/while/switch` statements.\",\n    rationale: (_a = [\"\\n            Labels in JavaScript only can be used in conjunction with `break` or `continue`,\\n            constructs meant to be used for loop flow control. While you can theoretically use\\n            labels on any block statement in JS, it is considered poor code structure to do so.\"], _a.raw = [\"\\n            Labels in JavaScript only can be used in conjunction with \\\\`break\\\\` or \\\\`continue\\\\`,\\n            constructs meant to be used for loop flow control. While you can theoretically use\\n            labels on any block statement in JS, it is considered poor code structure to do so.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"unexpected label on statement\";\nexports.Rule = Rule;\nvar LabelPositionWalker = (function (_super) {\n    __extends(LabelPositionWalker, _super);\n    function LabelPositionWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LabelPositionWalker.prototype.visitLabeledStatement = function (node) {\n        var statement = node.statement;\n        if (statement.kind !== ts.SyntaxKind.DoStatement\n            && statement.kind !== ts.SyntaxKind.ForStatement\n            && statement.kind !== ts.SyntaxKind.ForInStatement\n            && statement.kind !== ts.SyntaxKind.ForOfStatement\n            && statement.kind !== ts.SyntaxKind.WhileStatement\n            && statement.kind !== ts.SyntaxKind.SwitchStatement) {\n            this.addFailureAtNode(node.label, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitLabeledStatement.call(this, node);\n    };\n    return LabelPositionWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noArgRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-arg\",\n    description: \"Disallows use of `arguments.callee`.\",\n    rationale: (_a = [\"\\n            Using `arguments.callee` makes various performance optimizations impossible.\\n            See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\\n            for more details on why to avoid `arguments.callee`.\"], _a.raw = [\"\\n            Using \\\\`arguments.callee\\\\` makes various performance optimizations impossible.\\n            See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\\n            for more details on why to avoid \\\\`arguments.callee\\\\`.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Access to arguments.callee is forbidden\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isPropertyAccessExpression(node) &&\n            node.name.text === \"callee\" &&\n            node.expression.kind === ts.SyntaxKind.Identifier && node.expression.text === \"arguments\") {\n            return ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noBitwiseRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-bitwise\",\n    description: \"Disallows bitwise operators.\",\n    descriptionDetails: (_a = [\"\\n            Specifically, the following bitwise operators are banned:\\n            `&`, `&=`, `|`, `|=`,\\n            `^`, `^=`, `<<`, `<<=`,\\n            `>>`, `>>=`, `>>>`, `>>>=`, and `~`.\\n            This rule does not ban the use of `&` and `|` for intersection and union types.\"], _a.raw = [\"\\n            Specifically, the following bitwise operators are banned:\\n            \\\\`&\\\\`, \\\\`&=\\\\`, \\\\`|\\\\`, \\\\`|=\\\\`,\\n            \\\\`^\\\\`, \\\\`^=\\\\`, \\\\`<<\\\\`, \\\\`<<=\\\\`,\\n            \\\\`>>\\\\`, \\\\`>>=\\\\`, \\\\`>>>\\\\`, \\\\`>>>=\\\\`, and \\\\`~\\\\`.\\n            This rule does not ban the use of \\\\`&\\\\` and \\\\`|\\\\` for intersection and union types.\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            Bitwise operators are often typos - for example `bool1 & bool2` instead of `bool1 && bool2`.\\n            They also can be an indicator of overly clever code which decreases maintainability.\"], _b.raw = [\"\\n            Bitwise operators are often typos - for example \\\\`bool1 & bool2\\\\` instead of \\\\`bool1 && bool2\\\\`.\\n            They also can be an indicator of overly clever code which decreases maintainability.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Forbidden bitwise operation\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            switch (node.operatorToken.kind) {\n                case ts.SyntaxKind.AmpersandToken:\n                case ts.SyntaxKind.AmpersandEqualsToken:\n                case ts.SyntaxKind.BarToken:\n                case ts.SyntaxKind.BarEqualsToken:\n                case ts.SyntaxKind.CaretToken:\n                case ts.SyntaxKind.CaretEqualsToken:\n                case ts.SyntaxKind.LessThanLessThanToken:\n                case ts.SyntaxKind.LessThanLessThanEqualsToken:\n                case ts.SyntaxKind.GreaterThanGreaterThanToken:\n                case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n                    ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n        else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression &&\n            node.operator === ts.SyntaxKind.TildeToken) {\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noConditionalAssignmentRule.js":"/**\n * @license\n * Copyright 2015 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var walker = new NoConditionalAssignmentWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(walker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-conditional-assignment\",\n    description: \"Disallows any type of assignment in conditionals.\",\n    descriptionDetails: \"This applies to `do-while`, `for`, `if`, and `while` statements.\",\n    rationale: (_a = [\"\\n            Assignments in conditionals are often typos:\\n            for example `if (var1 = var2)` instead of `if (var1 == var2)`.\\n            They also can be an indicator of overly clever code which decreases maintainability.\"], _a.raw = [\"\\n            Assignments in conditionals are often typos:\\n            for example \\\\`if (var1 = var2)\\\\` instead of \\\\`if (var1 == var2)\\\\`.\\n            They also can be an indicator of overly clever code which decreases maintainability.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Assignments in conditional expressions are forbidden\";\nexports.Rule = Rule;\nvar NoConditionalAssignmentWalker = (function (_super) {\n    __extends(NoConditionalAssignmentWalker, _super);\n    function NoConditionalAssignmentWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isInConditional = false;\n        return _this;\n    }\n    NoConditionalAssignmentWalker.prototype.visitIfStatement = function (node) {\n        this.validateConditionalExpression(node.expression);\n        _super.prototype.visitIfStatement.call(this, node);\n    };\n    NoConditionalAssignmentWalker.prototype.visitWhileStatement = function (node) {\n        this.validateConditionalExpression(node.expression);\n        _super.prototype.visitWhileStatement.call(this, node);\n    };\n    NoConditionalAssignmentWalker.prototype.visitDoStatement = function (node) {\n        this.validateConditionalExpression(node.expression);\n        _super.prototype.visitDoStatement.call(this, node);\n    };\n    NoConditionalAssignmentWalker.prototype.visitForStatement = function (node) {\n        if (node.condition != null) {\n            this.validateConditionalExpression(node.condition);\n        }\n        _super.prototype.visitForStatement.call(this, node);\n    };\n    NoConditionalAssignmentWalker.prototype.visitBinaryExpression = function (expression) {\n        if (this.isInConditional) {\n            this.checkForAssignment(expression);\n        }\n        _super.prototype.visitBinaryExpression.call(this, expression);\n    };\n    NoConditionalAssignmentWalker.prototype.validateConditionalExpression = function (expression) {\n        this.isInConditional = true;\n        if (expression.kind === ts.SyntaxKind.BinaryExpression) {\n            // check for simple assignment in a conditional, like `if (a = 1) {`\n            this.checkForAssignment(expression);\n        }\n        // walk the children of the conditional expression for nested assignments, like `if ((a = 1) && (b == 1)) {`\n        this.walkChildren(expression);\n        this.isInConditional = false;\n    };\n    NoConditionalAssignmentWalker.prototype.checkForAssignment = function (expression) {\n        if (isAssignmentToken(expression.operatorToken)) {\n            this.addFailureAtNode(expression, Rule.FAILURE_STRING);\n        }\n    };\n    return NoConditionalAssignmentWalker;\n}(Lint.RuleWalker));\nfunction isAssignmentToken(token) {\n    return token.kind >= ts.SyntaxKind.FirstAssignment && token.kind <= ts.SyntaxKind.LastAssignment;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noConsoleRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BanRule = require(\"./banRule\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.apply = function (sourceFile) {\n        var options = this.getOptions();\n        var consoleBanWalker = new BanRule.BanFunctionWalker(sourceFile, this.getOptions());\n        for (var _i = 0, _a = options.ruleArguments; _i < _a.length; _i++) {\n            var option = _a[_i];\n            consoleBanWalker.addBannedFunction([\"console\", option]);\n        }\n        return this.applyWithWalker(consoleBanWalker);\n    };\n    return Rule;\n}(BanRule.Rule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-console\",\n    description: \"Bans the use of specified `console` methods.\",\n    rationale: \"In general, \\`console\\` methods aren't appropriate for production code.\",\n    optionsDescription: \"A list of method names to ban.\",\n    options: {\n        type: \"array\",\n        items: { type: \"string\" },\n    },\n    optionExamples: [\"[true, \\\"log\\\", \\\"error\\\"]\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/banRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var options = this.getOptions();\n        var banFunctionWalker = new BanFunctionWalker(sourceFile, options);\n        var functionsToBan = options.ruleArguments;\n        if (functionsToBan !== undefined) {\n            functionsToBan.forEach(function (f) { return banFunctionWalker.addBannedFunction(f); });\n        }\n        return this.applyWithWalker(banFunctionWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"ban\",\n    description: \"Bans the use of specific functions or global methods.\",\n    optionsDescription: (_a = [\"\\n            A list of `['object', 'method', 'optional explanation here']` or `['globalMethod']` which ban `object.method()`\\n            or respectively `globalMethod()`.\"], _a.raw = [\"\\n            A list of \\\\`['object', 'method', 'optional explanation here']\\\\` or \\\\`['globalMethod']\\\\` which ban \\\\`object.method()\\\\`\\n            or respectively \\\\`globalMethod()\\\\`.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"list\",\n        listType: {\n            type: \"array\",\n            items: { type: \"string\" },\n            minLength: 1,\n            maxLength: 3,\n        },\n    },\n    optionExamples: [\"[true, [\\\"someGlobalMethod\\\"], [\\\"someObject\\\", \\\"someFunction\\\"],\\n                          [\\\"someObject\\\", \\\"otherFunction\\\", \\\"Optional explanation\\\"]]\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (expression, messageAddition) {\n    return \"Calls to '\" + expression + \"' are not allowed.\" + (messageAddition ? \" \" + messageAddition : \"\");\n};\nexports.Rule = Rule;\nvar BanFunctionWalker = (function (_super) {\n    __extends(BanFunctionWalker, _super);\n    function BanFunctionWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.bannedGlobalFunctions = [];\n        _this.bannedFunctions = [];\n        return _this;\n    }\n    BanFunctionWalker.prototype.addBannedFunction = function (bannedFunction) {\n        if (bannedFunction.length === 1) {\n            this.bannedGlobalFunctions.push(bannedFunction[0]);\n        }\n        else if (bannedFunction.length >= 2) {\n            this.bannedFunctions.push(bannedFunction);\n        }\n    };\n    BanFunctionWalker.prototype.visitCallExpression = function (node) {\n        var expression = node.expression;\n        this.checkForObjectMethodBan(expression);\n        this.checkForGlobalBan(expression);\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    BanFunctionWalker.prototype.checkForObjectMethodBan = function (expression) {\n        if (expression.kind === ts.SyntaxKind.PropertyAccessExpression\n            && expression.getChildCount() >= 3) {\n            var firstToken = expression.getFirstToken();\n            var firstChild = expression.getChildAt(0);\n            var secondChild = expression.getChildAt(1);\n            var thirdChild = expression.getChildAt(2);\n            var rightSideExpression = thirdChild.getFullText();\n            var leftSideExpression = void 0;\n            if (firstChild.getChildCount() > 0) {\n                leftSideExpression = firstChild.getLastToken().getText();\n            }\n            else {\n                leftSideExpression = firstToken.getText();\n            }\n            if (secondChild.kind === ts.SyntaxKind.DotToken) {\n                for (var _i = 0, _a = this.bannedFunctions; _i < _a.length; _i++) {\n                    var bannedFunction = _a[_i];\n                    if (leftSideExpression === bannedFunction[0] && rightSideExpression === bannedFunction[1]) {\n                        var failure = Rule.FAILURE_STRING_FACTORY(leftSideExpression + \".\" + rightSideExpression, bannedFunction[2]);\n                        this.addFailureAtNode(expression, failure);\n                    }\n                }\n            }\n        }\n    };\n    BanFunctionWalker.prototype.checkForGlobalBan = function (expression) {\n        if (expression.kind === ts.SyntaxKind.Identifier) {\n            var identifierName = expression.text;\n            if (this.bannedGlobalFunctions.indexOf(identifierName) !== -1) {\n                this.addFailureAtNode(expression, Rule.FAILURE_STRING_FACTORY(\"\" + identifierName));\n            }\n        }\n    };\n    return BanFunctionWalker;\n}(Lint.RuleWalker));\nexports.BanFunctionWalker = BanFunctionWalker;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noConstructRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-construct\",\n    description: \"Disallows access to the constructors of `String`, `Number`, and `Boolean`.\",\n    descriptionDetails: \"Disallows constructor use such as `new Number(foo)` but does not disallow `Number(foo)`.\",\n    rationale: (_a = [\"\\n            There is little reason to use `String`, `Number`, or `Boolean` as constructors.\\n            In almost all cases, the regular function-call version is more appropriate.\\n            [More details](http://stackoverflow.com/q/4719320/3124288) are available on StackOverflow.\"], _a.raw = [\"\\n            There is little reason to use \\\\`String\\\\`, \\\\`Number\\\\`, or \\\\`Boolean\\\\` as constructors.\\n            In almost all cases, the regular function-call version is more appropriate.\\n            [More details](http://stackoverflow.com/q/4719320/3124288) are available on StackOverflow.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Forbidden constructor, use a literal or simple function call instead\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isNewExpression(node) && node.expression.kind === ts.SyntaxKind.Identifier) {\n            switch (node.expression.text) {\n                case \"Boolean\":\n                case \"String\":\n                case \"Number\":\n                    ctx.addFailure(node.getStart(ctx.sourceFile), node.expression.end, Rule.FAILURE_STRING);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noDebuggerRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-debugger\",\n    description: \"Disallows `debugger` statements.\",\n    rationale: \"In general, \\`debugger\\` statements aren't appropriate for production code.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Use of debugger statements is forbidden\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.DebuggerStatement) {\n            return ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noDuplicateSuperRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-duplicate-super\",\n    description: \"Warns if 'super()' appears twice in a constructor.\",\n    rationale: \"The second call to 'super()' will fail at runtime.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_DUPLICATE = \"Multiple calls to 'super()' found. It must be called only once.\";\nRule.FAILURE_STRING_LOOP = \"'super()' called in a loop. It must be called only once.\";\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Whether we've seen 'super()' yet in the current constructor. */\n    Walker.prototype.visitConstructorDeclaration = function (node) {\n        if (!node.body) {\n            return;\n        }\n        this.getSuperForNode(node.body);\n        _super.prototype.visitConstructorDeclaration.call(this, node);\n    };\n    Walker.prototype.getSuperForNode = function (node) {\n        if (Lint.isLoop(node)) {\n            var bodySuper = this.combineSequentialChildren(node);\n            if (typeof bodySuper === \"number\") {\n                return 0 /* NoSuper */;\n            }\n            if (!bodySuper.break) {\n                this.addFailureAtNode(bodySuper.node, Rule.FAILURE_STRING_LOOP);\n            }\n            return __assign({}, bodySuper, { break: false });\n        }\n        switch (node.kind) {\n            case ts.SyntaxKind.ReturnStatement:\n            case ts.SyntaxKind.ThrowStatement:\n                return 1 /* Return */;\n            case ts.SyntaxKind.BreakStatement:\n                return 2 /* Break */;\n            case ts.SyntaxKind.ClassDeclaration:\n            case ts.SyntaxKind.ClassExpression:\n                // 'super()' is bound differently inside, so ignore.\n                return 0 /* NoSuper */;\n            case ts.SyntaxKind.SuperKeyword:\n                return node.parent.kind === ts.SyntaxKind.CallExpression && node.parent.expression === node\n                    ? { node: node.parent, break: false }\n                    : 0 /* NoSuper */;\n            case ts.SyntaxKind.IfStatement: {\n                var _a = node, thenStatement = _a.thenStatement, elseStatement = _a.elseStatement;\n                return worse(this.getSuperForNode(thenStatement), elseStatement ? this.getSuperForNode(elseStatement) : 0 /* NoSuper */);\n            }\n            case ts.SyntaxKind.SwitchStatement:\n                return this.getSuperForSwitch(node);\n            default:\n                return this.combineSequentialChildren(node);\n        }\n    };\n    Walker.prototype.getSuperForSwitch = function (node) {\n        // 'super()' from any clause. Used to track whether 'super()' happens in the switch at all.\n        var foundSingle;\n        // 'super()' from the previous clause if it did not 'break;'.\n        var fallthroughSingle;\n        for (var _i = 0, _a = node.caseBlock.clauses; _i < _a.length; _i++) {\n            var clause = _a[_i];\n            var clauseSuper = this.combineSequentialChildren(clause);\n            switch (clauseSuper) {\n                case 0 /* NoSuper */:\n                    break;\n                case 2 /* Break */:\n                    fallthroughSingle = undefined;\n                    break;\n                case 1 /* Return */:\n                    return 0 /* NoSuper */;\n                default:\n                    if (fallthroughSingle) {\n                        this.addDuplicateFailure(fallthroughSingle, clauseSuper.node);\n                    }\n                    if (!clauseSuper.break) {\n                        fallthroughSingle = clauseSuper.node;\n                    }\n                    foundSingle = clauseSuper.node;\n                    break;\n            }\n        }\n        return foundSingle ? { node: foundSingle, break: false } : 0 /* NoSuper */;\n    };\n    /**\n     * Combines children that come one after another.\n     * (As opposed to if/else, switch, or loops, which need their own handling.)\n     */\n    Walker.prototype.combineSequentialChildren = function (node) {\n        var _this = this;\n        var seenSingle;\n        var res = ts.forEachChild(node, function (child) {\n            var childSuper = _this.getSuperForNode(child);\n            switch (childSuper) {\n                case 0 /* NoSuper */:\n                    return;\n                case 2 /* Break */:\n                    if (seenSingle) {\n                        return __assign({}, seenSingle, { break: true });\n                    }\n                    return childSuper;\n                case 1 /* Return */:\n                    return childSuper;\n                default:\n                    if (seenSingle && !seenSingle.break) {\n                        _this.addDuplicateFailure(seenSingle.node, childSuper.node);\n                    }\n                    seenSingle = childSuper;\n                    return;\n            }\n        });\n        return res || seenSingle || 0 /* NoSuper */;\n    };\n    Walker.prototype.addDuplicateFailure = function (a, b) {\n        this.addFailureFromStartToEnd(a.getStart(), b.end, Rule.FAILURE_STRING_DUPLICATE);\n    };\n    return Walker;\n}(Lint.RuleWalker));\n// If/else run separately, so return the branch more likely to result in eventual errors.\nfunction worse(a, b) {\n    return typeof a === \"number\"\n        ? typeof b === \"number\" ? (a < b ? b : a) : b\n        : typeof b === \"number\" ? a : a.break ? b : a;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noDuplicateVariableRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (name) {\n        return \"Duplicate variable: '\" + name + \"'\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-duplicate-variable\",\n    description: \"Disallows duplicate variable declarations in the same block scope.\",\n    descriptionDetails: (_a = [\"\\n            This rule is only useful when using the `var` keyword -\\n            the compiler will detect redeclarations of `let` and `const` variables.\"], _a.raw = [\"\\n            This rule is only useful when using the \\\\`var\\\\` keyword -\\n            the compiler will detect redeclarations of \\\\`let\\\\` and \\\\`const\\\\` variables.\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            A variable can be reassigned if necessary -\\n            there's no good reason to have a duplicate variable declaration.\"], _b.raw = [\"\\n            A variable can be reassigned if necessary -\\n            there's no good reason to have a duplicate variable declaration.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var scope = new Set();\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (utils.isFunctionScopeBoundary(node)) {\n            var oldScope = scope;\n            scope = new Set();\n            ts.forEachChild(node, cb);\n            scope = oldScope;\n            return;\n        }\n        else if (utils.isVariableDeclaration(node) && !utils.isBlockScopedVariableDeclaration(node)) {\n            forEachBoundIdentifier(node.name, function (id) {\n                var text = id.text;\n                if (scope.has(text)) {\n                    ctx.addFailureAtNode(id, Rule.FAILURE_STRING(text));\n                }\n                else {\n                    scope.add(text);\n                }\n            });\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction forEachBoundIdentifier(name, action) {\n    if (name.kind === ts.SyntaxKind.Identifier) {\n        action(name);\n    }\n    else {\n        for (var _i = 0, _a = name.elements; _i < _a.length; _i++) {\n            var e = _a[_i];\n            if (e.kind !== ts.SyntaxKind.OmittedExpression) {\n                forEachBoundIdentifier(e.name, action);\n            }\n        }\n    }\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noEmptyRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-empty\",\n    description: \"Disallows empty blocks.\",\n    descriptionDetails: \"Blocks with a comment inside are not considered empty.\",\n    rationale: \"Empty blocks are often indicators of missing code.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"block is empty\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.Block &&\n            node.statements.length === 0 &&\n            !isExcludedConstructor(node.parent)) {\n            var start = node.getStart(ctx.sourceFile);\n            // Block always starts with open brace. Adding 1 to its start gives us the end of the brace,\n            // which can be used to conveniently check for comments between braces\n            if (Lint.hasCommentAfterPosition(ctx.sourceFile.text, start + 1)) {\n                return;\n            }\n            return ctx.addFailure(start, node.end, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction isExcludedConstructor(node) {\n    return tsutils_1.isConstructorDeclaration(node) &&\n        (\n        /* If constructor is private or protected, the block is allowed to be empty.\n           The constructor is there on purpose to disallow instantiation from outside the class */\n        /* The public modifier does not serve a purpose here. It can only be used to allow instantiation of a base class where\n           the super constructor is protected. But then the block would not be empty, because of the call to super() */\n        tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.PrivateKeyword, ts.SyntaxKind.ProtectedKeyword) ||\n            node.parameters.some(tsutils_1.isParameterProperty));\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noEvalRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-eval\",\n    description: \"Disallows `eval` function invocations.\",\n    rationale: (_a = [\"\\n            `eval()` is dangerous as it allows arbitrary code execution with full privileges. There are\\n            [alternatives](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)\\n            for most of the use cases for `eval()`.\"], _a.raw = [\"\\n            \\\\`eval()\\\\` is dangerous as it allows arbitrary code execution with full privileges. There are\\n            [alternatives](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)\\n            for most of the use cases for \\\\`eval()\\\\`.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"forbidden eval\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isCallExpression(node) &&\n            node.expression.kind === ts.SyntaxKind.Identifier && node.expression.text === \"eval\") {\n            ctx.addFailureAtNode(node.expression, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noFloatingPromisesRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var walker = new NoFloatingPromisesWalker(sourceFile, this.getOptions(), program);\n        for (var _i = 0, _a = this.ruleArguments; _i < _a.length; _i++) {\n            var className = _a[_i];\n            walker.addPromiseClass(className);\n        }\n        return this.applyWithWalker(walker);\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-floating-promises\",\n    description: \"Promises returned by functions must be handled appropriately.\",\n    optionsDescription: (_a = [\"\\n            A list of 'string' names of any additional classes that should also be handled as Promises.\\n        \"], _a.raw = [\"\\n            A list of \\\\'string\\\\' names of any additional classes that should also be handled as Promises.\\n        \"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"list\",\n        listType: {\n            type: \"array\",\n            items: { type: \"string\" },\n        },\n    },\n    optionExamples: [\"true\", \"[true, \\\"JQueryPromise\\\"]\"],\n    rationale: \"Unhandled Promises can cause unexpected behavior, such as resolving at unexpected times.\",\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Promises must be handled appropriately\";\nexports.Rule = Rule;\nvar NoFloatingPromisesWalker = (function (_super) {\n    __extends(NoFloatingPromisesWalker, _super);\n    function NoFloatingPromisesWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.promiseClasses = [\"Promise\"];\n        return _this;\n    }\n    NoFloatingPromisesWalker.prototype.addPromiseClass = function (className) {\n        this.promiseClasses.push(className);\n    };\n    NoFloatingPromisesWalker.prototype.visitCallExpression = function (node) {\n        this.checkNode(node);\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    NoFloatingPromisesWalker.prototype.visitExpressionStatement = function (node) {\n        this.checkNode(node);\n        _super.prototype.visitExpressionStatement.call(this, node);\n    };\n    NoFloatingPromisesWalker.prototype.checkNode = function (node) {\n        if (node.parent && this.kindCanContainPromise(node.parent.kind)) {\n            return;\n        }\n        var typeChecker = this.getTypeChecker();\n        var type = typeChecker.getTypeAtLocation(node);\n        if (this.symbolIsPromise(type.symbol)) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n    };\n    NoFloatingPromisesWalker.prototype.symbolIsPromise = function (symbol) {\n        if (!symbol) {\n            return false;\n        }\n        return this.promiseClasses.indexOf(symbol.name) !== -1;\n    };\n    NoFloatingPromisesWalker.prototype.kindCanContainPromise = function (kind) {\n        return !NoFloatingPromisesWalker.barredParentKinds[kind];\n    };\n    return NoFloatingPromisesWalker;\n}(Lint.ProgramAwareRuleWalker));\nNoFloatingPromisesWalker.barredParentKinds = (_b = {},\n    _b[ts.SyntaxKind.Block] = true,\n    _b[ts.SyntaxKind.ExpressionStatement] = true,\n    _b[ts.SyntaxKind.SourceFile] = true,\n    _b);\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noForInArrayRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-for-in-array\",\n    description: \"Disallows iterating over an array with a for-in loop.\",\n    descriptionDetails: (_a = [\"\\n            A for-in loop (`for (var k in o)`) iterates over the properties of an Object.\\n\\n            While it is legal to use for-in loops with array types, it is not common.\\n            for-in will iterate over the indices of the array as strings, omitting any \\\"holes\\\" in\\n            the array.\\n\\n            More common is to use for-of, which iterates over the values of an array.\\n            If you want to iterate over the indices, alternatives include:\\n\\n            array.forEach((value, index) => { ... });\\n            for (const [index, value] of array.entries()) { ... }\\n            for (let i = 0; i < array.length; i++) { ... }\\n            \"], _a.raw = [\"\\n            A for-in loop (\\\\`for (var k in o)\\\\`) iterates over the properties of an Object.\\n\\n            While it is legal to use for-in loops with array types, it is not common.\\n            for-in will iterate over the indices of the array as strings, omitting any \\\"holes\\\" in\\n            the array.\\n\\n            More common is to use for-of, which iterates over the values of an array.\\n            If you want to iterate over the indices, alternatives include:\\n\\n            array.forEach((value, index) => { ... });\\n            for (const [index, value] of array.entries()) { ... }\\n            for (let i = 0; i < array.length; i++) { ... }\\n            \"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    requiresTypeInfo: true,\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"for-in loops over arrays are forbidden. Use for-of or array.forEach instead.\";\nexports.Rule = Rule;\nfunction walk(ctx, program) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.ForInStatement) {\n            var type = program.getTypeChecker().getTypeAtLocation(node.expression);\n            if (type.symbol !== undefined && type.symbol.name === \"Array\" ||\n                // tslint:disable-next-line:no-bitwise\n                (type.flags & ts.TypeFlags.StringLike) !== 0) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noInferredEmptyObjectTypeRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../language/utils\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new NoInferredEmptyObjectTypeRule(sourceFile, this.getOptions(), program));\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-inferred-empty-object-type\",\n    description: \"Disallow type inference of {} (empty object type) at function and constructor call sites\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.EMPTY_INTERFACE_INSTANCE = \"Explicit type parameter needs to be provided to the constructor\";\nRule.EMPTY_INTERFACE_FUNCTION = \"Explicit type parameter needs to be provided to the function call\";\nexports.Rule = Rule;\nvar NoInferredEmptyObjectTypeRule = (function (_super) {\n    __extends(NoInferredEmptyObjectTypeRule, _super);\n    function NoInferredEmptyObjectTypeRule(srcFile, lintOptions, program) {\n        var _this = _super.call(this, srcFile, lintOptions, program) || this;\n        _this.checker = _this.getTypeChecker();\n        return _this;\n    }\n    NoInferredEmptyObjectTypeRule.prototype.visitNewExpression = function (node) {\n        var _this = this;\n        var nodeTypeArgs = node.typeArguments;\n        var isObjectReference;\n        if (ts.TypeFlags.Reference != null) {\n            // typescript 2.0.x specific code\n            isObjectReference = function (o) { return utils_1.isTypeFlagSet(o, ts.TypeFlags.Reference); };\n        }\n        else {\n            isObjectReference = function (o) { return utils_1.isTypeFlagSet(o, ts.TypeFlags.Object); };\n        }\n        if (nodeTypeArgs === undefined) {\n            var objType = this.checker.getTypeAtLocation(node);\n            if (isObjectReference(objType) && objType.typeArguments !== undefined) {\n                var typeArgs = objType.typeArguments;\n                typeArgs.forEach(function (a) {\n                    if (_this.isEmptyObjectInterface(a)) {\n                        _this.addFailureAtNode(node, Rule.EMPTY_INTERFACE_INSTANCE);\n                    }\n                });\n            }\n        }\n        _super.prototype.visitNewExpression.call(this, node);\n    };\n    NoInferredEmptyObjectTypeRule.prototype.visitCallExpression = function (node) {\n        if (node.typeArguments === undefined) {\n            var callSig = this.checker.getResolvedSignature(node);\n            var retType = this.checker.getReturnTypeOfSignature(callSig);\n            if (this.isEmptyObjectInterface(retType)) {\n                this.addFailureAtNode(node, Rule.EMPTY_INTERFACE_FUNCTION);\n            }\n        }\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    NoInferredEmptyObjectTypeRule.prototype.isEmptyObjectInterface = function (objType) {\n        var _this = this;\n        var isAnonymous;\n        if (ts.ObjectFlags == null) {\n            // typescript 2.0.x specific code\n            isAnonymous = utils_1.isTypeFlagSet(objType, ts.TypeFlags.Anonymous);\n        }\n        else {\n            isAnonymous = utils_1.isObjectFlagSet(objType, ts.ObjectFlags.Anonymous);\n        }\n        var hasProblematicCallSignatures = false;\n        var hasProperties = (objType.getProperties() !== undefined && objType.getProperties().length > 0);\n        var hasNumberIndexType = objType.getNumberIndexType() !== undefined;\n        var hasStringIndexType = objType.getStringIndexType() !== undefined;\n        var callSig = objType.getCallSignatures();\n        if (callSig !== undefined && callSig.length > 0) {\n            var isClean = callSig.every(function (sig) {\n                var csigRetType = _this.checker.getReturnTypeOfSignature(sig);\n                return _this.isEmptyObjectInterface(csigRetType);\n            });\n            if (!isClean) {\n                hasProblematicCallSignatures = true;\n            }\n        }\n        return (isAnonymous && !hasProblematicCallSignatures && !hasProperties && !hasNumberIndexType && !hasStringIndexType);\n    };\n    return NoInferredEmptyObjectTypeRule;\n}(Lint.ProgramAwareRuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noInvalidTemplateStringsRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-invalid-template-strings\",\n    // tslint:disable-next-line no-invalid-template-strings\n    description: \"Warns on use of `${` in non-template strings.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Interpolation will only work for template strings.\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (utils.isStringLiteral(node)) {\n            check(node);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function check(node) {\n        var idx = node.text.search(/\\$\\{/);\n        if (idx !== -1) {\n            var textStart = node.getStart() + 1;\n            ctx.addFailureAt(textStart + idx, 2, Rule.FAILURE_STRING);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noMisusedNewRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-misused-new\",\n    description: \"Warns on apparent attempts to define constructors for interfaces or `new` for classes.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_INTERFACE = \"Interfaces cannot be constructed, only classes. Did you mean `declare class`?\";\nRule.FAILURE_STRING_CLASS = '`new` in a class is a method named \"new\". Did you mean `constructor`?';\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isMethodSignature(node)) {\n            if (tsutils_1.getPropertyName(node.name) === \"constructor\") {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING_INTERFACE);\n            }\n        }\n        else if (tsutils_1.isMethodDeclaration(node)) {\n            if (node.body === undefined &&\n                tsutils_1.getPropertyName(node.name) === \"new\" &&\n                returnTypeMatchesParent(node.parent, node)) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING_CLASS);\n            }\n        }\n        else if (tsutils_1.isConstructSignatureDeclaration(node)) {\n            if (returnTypeMatchesParent(node.parent, node)) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING_INTERFACE);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction returnTypeMatchesParent(parent, decl) {\n    if (parent.name === undefined || decl.type === undefined || !tsutils_1.isTypeReferenceNode(decl.type)) {\n        return false;\n    }\n    return decl.type.typeName.kind === ts.SyntaxKind.Identifier && decl.type.typeName.text === parent.name.text;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noNullKeywordRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// with due reference to https://github.com/Microsoft/TypeScript/blob/7813121c4d77e50aad0eed3152ef1f1156c7b574/scripts/tslint/noNullRule.ts\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-null-keyword\",\n    description: \"Disallows use of the `null` keyword literal.\",\n    rationale: (_a = [\"\\n            Instead of having the dual concepts of `null` and`undefined` in a codebase,\\n            this rule ensures that only `undefined` is used.\"], _a.raw = [\"\\n            Instead of having the dual concepts of \\\\`null\\\\` and\\\\`undefined\\\\` in a codebase,\\n            this rule ensures that only \\\\`undefined\\\\` is used.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Use 'undefined' instead of 'null'\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, cb);\n    function cb(node) {\n        if (node.kind >= ts.SyntaxKind.FirstTypeNode && node.kind <= ts.SyntaxKind.LastTypeNode) {\n            return; // skip type nodes\n        }\n        if (node.kind === ts.SyntaxKind.NullKeyword) {\n            return ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noShadowedVariableRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoShadowedVariableWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-shadowed-variable\",\n    description: \"Disallows shadowing variable declarations.\",\n    rationale: \"Shadowing a variable masks access to it and obscures to what value an identifier actually refers.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (name) {\n    return \"Shadowed variable: '\" + name + \"'\";\n};\nexports.Rule = Rule;\nvar NoShadowedVariableWalker = (function (_super) {\n    __extends(NoShadowedVariableWalker, _super);\n    function NoShadowedVariableWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoShadowedVariableWalker.prototype.createScope = function () {\n        return new Set();\n    };\n    NoShadowedVariableWalker.prototype.createBlockScope = function () {\n        return new Set();\n    };\n    NoShadowedVariableWalker.prototype.visitBindingElement = function (node) {\n        var isSingleVariable = node.name.kind === ts.SyntaxKind.Identifier;\n        if (isSingleVariable) {\n            var name = node.name;\n            var variableDeclaration = Lint.getBindingElementVariableDeclaration(node);\n            var isBlockScopedVariable = variableDeclaration !== null && Lint.isBlockScopedVariable(variableDeclaration);\n            this.handleSingleVariableIdentifier(name, isBlockScopedVariable);\n        }\n        _super.prototype.visitBindingElement.call(this, node);\n    };\n    NoShadowedVariableWalker.prototype.visitCatchClause = function (node) {\n        // don't visit the catch clause variable declaration, just visit the block\n        // the catch clause variable declaration has its own special scoping rules\n        this.visitBlock(node.block);\n    };\n    NoShadowedVariableWalker.prototype.visitCallSignature = function (_node) {\n        // don't call super, we don't need to check parameter names in call signatures\n    };\n    NoShadowedVariableWalker.prototype.visitFunctionType = function (_node) {\n        // don't call super, we don't need to check names in function types\n    };\n    NoShadowedVariableWalker.prototype.visitConstructorType = function (_node) {\n        // don't call super, we don't need to check names in constructor types\n    };\n    NoShadowedVariableWalker.prototype.visitIndexSignatureDeclaration = function (_node) {\n        // don't call super, we don't want to walk index signatures\n    };\n    NoShadowedVariableWalker.prototype.visitMethodSignature = function (_node) {\n        // don't call super, we don't want to walk method signatures either\n    };\n    NoShadowedVariableWalker.prototype.visitParameterDeclaration = function (node) {\n        var isSingleParameter = node.name.kind === ts.SyntaxKind.Identifier;\n        if (isSingleParameter) {\n            this.handleSingleVariableIdentifier(node.name, false);\n        }\n        _super.prototype.visitParameterDeclaration.call(this, node);\n    };\n    NoShadowedVariableWalker.prototype.visitTypeLiteral = function (_node) {\n        // don't call super, we don't want to walk the inside of type nodes\n    };\n    NoShadowedVariableWalker.prototype.visitVariableDeclaration = function (node) {\n        var isSingleVariable = node.name.kind === ts.SyntaxKind.Identifier;\n        if (isSingleVariable) {\n            this.handleSingleVariableIdentifier(node.name, Lint.isBlockScopedVariable(node));\n        }\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    NoShadowedVariableWalker.prototype.handleSingleVariableIdentifier = function (variableIdentifier, isBlockScoped) {\n        var variableName = variableIdentifier.text;\n        if (this.isVarInCurrentScope(variableName) && !this.inCurrentBlockScope(variableName)) {\n            // shadowing if there's already a `var` of the same name in the scope AND\n            // it's not in the current block (handled by the 'no-duplicate-variable' rule)\n            this.addFailureOnIdentifier(variableIdentifier);\n        }\n        else if (this.inPreviousBlockScope(variableName)) {\n            // shadowing if there is a `var`, `let`, 'const`, or parameter in a previous block scope\n            this.addFailureOnIdentifier(variableIdentifier);\n        }\n        if (!isBlockScoped) {\n            // `var` variables go on the scope\n            this.getCurrentScope().add(variableName);\n        }\n        // all variables go on block scope, including `var`\n        this.getCurrentBlockScope().add(variableName);\n    };\n    NoShadowedVariableWalker.prototype.isVarInCurrentScope = function (varName) {\n        return this.getCurrentScope().has(varName);\n    };\n    NoShadowedVariableWalker.prototype.inCurrentBlockScope = function (varName) {\n        return this.getCurrentBlockScope().has(varName);\n    };\n    NoShadowedVariableWalker.prototype.inPreviousBlockScope = function (varName) {\n        var _this = this;\n        return this.getAllBlockScopes().some(function (scopeInfo) {\n            return scopeInfo !== _this.getCurrentBlockScope() && scopeInfo.has(varName);\n        });\n    };\n    NoShadowedVariableWalker.prototype.addFailureOnIdentifier = function (ident) {\n        var failureString = Rule.FAILURE_STRING_FACTORY(ident.text);\n        this.addFailureAtNode(ident, failureString);\n    };\n    return NoShadowedVariableWalker;\n}(Lint.BlockScopeAwareRuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noStringLiteralRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoStringLiteralWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-string-literal\",\n    description: \"Disallows object access via string literals.\",\n    rationale: \"Encourages using strongly-typed property access.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"object access via string literals is disallowed\";\nexports.Rule = Rule;\nvar NoStringLiteralWalker = (function (_super) {\n    __extends(NoStringLiteralWalker, _super);\n    function NoStringLiteralWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoStringLiteralWalker.prototype.visitElementAccessExpression = function (node) {\n        var argument = node.argumentExpression;\n        if (argument != null) {\n            var accessorText = argument.getText();\n            // the argument expression should be a string of length at least 2 (due to quote characters)\n            if (argument.kind === ts.SyntaxKind.StringLiteral && accessorText.length > 2) {\n                var unquotedAccessorText = accessorText.substring(1, accessorText.length - 1);\n                // only create a failure if the identifier is valid, in which case there's no need to use string literals\n                if (isValidIdentifier(unquotedAccessorText)) {\n                    this.addFailureAtNode(argument, Rule.FAILURE_STRING);\n                }\n            }\n        }\n        _super.prototype.visitElementAccessExpression.call(this, node);\n    };\n    return NoStringLiteralWalker;\n}(Lint.RuleWalker));\nfunction isValidIdentifier(token) {\n    var scanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, token);\n    scanner.scan();\n    // if we scanned to the end of the token, we can check if the scanned item was an identifier\n    return scanner.getTokenText() === token && scanner.isIdentifier();\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noStringThrowRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-string-throw\",\n    description: \"Flags throwing plain strings or concatenations of strings \" +\n        \"because only Errors produce proper stack traces.\",\n    hasFix: true,\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Throwing plain strings (not instances of Error) gives no stack traces\";\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitThrowStatement = function (node) {\n        var expression = node.expression;\n        if (this.stringConcatRecursive(expression)) {\n            var fix = this.createReplacement(expression.getStart(), expression.getEnd() - expression.getStart(), \"new Error(\" + expression.getText() + \")\");\n            this.addFailureAtNode(node, Rule.FAILURE_STRING, fix);\n        }\n        _super.prototype.visitThrowStatement.call(this, node);\n    };\n    Walker.prototype.stringConcatRecursive = function (node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.StringLiteral:\n            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n            case ts.SyntaxKind.TemplateExpression:\n                return true;\n            case ts.SyntaxKind.BinaryExpression:\n                var n = node;\n                var op = n.operatorToken.kind;\n                return op === ts.SyntaxKind.PlusToken &&\n                    (this.stringConcatRecursive(n.left) ||\n                        this.stringConcatRecursive(n.right));\n            case ts.SyntaxKind.ParenthesizedExpression:\n                return this.stringConcatRecursive(node.expression);\n            default:\n                return false;\n        }\n    };\n    return Walker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noSparseArraysRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-sparse-arrays\",\n    description: \"Forbids array literals to contain missing elements.\",\n    rationale: \"Missing elements are probably an accidentally duplicated comma.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Array has a missing element.\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (!utils.isArrayLiteralExpression(node)) {\n            if (utils.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n                // Ignore LHS of assignments.\n                traverseExpressionsInLHS(node.left, cb);\n                return cb(node.right);\n            }\n            else {\n                return ts.forEachChild(node, cb);\n            }\n        }\n        for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {\n            var element = _a[_i];\n            if (utils.isOmittedExpression(element)) {\n                // Node has an empty range, so just use range starting at `element.pos`.\n                ctx.addFailureAt(element.pos, 1, Rule.FAILURE_STRING);\n            }\n            else {\n                ts.forEachChild(element, cb);\n            }\n        }\n    });\n}\n/** Traverse the LHS of an `=` expression, calling `cb` embedded default value, but ignoring binding patterns. */\nfunction traverseExpressionsInLHS(node, cb) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ParenthesizedExpression:\n            traverseExpressionsInLHS(node.expression, cb);\n            break;\n        case ts.SyntaxKind.ArrayLiteralExpression:\n            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {\n                var e = _a[_i];\n                traverseExpressionsInLHS(e, cb);\n            }\n            break;\n        case ts.SyntaxKind.ObjectLiteralExpression:\n            for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {\n                var o = _c[_b];\n                traverseExpressionsInLHS(o, cb);\n            }\n            break;\n        case ts.SyntaxKind.BinaryExpression: {\n            var _d = node, left = _d.left, operatorToken = _d.operatorToken, right = _d.right;\n            if (operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n                traverseExpressionsInLHS(left, cb);\n                cb(right);\n            }\n            break;\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnboundMethodRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unbound-method\",\n    description: \"Warns when a method is used as outside of a method call.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Avoid referencing unbound methods which may cause unintentional scoping of 'this'.\";\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitPropertyAccessExpression = function (node) {\n        if (!isSafeUse(node)) {\n            var symbol = this.getTypeChecker().getSymbolAtLocation(node);\n            var declaration = symbol && symbol.valueDeclaration;\n            if (declaration && isMethod(declaration)) {\n                this.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n        _super.prototype.visitPropertyAccessExpression.call(this, node);\n    };\n    return Walker;\n}(Lint.ProgramAwareRuleWalker));\nfunction isMethod(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.MethodSignature:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isSafeUse(node) {\n    var parent = node.parent;\n    switch (parent.kind) {\n        case ts.SyntaxKind.CallExpression:\n            return parent.expression === node;\n        case ts.SyntaxKind.TaggedTemplateExpression:\n            return parent.tag === node;\n        // E.g. `obj.method.bind(obj)`.\n        case ts.SyntaxKind.PropertyAccessExpression:\n            return true;\n        // Allow most binary operators, but don't allow e.g. `myArray.forEach(obj.method || otherObj.otherMethod)`.\n        case ts.SyntaxKind.BinaryExpression:\n            return parent.operatorToken.kind !== ts.SyntaxKind.BarBarToken;\n        default:\n            return false;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnsafeAnyRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unsafe-any\",\n    description: (_a = [\"\\n            Warns when using an expression of type 'any' in a dynamic way.\\n            Uses are only allowed if they would work for `{} | null | undefined`.\\n            Type casts and tests are allowed.\\n            Expressions that work on all values (such as `\\\"\\\" + x`) are allowed.\"], _a.raw = [\"\\n            Warns when using an expression of type 'any' in a dynamic way.\\n            Uses are only allowed if they would work for \\\\`{} | null | undefined\\\\`.\\n            Type casts and tests are allowed.\\n            Expressions that work on all values (such as \\\\`\\\"\\\" + x\\\\`) are allowed.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Unsafe use of expression of type 'any'.\";\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    if (ctx.sourceFile.isDeclarationFile) {\n        // Not possible in a declaration file.\n        return;\n    }\n    return ts.forEachChild(ctx.sourceFile, cb);\n    /** @param anyOk If true, this node will be allowed to be of type *any*. (But its children might not.) */\n    function cb(node, anyOk) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ParenthesizedExpression:\n                // Don't warn on a parenthesized expression, warn on its contents.\n                return cb(node.expression, anyOk);\n            case ts.SyntaxKind.Parameter: {\n                var _a = node, type = _a.type, initializer = _a.initializer;\n                if (initializer !== undefined) {\n                    return cb(initializer, /*anyOk*/ type !== undefined && type.kind === ts.SyntaxKind.AnyKeyword);\n                }\n                return;\n            }\n            // Ignore types\n            case ts.SyntaxKind.InterfaceDeclaration:\n            case ts.SyntaxKind.TypeAliasDeclaration:\n            case ts.SyntaxKind.QualifiedName:\n            case ts.SyntaxKind.TypePredicate:\n            case ts.SyntaxKind.TypeOfExpression:\n            // Ignore imports\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n            case ts.SyntaxKind.ImportDeclaration:\n            case ts.SyntaxKind.ExportDeclaration:\n            // For some reason, these are of type \"any\".\n            case ts.SyntaxKind.StringLiteral:\n                return;\n            // Recurse through these, but ignore the immediate child because it is allowed to be 'any'.\n            case ts.SyntaxKind.ExpressionStatement:\n            case ts.SyntaxKind.TypeAssertionExpression:\n            case ts.SyntaxKind.AsExpression:\n            case ts.SyntaxKind.TemplateSpan: // Allow stringification (works on all values). Note: tagged templates handled differently.\n            case ts.SyntaxKind.ThrowStatement: {\n                var expression = node.expression;\n                return cb(expression, /*anyOk*/ true);\n            }\n            case ts.SyntaxKind.PropertyDeclaration: {\n                var _b = node, name = _b.name, initializer = _b.initializer;\n                if (initializer !== undefined) {\n                    return cb(initializer, /*anyOk*/ isNodeAny(name, checker));\n                }\n                return;\n            }\n            case ts.SyntaxKind.TaggedTemplateExpression: {\n                var _c = node, tag = _c.tag, template = _c.template;\n                cb(tag);\n                if (template.kind === ts.SyntaxKind.TemplateExpression) {\n                    for (var _i = 0, _d = template.templateSpans; _i < _d.length; _i++) {\n                        var expression = _d[_i].expression;\n                        checkContextual(expression);\n                    }\n                }\n                // Also check the template expression itself\n                check();\n                return;\n            }\n            case ts.SyntaxKind.CallExpression:\n            case ts.SyntaxKind.NewExpression: {\n                var _e = node, expression = _e.expression, args = _e.arguments;\n                cb(expression);\n                for (var _f = 0, args_1 = args; _f < args_1.length; _f++) {\n                    var arg = args_1[_f];\n                    checkContextual(arg);\n                }\n                // Also check the call expression itself\n                check();\n                return;\n            }\n            case ts.SyntaxKind.PropertyAccessExpression:\n                // Don't warn for right hand side; this is redundant if we warn for the access itself.\n                cb(node.expression);\n                check();\n                return;\n            case ts.SyntaxKind.VariableDeclaration:\n                return checkVariableDeclaration(node);\n            case ts.SyntaxKind.BinaryExpression:\n                return checkBinaryExpression(node);\n            case ts.SyntaxKind.ReturnStatement: {\n                var expression = node.expression;\n                if (expression) {\n                    return checkContextual(expression);\n                }\n                return;\n            }\n            default:\n                if (!(ts.isExpression(node) && check())) {\n                    return ts.forEachChild(node, cb);\n                }\n                return;\n        }\n        function check() {\n            var isUnsafe = !anyOk && isNodeAny(node, checker);\n            if (isUnsafe) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n            return isUnsafe;\n        }\n    }\n    /** OK for this value to be 'any' if that's its contextual type. */\n    function checkContextual(arg) {\n        return cb(arg, /*anyOk*/ isAny(checker.getContextualType(arg)));\n    }\n    // Allow `const x = foo;` and `const x: any = foo`, but not `const x: Foo = foo;`.\n    function checkVariableDeclaration(_a) {\n        var type = _a.type, initializer = _a.initializer;\n        // Always allow the LHS to be `any`. Just don't allow RHS to be `any` when LHS isn't.\n        // TODO: handle destructuring\n        if (initializer !== undefined) {\n            return cb(initializer, /*anyOk*/ type === undefined || type.kind === ts.SyntaxKind.AnyKeyword);\n        }\n        return;\n    }\n    function checkBinaryExpression(node) {\n        var _a = node, left = _a.left, right = _a.right, operatorToken = _a.operatorToken;\n        // Allow equality since all values support equality.\n        if (Lint.getEqualsKind(operatorToken) !== undefined) {\n            return;\n        }\n        switch (operatorToken.kind) {\n            case ts.SyntaxKind.InstanceOfKeyword:\n                return cb(right);\n            case ts.SyntaxKind.CommaToken:\n                cb(left, /*anyOk*/ true);\n                return cb(right, /*anyOk*/ true);\n            case ts.SyntaxKind.EqualsToken:\n                // Allow assignment if the lhs is also *any*.\n                // TODO: handle destructuring\n                cb(right, /*anyOk*/ isNodeAny(left, checker));\n                return;\n            case ts.SyntaxKind.PlusToken: // Allow implicit stringification\n            case ts.SyntaxKind.PlusEqualsToken:\n                var anyOk = isStringLike(left, checker)\n                    || (isStringLike(right, checker) && operatorToken.kind === ts.SyntaxKind.PlusToken);\n                cb(left, anyOk);\n                return cb(right, anyOk);\n            default:\n                cb(left);\n                return cb(right);\n        }\n    }\n}\nfunction isNodeAny(node, checker) {\n    return isAny(checker.getTypeAtLocation(node));\n}\nfunction isStringLike(expr, checker) {\n    return Lint.isTypeFlagSet(checker.getTypeAtLocation(expr), ts.TypeFlags.StringLike);\n}\nfunction isAny(type) {\n    return type !== undefined && Lint.isTypeFlagSet(type, ts.TypeFlags.Any);\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnsafeFinallyRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoReturnInFinallyScopeAwareWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unsafe-finally\",\n    description: (_a = [\"\\n            Disallows control flow statements, such as `return`, `continue`,\\n            `break` and `throws` in finally blocks.\"], _a.raw = [\"\\n            Disallows control flow statements, such as \\\\`return\\\\`, \\\\`continue\\\\`,\\n            \\\\`break\\\\` and \\\\`throws\\\\` in finally blocks.\"], Lint.Utils.dedent(_a)),\n    descriptionDetails: \"\",\n    rationale: (_b = [\"\\n            When used inside `finally` blocks, control flow statements,\\n            such as `return`, `continue`, `break` and `throws`\\n            override any other control flow statements in the same try/catch scope.\\n            This is confusing and unexpected behavior.\"], _b.raw = [\"\\n            When used inside \\\\`finally\\\\` blocks, control flow statements,\\n            such as \\\\`return\\\\`, \\\\`continue\\\\`, \\\\`break\\\\` and \\\\`throws\\\\`\\n            override any other control flow statements in the same try/catch scope.\\n            This is confusing and unexpected behavior.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_TYPE_BREAK = \"break\";\nRule.FAILURE_TYPE_CONTINUE = \"continue\";\nRule.FAILURE_TYPE_RETURN = \"return\";\nRule.FAILURE_TYPE_THROW = \"throw\";\nRule.FAILURE_STRING_FACTORY = function (name) {\n    return name + \" statements in finally blocks are forbidden.\";\n};\nexports.Rule = Rule;\n/**\n * Represents a block walker that identifies finally blocks and walks\n * only the blocks that do not change scope for return statements.\n */\nvar NoReturnInFinallyScopeAwareWalker = (function (_super) {\n    __extends(NoReturnInFinallyScopeAwareWalker, _super);\n    function NoReturnInFinallyScopeAwareWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoReturnInFinallyScopeAwareWalker.prototype.visitBreakStatement = function (node) {\n        if (!this.isControlFlowWithinFinallyBlock(isBreakBoundary, node)) {\n            _super.prototype.visitBreakStatement.call(this, node);\n            return;\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING_FACTORY(Rule.FAILURE_TYPE_BREAK));\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.visitContinueStatement = function (node) {\n        if (!this.isControlFlowWithinFinallyBlock(isContinueBoundary, node)) {\n            _super.prototype.visitContinueStatement.call(this, node);\n            return;\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING_FACTORY(Rule.FAILURE_TYPE_CONTINUE));\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.visitLabeledStatement = function (node) {\n        this.getCurrentScope().labels.push(node.label.text);\n        _super.prototype.visitLabeledStatement.call(this, node);\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.visitReturnStatement = function (node) {\n        if (!this.isControlFlowWithinFinallyBlock(isReturnsOrThrowsBoundary)) {\n            _super.prototype.visitReturnStatement.call(this, node);\n            return;\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING_FACTORY(Rule.FAILURE_TYPE_RETURN));\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.visitThrowStatement = function (node) {\n        if (!this.isControlFlowWithinFinallyBlock(isReturnsOrThrowsBoundary)) {\n            _super.prototype.visitThrowStatement.call(this, node);\n            return;\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING_FACTORY(Rule.FAILURE_TYPE_THROW));\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.createScope = function (node) {\n        var isScopeBoundary = _super.prototype.isScopeBoundary.call(this, node);\n        return {\n            isBreakBoundary: isScopeBoundary || isLoopBlock(node) || isCaseBlock(node),\n            isContinueBoundary: isScopeBoundary || isLoopBlock(node),\n            isFinallyBlock: isFinallyBlock(node),\n            isReturnsThrowsBoundary: isScopeBoundary,\n            labels: [],\n        };\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.isScopeBoundary = function (node) {\n        return _super.prototype.isScopeBoundary.call(this, node) ||\n            isFinallyBlock(node) ||\n            isLoopBlock(node) ||\n            isCaseBlock(node);\n    };\n    NoReturnInFinallyScopeAwareWalker.prototype.isControlFlowWithinFinallyBlock = function (isControlFlowBoundary, node) {\n        var scopes = this.getAllScopes();\n        var currentScope = this.getCurrentScope();\n        var depth = this.getCurrentDepth();\n        while (currentScope) {\n            if (isControlFlowBoundary(currentScope, node)) {\n                return false;\n            }\n            if (currentScope.isFinallyBlock) {\n                return true;\n            }\n            currentScope = scopes[--depth];\n        }\n        return false;\n    };\n    return NoReturnInFinallyScopeAwareWalker;\n}(Lint.ScopeAwareRuleWalker));\nfunction isLoopBlock(node) {\n    var parent = node.parent;\n    return parent !== undefined &&\n        node.kind === ts.SyntaxKind.Block &&\n        (parent.kind === ts.SyntaxKind.ForInStatement ||\n            parent.kind === ts.SyntaxKind.ForOfStatement ||\n            parent.kind === ts.SyntaxKind.ForStatement ||\n            parent.kind === ts.SyntaxKind.WhileStatement ||\n            parent.kind === ts.SyntaxKind.DoStatement);\n}\nfunction isCaseBlock(node) {\n    return node.kind === ts.SyntaxKind.CaseBlock;\n}\nfunction isFinallyBlock(node) {\n    var parent = node.parent;\n    return parent !== undefined &&\n        node.kind === ts.SyntaxKind.Block &&\n        utils.isTryStatement(parent) &&\n        parent.finallyBlock === node;\n}\nfunction isReturnsOrThrowsBoundary(scope) {\n    return scope.isReturnsThrowsBoundary;\n}\nfunction isContinueBoundary(scope, node) {\n    return node.label ? scope.labels.indexOf(node.label.text) >= 0 : scope.isContinueBoundary;\n}\nfunction isBreakBoundary(scope, node) {\n    return node.label ? scope.labels.indexOf(node.label.text) >= 0 : scope.isBreakBoundary;\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnusedExpressionRule.js":"/**\n * @license\n * Copyright 2014 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../language/utils\");\nvar ALLOW_FAST_NULL_CHECKS = \"allow-fast-null-checks\";\nvar ALLOW_NEW = \"allow-new\";\nvar ALLOW_TAGGED_TEMPLATE = \"allow-tagged-template\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoUnusedExpressionWalker(sourceFile, this.ruleName, {\n            allowFastNullChecks: this.ruleArguments.indexOf(ALLOW_FAST_NULL_CHECKS) !== -1,\n            allowNew: this.ruleArguments.indexOf(ALLOW_NEW) !== -1,\n            allowTaggedTemplate: this.ruleArguments.indexOf(ALLOW_TAGGED_TEMPLATE) !== -1,\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unused-expression\",\n    description: \"Disallows unused expression statements.\",\n    descriptionDetails: (_a = [\"\\n            Unused expressions are expression statements which are not assignments or function calls\\n            (and thus usually no-ops).\"], _a.raw = [\"\\n            Unused expressions are expression statements which are not assignments or function calls\\n            (and thus usually no-ops).\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            Detects potential errors where an assignment or function call was intended.\"], _b.raw = [\"\\n            Detects potential errors where an assignment or function call was intended.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: (_c = [\"\\n            Two arguments may be optionally provided:\\n\\n            * `\", \"` allows to use logical operators to perform fast null checks and perform\\n            method or function calls for side effects (e.g. `e && e.preventDefault()`).\\n            * `\", \"` allows 'new' expressions for side effects (e.g. `new ModifyGlobalState();`.\\n            * `\", \"` allows tagged templates for side effects (e.g. `this.add\\\\`foo\\\\`;`.\"], _c.raw = [\"\\n            Two arguments may be optionally provided:\\n\\n            * \\\\`\", \"\\\\` allows to use logical operators to perform fast null checks and perform\\n            method or function calls for side effects (e.g. \\\\`e && e.preventDefault()\\\\`).\\n            * \\\\`\", \"\\\\` allows 'new' expressions for side effects (e.g. \\\\`new ModifyGlobalState();\\\\`.\\n            * \\\\`\", \"\\\\` allows tagged templates for side effects (e.g. \\\\`this.add\\\\\\\\\\\\`foo\\\\\\\\\\\\`;\\\\`.\"], Lint.Utils.dedent(_c, ALLOW_FAST_NULL_CHECKS, ALLOW_NEW, ALLOW_TAGGED_TEMPLATE)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [ALLOW_FAST_NULL_CHECKS],\n        },\n        minLength: 0,\n        maxLength: 1,\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + ALLOW_FAST_NULL_CHECKS + \"\\\"]\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"unused expression, expected an assignment or function call\";\nexports.Rule = Rule;\nvar NoUnusedExpressionWalker = (function (_super) {\n    __extends(NoUnusedExpressionWalker, _super);\n    function NoUnusedExpressionWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoUnusedExpressionWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (tsutils_1.isExpressionStatement(node)) {\n                if (!isDirective(node) && _this.isUnusedExpression(node.expression)) {\n                    _this.reportFailure(node);\n                }\n            }\n            else if (tsutils_1.isVoidExpression(node)) {\n                // allow `void 0`\n                if (!isLiteralZero(node.expression) && _this.isUnusedExpression(node.expression)) {\n                    _this.reportFailure(node.expression);\n                }\n            }\n            else if (tsutils_1.isBinaryExpression(node)) {\n                if (node.operatorToken.kind === ts.SyntaxKind.CommaToken) {\n                    // allow indirect eval: `(0, eval)(\"code\");`\n                    if (!isIndirectEval(node) && _this.isUnusedExpression(node.left)) {\n                        _this.reportFailure(node.left);\n                    }\n                }\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    NoUnusedExpressionWalker.prototype.reportFailure = function (node) {\n        var start = node.getStart(this.sourceFile);\n        var end = node.end;\n        // don't add a new failure if it is contained in another failure's span\n        for (var _i = 0, _a = this.failures; _i < _a.length; _i++) {\n            var failure = _a[_i];\n            if (failure.getStartPosition().getPosition() <= start &&\n                failure.getEndPosition().getPosition() >= end) {\n                return;\n            }\n        }\n        this.addFailure(start, end, Rule.FAILURE_STRING);\n    };\n    NoUnusedExpressionWalker.prototype.isUnusedExpression = function (expression) {\n        expression = utils_1.unwrapParentheses(expression);\n        switch (expression.kind) {\n            case ts.SyntaxKind.CallExpression:\n            case ts.SyntaxKind.YieldExpression:\n            case ts.SyntaxKind.DeleteExpression:\n            case ts.SyntaxKind.AwaitExpression:\n            case ts.SyntaxKind.PostfixUnaryExpression:\n                return false;\n            case ts.SyntaxKind.NewExpression:\n                return !this.options.allowNew;\n            case ts.SyntaxKind.TaggedTemplateExpression:\n                return !this.options.allowTaggedTemplate;\n            default:\n        }\n        if (tsutils_1.isPrefixUnaryExpression(expression) &&\n            (expression.operator === ts.SyntaxKind.PlusPlusToken || expression.operator === ts.SyntaxKind.MinusMinusToken)) {\n            return false;\n        }\n        if (tsutils_1.isConditionalExpression(expression)) {\n            return this.isUnusedExpression(expression.whenTrue) || this.isUnusedExpression(expression.whenFalse);\n        }\n        if (tsutils_1.isBinaryExpression(expression)) {\n            var operatorKind = expression.operatorToken.kind;\n            if (tsutils_1.isAssignmentKind(operatorKind)) {\n                return false;\n            }\n            if (this.options.allowFastNullChecks &&\n                (operatorKind === ts.SyntaxKind.AmpersandAmpersandToken || operatorKind === ts.SyntaxKind.BarBarToken)) {\n                return this.isUnusedExpression(expression.right);\n            }\n            else if (operatorKind === ts.SyntaxKind.CommaToken) {\n                return this.isUnusedExpression(expression.left) || this.isUnusedExpression(expression.right);\n            }\n        }\n        return true;\n    };\n    return NoUnusedExpressionWalker;\n}(Lint.AbstractWalker));\nfunction isLiteralZero(node) {\n    return tsutils_1.isNumericLiteral(node) && node.text === \"0\";\n}\nfunction isIndirectEval(node) {\n    return tsutils_1.isIdentifier(node.right) && node.right.text === \"eval\" &&\n        isLiteralZero(node.left) &&\n        node.parent.kind === ts.SyntaxKind.ParenthesizedExpression &&\n        node.parent.parent.kind === ts.SyntaxKind.CallExpression;\n}\nfunction isDirective(node) {\n    if (node.expression.kind !== ts.SyntaxKind.StringLiteral || !canContainDirective(node.parent)) {\n        return false;\n    }\n    var parent = node.parent;\n    // check if all previous statements in block are also directives\n    for (var i = parent.statements.indexOf(node) - 1; i >= 0; --i) {\n        var statement = parent.statements[i];\n        if (!tsutils_1.isExpressionStatement(statement) || statement.expression.kind !== ts.SyntaxKind.StringLiteral) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canContainDirective(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.SourceFile:\n        case ts.SyntaxKind.ModuleBlock:\n            return true;\n        case ts.SyntaxKind.Block:\n            switch (node.parent.kind) {\n                case ts.SyntaxKind.ArrowFunction:\n                case ts.SyntaxKind.FunctionExpression:\n                case ts.SyntaxKind.FunctionDeclaration:\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.Constructor:\n                case ts.SyntaxKind.GetAccessor:\n                case ts.SyntaxKind.SetAccessor:\n                    return true;\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar _a, _b, _c;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnusedVariableRule.js":"/**\n * @license\n * Copyright 2014 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_CHECK_PARAMETERS = \"check-parameters\";\nvar OPTION_IGNORE_PATTERN = \"ignore-pattern\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var _this = this;\n        var x = program.getCompilerOptions();\n        if (x.noUnusedLocals && x.noUnusedParameters) {\n            console.warn(\"WARNING: 'no-unused-variable' lint rule does not need to be set if \" +\n                \"the 'no-unused-locals' and 'no-unused-parameters' compiler options are enabled.\");\n        }\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program, parseOptions(_this.ruleArguments)); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unused-variable\",\n    description: (_a = [\"Disallows unused imports, variables, functions and\\n            private class members. Similar to tsc's --noUnusedParameters and --noUnusedLocals\\n            options, but does not interrupt code compilation.\"], _a.raw = [\"Disallows unused imports, variables, functions and\\n            private class members. Similar to tsc's --noUnusedParameters and --noUnusedLocals\\n            options, but does not interrupt code compilation.\"], Lint.Utils.dedent(_a)),\n    hasFix: true,\n    optionsDescription: (_b = [\"\\n            Three optional arguments may be optionally provided:\\n\\n            * `\\\"check-parameters\\\"` disallows unused function and constructor parameters.\\n                * NOTE: this option is experimental and does not work with classes\\n                that use abstract method declarations, among other things.\\n            * `{\\\"ignore-pattern\\\": \\\"pattern\\\"}` where pattern is a case-sensitive regexp.\\n            Variable names that match the pattern will be ignored.\"], _b.raw = [\"\\n            Three optional arguments may be optionally provided:\\n\\n            * \\\\`\\\"check-parameters\\\"\\\\` disallows unused function and constructor parameters.\\n                * NOTE: this option is experimental and does not work with classes\\n                that use abstract method declarations, among other things.\\n            * \\\\`{\\\"ignore-pattern\\\": \\\"pattern\\\"}\\\\` where pattern is a case-sensitive regexp.\\n            Variable names that match the pattern will be ignored.\"], Lint.Utils.dedent(_b)),\n    options: {\n        type: \"array\",\n        items: {\n            oneOf: [{\n                    type: \"string\",\n                    enum: [\"check-parameters\"],\n                }, {\n                    type: \"object\",\n                    properties: {\n                        \"ignore-pattern\": { type: \"string\" },\n                    },\n                    additionalProperties: false,\n                }],\n        },\n        minLength: 0,\n        maxLength: 3,\n    },\n    optionExamples: [\"[true]\", '[true, {\"ignore-pattern\": \"^_\"}]'],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\nexports.Rule = Rule;\nfunction parseOptions(options) {\n    var checkParameters = options.indexOf(OPTION_CHECK_PARAMETERS) !== -1;\n    var ignorePattern;\n    for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {\n        var o = options_1[_i];\n        if (typeof o === \"object\" && o[OPTION_IGNORE_PATTERN] != null) {\n            ignorePattern = new RegExp(o[OPTION_IGNORE_PATTERN]);\n            break;\n        }\n    }\n    return { checkParameters: checkParameters, ignorePattern: ignorePattern };\n}\nfunction walk(ctx, program, _a) {\n    var checkParameters = _a.checkParameters, ignorePattern = _a.ignorePattern;\n    var sourceFile = ctx.sourceFile;\n    var unusedCheckedProgram = getUnusedCheckedProgram(program, checkParameters);\n    var diagnostics = ts.getPreEmitDiagnostics(unusedCheckedProgram, sourceFile);\n    var checker = unusedCheckedProgram.getTypeChecker(); // Doesn't matter which program is used for this.\n    // If all specifiers in an import are unused, we elide the entire import.\n    var importSpecifierFailures = new Map();\n    for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {\n        var diag = diagnostics_1[_i];\n        var kind = getUnusedDiagnostic(diag);\n        if (kind === undefined) {\n            continue;\n        }\n        var failure = ts.flattenDiagnosticMessageText(diag.messageText, \"\\n\");\n        if (kind === 0 /* VARIABLE_OR_PARAMETER */) {\n            var importName = findImport(diag.start, sourceFile);\n            if (importName !== undefined) {\n                if (isImportUsed(importName, sourceFile, checker)) {\n                    continue;\n                }\n                if (importSpecifierFailures.has(importName)) {\n                    throw new Error(\"Should not get 2 errors for the same import.\");\n                }\n                importSpecifierFailures.set(importName, failure);\n                continue;\n            }\n        }\n        if (ignorePattern) {\n            var varName = /'(.*)'/.exec(failure)[1];\n            if (ignorePattern.test(varName)) {\n                continue;\n            }\n        }\n        ctx.addFailureAt(diag.start, diag.length, failure);\n    }\n    if (importSpecifierFailures.size) {\n        addImportSpecifierFailures(ctx, importSpecifierFailures, sourceFile);\n    }\n}\n/**\n * Handle import-specifier failures separately.\n * - If all of the import specifiers in an import are unused, add a combined failure for them all.\n * - Unused imports are fixable.\n */\nfunction addImportSpecifierFailures(ctx, failures, sourceFile) {\n    forEachImport(sourceFile, function (importNode) {\n        if (importNode.kind === ts.SyntaxKind.ImportEqualsDeclaration) {\n            tryRemoveAll(importNode.name);\n            return;\n        }\n        if (!importNode.importClause) {\n            // Error node\n            return;\n        }\n        var _a = importNode.importClause, defaultName = _a.name, namedBindings = _a.namedBindings;\n        if (namedBindings && namedBindings.kind === ts.SyntaxKind.NamespaceImport) {\n            tryRemoveAll(namedBindings.name);\n            return;\n        }\n        var allNamedBindingsAreFailures = !namedBindings || namedBindings.elements.every(function (e) { return failures.has(e.name); });\n        if (namedBindings && allNamedBindingsAreFailures) {\n            for (var _i = 0, _b = namedBindings.elements; _i < _b.length; _i++) {\n                var e = _b[_i];\n                failures.delete(e.name);\n            }\n        }\n        if ((!defaultName || failures.has(defaultName)) && allNamedBindingsAreFailures) {\n            if (defaultName) {\n                failures.delete(defaultName);\n            }\n            removeAll(importNode, \"All imports are unused.\");\n            return;\n        }\n        if (defaultName) {\n            var failure = tryDelete(defaultName);\n            if (failure !== undefined) {\n                var start = defaultName.getStart();\n                var end = namedBindings ? namedBindings.getStart() : importNode.moduleSpecifier.getStart();\n                var fix = Lint.Replacement.deleteFromTo(start, end);\n                ctx.addFailureAtNode(defaultName, failure, fix);\n            }\n        }\n        if (namedBindings) {\n            if (allNamedBindingsAreFailures) {\n                var start = defaultName ? defaultName.getEnd() : namedBindings.getStart();\n                var fix = Lint.Replacement.deleteFromTo(start, namedBindings.getEnd());\n                var failure = \"All named bindings are unused.\";\n                ctx.addFailureAtNode(namedBindings, failure, fix);\n            }\n            else {\n                var elements = namedBindings.elements;\n                for (var i = 0; i < elements.length; i++) {\n                    var element = elements[i];\n                    var failure = tryDelete(element.name);\n                    if (failure === undefined) {\n                        continue;\n                    }\n                    var prevElement = elements[i - 1];\n                    var nextElement = elements[i + 1];\n                    var start = prevElement ? prevElement.getEnd() : element.getStart();\n                    var end = nextElement && !prevElement ? nextElement.getStart() : element.getEnd();\n                    var fix = Lint.Replacement.deleteFromTo(start, end);\n                    ctx.addFailureAtNode(element.name, failure, fix);\n                }\n            }\n        }\n        function tryRemoveAll(name) {\n            var failure = tryDelete(name);\n            if (failure !== undefined) {\n                removeAll(name, failure);\n            }\n        }\n        function removeAll(errorNode, failure) {\n            var fix = Lint.Replacement.deleteFromTo(importNode.getStart(), importNode.getEnd());\n            ctx.addFailureAtNode(errorNode, failure, fix);\n        }\n    });\n    if (failures.size) {\n        throw new Error(\"Should have revisited all import specifier failures.\");\n    }\n    function tryDelete(name) {\n        var failure = failures.get(name);\n        if (failure !== undefined) {\n            failures.delete(name);\n            return failure;\n        }\n        return undefined;\n    }\n}\n/**\n * Ignore this import if it's used as an implicit type somewhere.\n * Workround for https://github.com/Microsoft/TypeScript/issues/9944\n */\nfunction isImportUsed(importSpecifier, sourceFile, checker) {\n    var symbol = checker.getSymbolAtLocation(importSpecifier);\n    if (!symbol) {\n        return false;\n    }\n    symbol = checker.getAliasedSymbol(symbol);\n    if (!Lint.isSymbolFlagSet(symbol, ts.SymbolFlags.Type)) {\n        return false;\n    }\n    return ts.forEachChild(sourceFile, function cb(child) {\n        if (isImportLike(child)) {\n            return false;\n        }\n        var type = getImplicitType(child, checker);\n        // TODO: checker.typeEquals https://github.com/Microsoft/TypeScript/issues/13502\n        if (type && checker.typeToString(type) === checker.symbolToString(symbol)) {\n            return true;\n        }\n        return ts.forEachChild(child, cb);\n    });\n}\nfunction getImplicitType(node, checker) {\n    if ((utils.isPropertyDeclaration(node) || utils.isVariableDeclaration(node)) && !node.type) {\n        return checker.getTypeAtLocation(node);\n    }\n    else if (utils.isSignatureDeclaration(node) && !node.type) {\n        return checker.getSignatureFromDeclaration(node).getReturnType();\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isImportLike(node) {\n    return node.kind === ts.SyntaxKind.ImportDeclaration || node.kind === ts.SyntaxKind.ImportEqualsDeclaration;\n}\nfunction forEachImport(sourceFile, f) {\n    return ts.forEachChild(sourceFile, function (child) {\n        if (isImportLike(child)) {\n            var res = f(child);\n            if (res !== undefined) {\n                return res;\n            }\n        }\n        return undefined;\n    });\n}\nfunction findImport(pos, sourceFile) {\n    return forEachImport(sourceFile, function (i) {\n        if (i.kind === ts.SyntaxKind.ImportEqualsDeclaration) {\n            if (i.name.getStart() === pos) {\n                return i.name;\n            }\n        }\n        else {\n            if (!i.importClause) {\n                // Error node\n                return undefined;\n            }\n            var _a = i.importClause, defaultName = _a.name, namedBindings = _a.namedBindings;\n            if (namedBindings && namedBindings.kind === ts.SyntaxKind.NamespaceImport) {\n                var name = namedBindings.name;\n                if (name.getStart() === pos) {\n                    return name;\n                }\n                return undefined;\n            }\n            if (defaultName && defaultName.getStart() === pos) {\n                return defaultName;\n            }\n            else if (namedBindings) {\n                for (var _i = 0, _b = namedBindings.elements; _i < _b.length; _i++) {\n                    var name = _b[_i].name;\n                    if (name.getStart() === pos) {\n                        return name;\n                    }\n                }\n            }\n        }\n        return undefined;\n    });\n}\nfunction getUnusedDiagnostic(diag) {\n    switch (diag.code) {\n        case 6133:\n            return 0 /* VARIABLE_OR_PARAMETER */; // \"'{0}' is declared but never used.\n        case 6138:\n            return 1 /* PROPERTY */; // \"Property '{0}' is declared but never used.\"\n        default:\n            return undefined;\n    }\n}\nvar programToUnusedCheckedProgram = new WeakMap();\nfunction getUnusedCheckedProgram(program, checkParameters) {\n    // Assuming checkParameters will always have the same value, so only lookup by program.\n    var checkedProgram = programToUnusedCheckedProgram.get(program);\n    if (checkedProgram) {\n        return checkedProgram;\n    }\n    checkedProgram = makeUnusedCheckedProgram(program, checkParameters);\n    programToUnusedCheckedProgram.set(program, checkedProgram);\n    return checkedProgram;\n}\nfunction makeUnusedCheckedProgram(program, checkParameters) {\n    var options = __assign({}, program.getCompilerOptions(), { noUnusedLocals: true }, (checkParameters ? { noUnusedParameters: true } : null));\n    var sourceFilesByName = new Map(program.getSourceFiles().map(function (s) { return [s.fileName, s]; }));\n    // tslint:disable object-literal-sort-keys\n    return ts.createProgram(Array.from(sourceFilesByName.keys()), options, {\n        fileExists: function (f) { return sourceFilesByName.has(f); },\n        readFile: function (f) {\n            var s = sourceFilesByName.get(f);\n            return s.text;\n        },\n        getSourceFile: function (f) { return sourceFilesByName.get(f); },\n        getDefaultLibFileName: function () { return ts.getDefaultLibFileName(options); },\n        writeFile: function () { },\n        getCurrentDirectory: function () { return \"\"; },\n        getDirectories: function () { return []; },\n        getCanonicalFileName: function (f) { return f; },\n        useCaseSensitiveFileNames: function () { return true; },\n        getNewLine: function () { return \"\\n\"; },\n    });\n    // tslint:enable object-literal-sort-keys\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUseBeforeDeclareRule.js":"/**\n * @license\n * Copyright 2014 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (name) {\n        return \"variable '\" + name + \"' used before declaration\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-use-before-declare\",\n    description: \"Disallows usage of variables before their declaration.\",\n    descriptionDetails: (_a = [\"\\n            This rule is primarily useful when using the `var` keyword -\\n            the compiler will detect if a `let` and `const` variable is used before it is declared.\"], _a.raw = [\"\\n            This rule is primarily useful when using the \\\\`var\\\\` keyword -\\n            the compiler will detect if a \\\\`let\\\\` and \\\\`const\\\\` variable is used before it is declared.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n    requiresTypeInfo: true,\n};\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    return ts.forEachChild(ctx.sourceFile, function recur(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.TypeReference:\n                // Ignore types.\n                return;\n            case ts.SyntaxKind.PropertyAccessExpression:\n                // Ignore `y` in `x.y`, but recurse to `x`.\n                return recur(node.expression);\n            case ts.SyntaxKind.Identifier:\n                return checkIdentifier(node, checker.getSymbolAtLocation(node));\n            case ts.SyntaxKind.ExportSpecifier:\n                return checkIdentifier(node.name, checker.getExportSpecifierLocalTargetSymbol(node));\n            default:\n                return ts.forEachChild(node, recur);\n        }\n    });\n    function checkIdentifier(node, symbol) {\n        var declarations = symbol && symbol.declarations;\n        if (declarations === undefined || declarations.length === 0) {\n            return;\n        }\n        var declaredBefore = declarations.some(function (decl) {\n            switch (decl.kind) {\n                case ts.SyntaxKind.FunctionDeclaration:\n                    // Functions may be declared later.\n                    return true;\n                default:\n                    // Use `<=` in case this *is* the declaration.\n                    // If it's a global declared in a different file, OK.\n                    return decl.pos <= node.pos || decl.getSourceFile() !== ctx.sourceFile;\n            }\n        });\n        if (!declaredBefore) {\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING(node.text));\n        }\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noVarKeywordRule.js":"/**\n * @license\n * Copyright 2015 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var noVarKeywordWalker = new NoVarKeywordWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(noVarKeywordWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-var-keyword\",\n    description: \"Disallows usage of the `var` keyword.\",\n    descriptionDetails: \"Use `let` or `const` instead.\",\n    hasFix: true,\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Forbidden 'var' keyword, use 'let' or 'const' instead\";\nexports.Rule = Rule;\nvar NoVarKeywordWalker = (function (_super) {\n    __extends(NoVarKeywordWalker, _super);\n    function NoVarKeywordWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoVarKeywordWalker.prototype.visitVariableStatement = function (node) {\n        if (!Lint.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword)\n            && !Lint.isBlockScopedVariable(node)) {\n            this.reportFailure(node.declarationList);\n        }\n        _super.prototype.visitVariableStatement.call(this, node);\n    };\n    NoVarKeywordWalker.prototype.visitForStatement = function (node) {\n        this.handleInitializerNode(node.initializer);\n        _super.prototype.visitForStatement.call(this, node);\n    };\n    NoVarKeywordWalker.prototype.visitForInStatement = function (node) {\n        this.handleInitializerNode(node.initializer);\n        _super.prototype.visitForInStatement.call(this, node);\n    };\n    NoVarKeywordWalker.prototype.visitForOfStatement = function (node) {\n        this.handleInitializerNode(node.initializer);\n        _super.prototype.visitForOfStatement.call(this, node);\n    };\n    NoVarKeywordWalker.prototype.handleInitializerNode = function (node) {\n        if (node && node.kind === ts.SyntaxKind.VariableDeclarationList &&\n            !(Lint.isNodeFlagSet(node, ts.NodeFlags.Let) || Lint.isNodeFlagSet(node, ts.NodeFlags.Const))) {\n            this.reportFailure(node);\n        }\n    };\n    NoVarKeywordWalker.prototype.reportFailure = function (node) {\n        var nodeStart = node.getStart(this.getSourceFile());\n        this.addFailureAt(nodeStart, \"var\".length, Rule.FAILURE_STRING, this.createReplacement(nodeStart, \"var\".length, \"let\"));\n    };\n    return NoVarKeywordWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noVoidExpressionRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../language/utils\");\nvar OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND = \"ignore-arrow-function-shorthand\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var ignoreArrowFunctionShorthand = this.ruleArguments.indexOf(OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND) !== -1;\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); }, { ignoreArrowFunctionShorthand: ignoreArrowFunctionShorthand });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-void-expression\",\n    description: \"Requires expressions of type `void` to appear in statement position.\",\n    optionsDescription: (_a = [\"\\n            If `\", \"` is provided, `() => returnsVoid()` will be allowed.\\n            Otherwise, it must be written as `() => { returnsVoid(); }`.\"], _a.raw = [\"\\n            If \\\\`\", \"\\\\` is provided, \\\\`() => returnsVoid()\\\\` will be allowed.\\n            Otherwise, it must be written as \\\\`() => { returnsVoid(); }\\\\`.\"], Lint.Utils.dedent(_a, OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND],\n        },\n        minLength: 0,\n        maxLength: 1,\n    },\n    requiresTypeInfo: true,\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Expression has type `void`. Put it on its own line as a statement.\";\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    var sourceFile = ctx.sourceFile, ignoreArrowFunctionShorthand = ctx.options.ignoreArrowFunctionShorthand;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        if (isPossiblyVoidExpression(node)\n            && !isParentAllowedVoid(node)\n            && utils_1.isTypeFlagSet(checker.getTypeAtLocation(node), ts.TypeFlags.Void)) {\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function isParentAllowedVoid(node) {\n        switch (node.parent.kind) {\n            case ts.SyntaxKind.ExpressionStatement:\n                return true;\n            case ts.SyntaxKind.ArrowFunction:\n                return ignoreArrowFunctionShorthand;\n            default:\n                return false;\n        }\n    }\n}\nfunction isPossiblyVoidExpression(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.AwaitExpression:\n        case ts.SyntaxKind.CallExpression:\n        case ts.SyntaxKind.TaggedTemplateExpression:\n            return true;\n        default:\n            return false;\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/radixRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"radix\",\n    description: \"Requires the radix parameter to be specified when calling `parseInt`.\",\n    rationale: (_a = [\"\\n            From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt):\\n            > Always specify this parameter to eliminate reader confusion and to guarantee predictable behavior.\\n            > Different implementations produce different results when a radix is not specified, usually defaulting the value to 10.\"], _a.raw = [\"\\n            From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt):\\n            > Always specify this parameter to eliminate reader confusion and to guarantee predictable behavior.\\n            > Different implementations produce different results when a radix is not specified, usually defaulting the value to 10.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Missing radix parameter\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isCallExpression(node) && node.arguments.length === 1 &&\n            (\n            // parseInt(\"123\")\n            tsutils_1.isIdentifier(node.expression) && node.expression.text === \"parseInt\" ||\n                // window.parseInt(\"123\") || global.parseInt(\"123\")\n                tsutils_1.isPropertyAccessExpression(node.expression) &&\n                    node.expression.name.text === \"parseInt\" &&\n                    tsutils_1.isIdentifier(node.expression.expression) &&\n                    (node.expression.expression.text === \"global\" ||\n                        node.expression.expression.text === \"window\"))) {\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/restrictPlusOperandsRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"restrict-plus-operands\",\n    description: \"When adding two variables, operands must both be of type number or of type string.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.INVALID_TYPES_ERROR = \"Operands of '+' operation must either be both strings or both numbers\";\nexports.Rule = Rule;\nfunction walk(ctx, program) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.PlusToken) {\n            var tc = program.getTypeChecker();\n            var leftType = getBaseTypeOfLiteralType(tc.getTypeAtLocation(node.left));\n            var rightType = getBaseTypeOfLiteralType(tc.getTypeAtLocation(node.right));\n            if (leftType === \"invalid\" || rightType === \"invalid\" || leftType !== rightType) {\n                return ctx.addFailureAtNode(node, Rule.INVALID_TYPES_ERROR);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction getBaseTypeOfLiteralType(type) {\n    if (Lint.isTypeFlagSet(type, ts.TypeFlags.StringLiteral) || Lint.isTypeFlagSet(type, ts.TypeFlags.String)) {\n        return \"string\";\n    }\n    else if (Lint.isTypeFlagSet(type, ts.TypeFlags.NumberLiteral) || Lint.isTypeFlagSet(type, ts.TypeFlags.Number)) {\n        return \"number\";\n    }\n    else if (isUnionType(type) && !Lint.isTypeFlagSet(type, ts.TypeFlags.Enum)) {\n        var types = type.types.map(getBaseTypeOfLiteralType);\n        return allSame(types) ? types[0] : \"invalid\";\n    }\n    else if (Lint.isTypeFlagSet(type, ts.TypeFlags.EnumLiteral)) {\n        return getBaseTypeOfLiteralType(type.baseType);\n    }\n    return \"invalid\";\n}\nfunction allSame(array) {\n    return array.every(function (value) { return value === array[0]; });\n}\nfunction isUnionType(type) {\n    return Lint.isTypeFlagSet(type, ts.TypeFlags.Union);\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/strictBooleanExpressionsRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_NULL_UNION = \"allow-null-union\";\nvar OPTION_ALLOW_UNDEFINED_UNION = \"allow-undefined-union\";\nvar OPTION_ALLOW_STRING = \"allow-string\";\nvar OPTION_ALLOW_NUMBER = \"allow-number\";\nvar OPTION_ALLOW_MIX = \"allow-mix\";\n// tslint:disable object-literal-sort-keys switch-default\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var strictNullChecks = !!program.getCompilerOptions().strictNullChecks;\n        var options = parseOptions(this.ruleArguments, strictNullChecks);\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); }, options);\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\nRule.metadata = {\n    ruleName: \"strict-boolean-expressions\",\n    description: (_a = [\"\\n            Restricts the types allowed in boolean expressions. By default only booleans are allowed.\\n\\n            The following nodes are checked:\\n\\n            * Arguments to the `!`, `&&`, and `||` operators\\n            * The condition in a conditional expression (`cond ? x : y`)\\n            * Conditions for `if`, `for`, `while`, and `do-while` statements.\"], _a.raw = [\"\\n            Restricts the types allowed in boolean expressions. By default only booleans are allowed.\\n\\n            The following nodes are checked:\\n\\n            * Arguments to the \\\\`!\\\\`, \\\\`&&\\\\`, and \\\\`||\\\\` operators\\n            * The condition in a conditional expression (\\\\`cond ? x : y\\\\`)\\n            * Conditions for \\\\`if\\\\`, \\\\`for\\\\`, \\\\`while\\\\`, and \\\\`do-while\\\\` statements.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: (_b = [\"\\n            These options may be provided:\\n\\n            * `\", \"` allows union types containing `null`.\\n              - It does *not* allow `null` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * `\", \"` allows union types containing `undefined`.\\n              - It does *not* allow `undefined` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * `\", \"` allows strings.\\n              - It does *not* allow unions containing `string`.\\n              - It does *not* allow string literal types.\\n            * `\", \"` allows numbers.\\n              - It does *not* allow unions containing `number`.\\n              - It does *not* allow enums or number literal types.\\n            * `\", \"` allow multiple of the above to appear together.\\n              - For example, `string | number` or `RegExp | null | undefined` would normally not be allowed.\\n              - A type like `\\\"foo\\\" | \\\"bar\\\" | undefined` is always allowed, because it has only one way to be false.\"], _b.raw = [\"\\n            These options may be provided:\\n\\n            * \\\\`\", \"\\\\` allows union types containing \\\\`null\\\\`.\\n              - It does *not* allow \\\\`null\\\\` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * \\\\`\", \"\\\\` allows union types containing \\\\`undefined\\\\`.\\n              - It does *not* allow \\\\`undefined\\\\` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * \\\\`\", \"\\\\` allows strings.\\n              - It does *not* allow unions containing \\\\`string\\\\`.\\n              - It does *not* allow string literal types.\\n            * \\\\`\", \"\\\\` allows numbers.\\n              - It does *not* allow unions containing \\\\`number\\\\`.\\n              - It does *not* allow enums or number literal types.\\n            * \\\\`\", \"\\\\` allow multiple of the above to appear together.\\n              - For example, \\\\`string | number\\\\` or \\\\`RegExp | null | undefined\\\\` would normally not be allowed.\\n              - A type like \\\\`\\\"foo\\\" | \\\"bar\\\" | undefined\\\\` is always allowed, because it has only one way to be false.\"], Lint.Utils.dedent(_b, OPTION_ALLOW_NULL_UNION, OPTION_ALLOW_UNDEFINED_UNION, OPTION_ALLOW_STRING, OPTION_ALLOW_NUMBER, OPTION_ALLOW_MIX)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_ALLOW_NULL_UNION, OPTION_ALLOW_UNDEFINED_UNION, OPTION_ALLOW_STRING, OPTION_ALLOW_NUMBER],\n        },\n        minLength: 0,\n        maxLength: 5,\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, \" + OPTION_ALLOW_NULL_UNION + \", \" + OPTION_ALLOW_UNDEFINED_UNION + \", \" + OPTION_ALLOW_STRING + \", \" + OPTION_ALLOW_NUMBER + \"]\",\n    ],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments, strictNullChecks) {\n    return {\n        strictNullChecks: strictNullChecks,\n        allowNullUnion: has(OPTION_ALLOW_NULL_UNION),\n        allowUndefinedUnion: has(OPTION_ALLOW_UNDEFINED_UNION),\n        allowString: has(OPTION_ALLOW_STRING),\n        allowNumber: has(OPTION_ALLOW_NUMBER),\n        allowMix: has(OPTION_ALLOW_MIX),\n    };\n    function has(name) {\n        return ruleArguments.indexOf(name) !== -1;\n    }\n}\nfunction walk(ctx, checker) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.BinaryExpression: {\n                var b_1 = node;\n                if (binaryBooleanExpressionKind(b_1)) {\n                    var left = b_1.left, right = b_1.right;\n                    var checkHalf = function (expr) {\n                        // If it's another boolean binary expression, we'll check it when recursing.\n                        if (!isBooleanBinaryExpression(expr)) {\n                            checkExpression(expr, b_1);\n                        }\n                    };\n                    checkHalf(left);\n                    checkHalf(right);\n                }\n                break;\n            }\n            case ts.SyntaxKind.PrefixUnaryExpression: {\n                var _a = node, operator = _a.operator, operand = _a.operand;\n                if (operator === ts.SyntaxKind.ExclamationToken) {\n                    checkExpression(operand, node);\n                }\n                break;\n            }\n            case ts.SyntaxKind.IfStatement:\n            case ts.SyntaxKind.WhileStatement:\n            case ts.SyntaxKind.DoStatement: {\n                var c = node;\n                // If it's a boolean binary expression, we'll check it when recursing.\n                if (!isBooleanBinaryExpression(c.expression)) {\n                    checkExpression(c.expression, c);\n                }\n                break;\n            }\n            case ts.SyntaxKind.ConditionalExpression:\n                checkExpression(node.condition, node);\n                break;\n            case ts.SyntaxKind.ForStatement: {\n                var condition = node.condition;\n                if (condition) {\n                    checkExpression(condition, node);\n                }\n                break;\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkExpression(node, location) {\n        var type = checker.getTypeAtLocation(node);\n        var failure = getTypeFailure(type, options);\n        if (failure !== undefined) {\n            if (failure === 0 /* AlwaysTruthy */ &&\n                !options.strictNullChecks &&\n                (options.allowNullUnion || options.allowUndefinedUnion)) {\n                // OK; It might be null/undefined.\n                return;\n            }\n            ctx.addFailureAtNode(node, showFailure(location, failure, isUnionType(type), options));\n        }\n    }\n}\nfunction getTypeFailure(type, options) {\n    if (isUnionType(type)) {\n        return handleUnion(type, options);\n    }\n    var kind = getKind(type);\n    var failure = failureForKind(kind, /*isInUnion*/ false, options);\n    if (failure !== undefined) {\n        return failure;\n    }\n    switch (triState(kind)) {\n        case true:\n            return 0 /* AlwaysTruthy */;\n        case false:\n            return 1 /* AlwaysFalsy */;\n        case undefined:\n            return undefined;\n    }\n}\nfunction handleUnion(type, options) {\n    // Tracks whether it's possibly truthy.\n    var anyTruthy = false;\n    // Counts falsy kinds to see if there's a mix. Also tracks whether it's possibly falsy.\n    var seenFalsy = 0;\n    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {\n        var ty = _a[_i];\n        var kind = getKind(ty);\n        var failure = failureForKind(kind, /*isInUnion*/ true, options);\n        if (failure !== undefined) {\n            return failure;\n        }\n        switch (triState(kind)) {\n            case true:\n                anyTruthy = true;\n                break;\n            case false:\n                seenFalsy++;\n                break;\n            default:\n                anyTruthy = true;\n                seenFalsy++;\n        }\n    }\n    return seenFalsy === 0 ? 0 /* AlwaysTruthy */\n        : !anyTruthy ? 1 /* AlwaysFalsy */\n            : !options.allowMix && seenFalsy > 1 ? 7 /* Mixes */ : undefined;\n}\n/** Fails if a kind of falsiness is not allowed. */\nfunction failureForKind(kind, isInUnion, options) {\n    switch (kind) {\n        case 0 /* String */:\n        case 1 /* FalseStringLiteral */:\n            return options.allowString ? undefined : 2 /* String */;\n        case 2 /* Number */:\n        case 3 /* FalseNumberLiteral */:\n            return options.allowNumber ? undefined : 3 /* Number */;\n        case 8 /* Enum */:\n            return 6 /* Enum */;\n        case 6 /* Null */:\n            return isInUnion && !options.allowNullUnion ? 4 /* Null */ : undefined;\n        case 7 /* Undefined */:\n            return isInUnion && !options.allowUndefinedUnion ? 5 /* Undefined */ : undefined;\n        default:\n            return undefined;\n    }\n}\n/** Divides a type into always true, always false, or unknown. */\nfunction triState(kind) {\n    switch (kind) {\n        case 0 /* String */:\n        case 2 /* Number */:\n        case 4 /* Boolean */:\n        case 8 /* Enum */:\n            return undefined;\n        case 6 /* Null */:\n        case 7 /* Undefined */:\n        case 3 /* FalseNumberLiteral */:\n        case 1 /* FalseStringLiteral */:\n        case 5 /* FalseBooleanLiteral */:\n            return false;\n        case 9 /* AlwaysTruthy */:\n            return true;\n    }\n}\nfunction getKind(type) {\n    return is(ts.TypeFlags.String) ? 0 /* String */\n        : is(ts.TypeFlags.Number) ? 2 /* Number */\n            : is(ts.TypeFlags.Boolean) ? 4 /* Boolean */\n                : is(ts.TypeFlags.Null) ? 6 /* Null */\n                    : is(ts.TypeFlags.Undefined | ts.TypeFlags.Void) ? 7 /* Undefined */ // tslint:disable-line:no-bitwise\n                        : is(ts.TypeFlags.EnumLike) ? 8 /* Enum */\n                            : is(ts.TypeFlags.NumberLiteral) ?\n                                (type.text === \"0\" ? 3 /* FalseNumberLiteral */ : 9 /* AlwaysTruthy */)\n                                : is(ts.TypeFlags.StringLiteral) ?\n                                    (type.text === \"\" ? 1 /* FalseStringLiteral */ : 9 /* AlwaysTruthy */)\n                                    : is(ts.TypeFlags.BooleanLiteral) ?\n                                        (type.intrinsicName === \"true\" ? 9 /* AlwaysTruthy */ : 5 /* FalseBooleanLiteral */)\n                                        : 9 /* AlwaysTruthy */;\n    function is(flags) {\n        return Lint.isTypeFlagSet(type, flags);\n    }\n}\n/** Matches `&&` and `||` operators. */\nfunction isBooleanBinaryExpression(node) {\n    return node.kind === ts.SyntaxKind.BinaryExpression && binaryBooleanExpressionKind(node) !== undefined;\n}\nfunction binaryBooleanExpressionKind(node) {\n    switch (node.operatorToken.kind) {\n        case ts.SyntaxKind.AmpersandAmpersandToken:\n            return \"&&\";\n        case ts.SyntaxKind.BarBarToken:\n            return \"||\";\n        default:\n            return undefined;\n    }\n}\nfunction stringOr(parts) {\n    switch (parts.length) {\n        case 1:\n            return parts[0];\n        case 2:\n            return parts[0] + \" or \" + parts[1];\n        default:\n            var res = \"\";\n            for (var i = 0; i < parts.length - 1; i++) {\n                res += parts[i] + \", \";\n            }\n            return res + \"or \" + parts[parts.length - 1];\n    }\n}\nfunction isUnionType(type) {\n    return Lint.isTypeFlagSet(type, ts.TypeFlags.Union) && !Lint.isTypeFlagSet(type, ts.TypeFlags.Enum);\n}\nfunction showLocation(n) {\n    switch (n.kind) {\n        case ts.SyntaxKind.PrefixUnaryExpression:\n            return \"operand for the '!' operator\";\n        case ts.SyntaxKind.ConditionalExpression:\n            return \"condition\";\n        case ts.SyntaxKind.ForStatement:\n            return \"'for' condition\";\n        case ts.SyntaxKind.IfStatement:\n            return \"'if' condition\";\n        case ts.SyntaxKind.WhileStatement:\n            return \"'while' condition\";\n        case ts.SyntaxKind.DoStatement:\n            return \"'do-while' condition\";\n        case ts.SyntaxKind.BinaryExpression:\n            return \"operand for the '\" + binaryBooleanExpressionKind(n) + \"' operator\";\n    }\n}\nfunction showFailure(location, ty, isUnionType, options) {\n    var expectedTypes = showExpectedTypes(options);\n    var expected = expectedTypes.length === 1\n        ? \"Only \" + expectedTypes[0] + \"s are allowed\"\n        : \"Allowed types are \" + stringOr(expectedTypes);\n    var tyFail = showTypeFailure(ty, isUnionType, options.strictNullChecks);\n    return \"This type is not allowed in the \" + showLocation(location) + \" because it \" + tyFail + \". \" + expected + \".\";\n}\nfunction showExpectedTypes(options) {\n    var parts = [\"boolean\"];\n    if (options.allowNullUnion) {\n        parts.push(\"null-union\");\n    }\n    if (options.allowUndefinedUnion) {\n        parts.push(\"undefined-union\");\n    }\n    if (options.allowString) {\n        parts.push(\"string\");\n    }\n    if (options.allowNumber) {\n        parts.push(\"number\");\n    }\n    return parts;\n}\nfunction showTypeFailure(ty, isUnionType, strictNullChecks) {\n    var is = isUnionType ? \"could be\" : \"is\";\n    switch (ty) {\n        case 0 /* AlwaysTruthy */:\n            return strictNullChecks\n                ? \"is always truthy\"\n                : \"is always truthy. It may be null/undefined, but neither \" +\n                    (\"'\" + OPTION_ALLOW_NULL_UNION + \"' nor '\" + OPTION_ALLOW_UNDEFINED_UNION + \"' is set\");\n        case 1 /* AlwaysFalsy */: return \"is always falsy\";\n        case 2 /* String */: return is + \" a string\";\n        case 3 /* Number */: return is + \" a number\";\n        case 4 /* Null */: return is + \" null\";\n        case 5 /* Undefined */: return is + \" undefined\";\n        case 6 /* Enum */: return is + \" an enum\";\n        case 7 /* Mixes */: return \"unions more than one truthy/falsy type\";\n    }\n}\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/strictTypePredicatesRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\n// tslint:disable:no-bitwise\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.FAILURE_STRING = function (value) {\n        return \"Expression is always \" + value + \".\";\n    };\n    Rule.FAILURE_STRICT_PREFER_STRICT_EQUALS = function (value, isPositive) {\n        return \"Use '\" + (isPositive ? \"===\" : \"!==\") + \" \" + value + \"' instead.\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"strict-type-predicates\",\n    description: (_a = [\"\\n            Warns for type predicates that are always true or always false.\\n            Works for 'typeof' comparisons to constants (e.g. 'typeof foo === \\\"string\\\"'), and equality comparison to 'null'/'undefined'.\\n            (TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\\n            Does not yet work for 'instanceof'.\\n            Does *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\"], _a.raw = [\"\\n            Warns for type predicates that are always true or always false.\\n            Works for 'typeof' comparisons to constants (e.g. 'typeof foo === \\\"string\\\"'), and equality comparison to 'null'/'undefined'.\\n            (TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\\n            Does not yet work for 'instanceof'.\\n            Does *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_BAD_TYPEOF = \"Bad comparison for 'typeof'.\";\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (utils.isBinaryExpression(node)) {\n            var equals = Lint.getEqualsKind(node.operatorToken);\n            if (equals) {\n                checkEquals(node, equals);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkEquals(node, _a) {\n        var isStrict = _a.isStrict, isPositive = _a.isPositive;\n        var exprPred = getTypePredicate(node, isStrict);\n        if (exprPred === undefined) {\n            return;\n        }\n        if (exprPred.kind === 2 /* TypeofTypo */) {\n            fail(Rule.FAILURE_STRING_BAD_TYPEOF);\n            return;\n        }\n        var exprType = checker.getTypeAtLocation(exprPred.expression);\n        // TODO: could use checker.getBaseConstraintOfType to help with type parameters, but it's not publicly exposed.\n        if (Lint.isTypeFlagSet(exprType, ts.TypeFlags.Any | ts.TypeFlags.TypeParameter)) {\n            return;\n        }\n        switch (exprPred.kind) {\n            case 0 /* Plain */: {\n                var predicate = exprPred.predicate, isNullOrUndefined = exprPred.isNullOrUndefined;\n                var value = getConstantBoolean(exprType, predicate);\n                // 'null'/'undefined' are the only two values *not* assignable to '{}'.\n                if (value !== undefined && (isNullOrUndefined || !isEmptyType(checker, exprType))) {\n                    fail(Rule.FAILURE_STRING(value === isPositive));\n                }\n                break;\n            }\n            case 1 /* NonStructNullUndefined */: {\n                var result = testNonStrictNullUndefined(exprType);\n                if (result !== undefined) {\n                    fail(typeof result === \"boolean\"\n                        ? Rule.FAILURE_STRING(result === isPositive)\n                        : Rule.FAILURE_STRICT_PREFER_STRICT_EQUALS(result, isPositive));\n                }\n                break;\n            }\n        }\n        function fail(failure) {\n            ctx.addFailureAtNode(node, failure);\n        }\n    }\n}\n/** Detects a type predicate given `left === right`. */\nfunction getTypePredicate(node, isStrictEquals) {\n    var left = node.left, right = node.right;\n    return getTypePredicateOneWay(left, right, isStrictEquals) || getTypePredicateOneWay(right, left, isStrictEquals);\n}\n/** Only gets the type predicate if the expression is on the left. */\nfunction getTypePredicateOneWay(left, right, isStrictEquals) {\n    switch (right.kind) {\n        case ts.SyntaxKind.TypeOfExpression:\n            var expression = right.expression;\n            var kind = left.kind === ts.SyntaxKind.StringLiteral ? left.text : \"\";\n            var predicate = getTypePredicateForKind(kind);\n            return predicate === undefined\n                ? { kind: 2 /* TypeofTypo */ }\n                : { kind: 0 /* Plain */, expression: expression, predicate: predicate, isNullOrUndefined: kind === \"undefined\" };\n        case ts.SyntaxKind.NullKeyword:\n            return nullOrUndefined(ts.TypeFlags.Null);\n        case ts.SyntaxKind.Identifier:\n            if (right.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n                return nullOrUndefined(undefinedFlags);\n            }\n            return undefined;\n        default:\n            return undefined;\n    }\n    function nullOrUndefined(flags) {\n        return isStrictEquals\n            ? { kind: 0 /* Plain */, expression: left, predicate: flagPredicate(flags), isNullOrUndefined: true }\n            : { kind: 1 /* NonStructNullUndefined */, expression: left };\n    }\n}\nfunction isEmptyType(checker, type) {\n    return checker.typeToString(type) === \"{}\";\n}\nvar undefinedFlags = ts.TypeFlags.Undefined | ts.TypeFlags.Void;\nfunction getTypePredicateForKind(kind) {\n    switch (kind) {\n        case \"undefined\":\n            return flagPredicate(undefinedFlags);\n        case \"boolean\":\n            return flagPredicate(ts.TypeFlags.BooleanLike);\n        case \"number\":\n            return flagPredicate(ts.TypeFlags.NumberLike);\n        case \"string\":\n            return flagPredicate(ts.TypeFlags.StringLike);\n        case \"symbol\":\n            return flagPredicate(ts.TypeFlags.ESSymbol);\n        case \"function\":\n            return isFunction;\n        case \"object\":\n            // It's an object if it's not any of the above.\n            var allFlags_1 = ts.TypeFlags.Undefined | ts.TypeFlags.Void | ts.TypeFlags.BooleanLike |\n                ts.TypeFlags.NumberLike | ts.TypeFlags.StringLike | ts.TypeFlags.ESSymbol;\n            return function (type) { return !Lint.isTypeFlagSet(type, allFlags_1) && !isFunction(type); };\n        default:\n            return undefined;\n    }\n}\nfunction flagPredicate(testedFlag) {\n    return function (type) { return Lint.isTypeFlagSet(type, testedFlag); };\n}\nfunction isFunction(t) {\n    if (t.getConstructSignatures().length !== 0 || t.getCallSignatures().length !== 0) {\n        return true;\n    }\n    var symbol = t.getSymbol();\n    return (symbol && symbol.getName()) === \"Function\";\n}\n/** Returns a boolean value if that should always be the result of a type predicate. */\nfunction getConstantBoolean(type, predicate) {\n    var anyTrue = false;\n    var anyFalse = false;\n    for (var _i = 0, _a = unionParts(type); _i < _a.length; _i++) {\n        var ty = _a[_i];\n        if (predicate(ty)) {\n            anyTrue = true;\n        }\n        else {\n            anyFalse = true;\n        }\n        if (anyTrue && anyFalse) {\n            return undefined;\n        }\n    }\n    return anyTrue;\n}\n/** Returns bool for always/never true, or a string to recommend strict equality. */\nfunction testNonStrictNullUndefined(type) {\n    var anyNull = false;\n    var anyUndefined = false;\n    var anyOther = false;\n    for (var _i = 0, _a = unionParts(type); _i < _a.length; _i++) {\n        var ty = _a[_i];\n        if (Lint.isTypeFlagSet(ty, ts.TypeFlags.Null)) {\n            anyNull = true;\n        }\n        else if (Lint.isTypeFlagSet(ty, undefinedFlags)) {\n            anyUndefined = true;\n        }\n        else {\n            anyOther = true;\n        }\n    }\n    return !anyOther ? true\n        : anyNull && anyUndefined ? undefined\n            : anyNull ? \"null\"\n                : anyUndefined ? \"undefined\"\n                    : false;\n}\nfunction unionParts(type) {\n    return isUnionType(type) ? type.types : [type];\n}\n/** Type predicate to test for a union type. */\nfunction isUnionType(type) {\n    return Lint.isTypeFlagSet(type, ts.TypeFlags.Union);\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/switchDefaultRule.js":"/**\n * @license\n * Copyright 2015 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"switch-default\",\n    description: \"Require a `default` case in all `switch` statements.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Switch statement should include a 'default' case\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.SwitchStatement &&\n            !node.caseBlock.clauses.some(tsutils_1.isDefaultClause)) {\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/tripleEqualsRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_NULL_CHECK = \"allow-null-check\";\nvar OPTION_ALLOW_UNDEFINED_CHECK = \"allow-undefined-check\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, {\n            allowNull: this.ruleArguments.indexOf(OPTION_ALLOW_NULL_CHECK) !== -1,\n            allowUndefined: this.ruleArguments.indexOf(OPTION_ALLOW_UNDEFINED_CHECK) !== -1,\n        });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"triple-equals\",\n    description: \"Requires `===` and `!==` in place of `==` and `!=`.\",\n    optionsDescription: (_a = [\"\\n            Two arguments may be optionally provided:\\n\\n            * `\\\"allow-null-check\\\"` allows `==` and `!=` when comparing to `null`.\\n            * `\\\"allow-undefined-check\\\"` allows `==` and `!=` when comparing to `undefined`.\"], _a.raw = [\"\\n            Two arguments may be optionally provided:\\n\\n            * \\\\`\\\"allow-null-check\\\"\\\\` allows \\\\`==\\\\` and \\\\`!=\\\\` when comparing to \\\\`null\\\\`.\\n            * \\\\`\\\"allow-undefined-check\\\"\\\\` allows \\\\`==\\\\` and \\\\`!=\\\\` when comparing to \\\\`undefined\\\\`.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_ALLOW_NULL_CHECK, OPTION_ALLOW_UNDEFINED_CHECK],\n        },\n        minLength: 0,\n        maxLength: 2,\n    },\n    optionExamples: [\"true\", '[true, \"allow-null-check\"]', '[true, \"allow-undefined-check\"]'],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.EQ_FAILURE_STRING = \"== should be ===\";\nRule.NEQ_FAILURE_STRING = \"!= should be !==\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isBinaryExpression(node)) {\n            if ((node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||\n                node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken) &&\n                !(isExpressionAllowed(node.right, ctx.options) || isExpressionAllowed(node.left, ctx.options))) {\n                ctx.addFailureAtNode(node.operatorToken, node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken\n                    ? Rule.EQ_FAILURE_STRING\n                    : Rule.NEQ_FAILURE_STRING);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction isExpressionAllowed(node, options) {\n    if (node.kind === ts.SyntaxKind.NullKeyword) {\n        return options.allowNull;\n    }\n    return options.allowUndefined &&\n        node.kind === ts.SyntaxKind.Identifier &&\n        node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/useIsnanRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"use-isnan\",\n    description: \"Enforces use of the `isNaN()` function to check for NaN references instead of a comparison to the `NaN` constant.\",\n    rationale: (_a = [\"\\n            Since `NaN !== NaN`, comparisons with regular operators will produce unexpected results.\\n            So, instead of `if (myVar === NaN)`, do `if (isNaN(myVar))`.\"], _a.raw = [\"\\n            Since \\\\`NaN !== NaN\\\\`, comparisons with regular operators will produce unexpected results.\\n            So, instead of \\\\`if (myVar === NaN)\\\\`, do \\\\`if (isNaN(myVar))\\\\`.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Found an invalid comparison for NaN: \";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isBinaryExpression(node)) {\n            switch (node.operatorToken.kind) {\n                case ts.SyntaxKind.LessThanToken:\n                case ts.SyntaxKind.GreaterThanToken:\n                case ts.SyntaxKind.LessThanEqualsToken:\n                case ts.SyntaxKind.GreaterThanEqualsToken:\n                case ts.SyntaxKind.EqualsEqualsToken:\n                case ts.SyntaxKind.ExclamationEqualsToken:\n                case ts.SyntaxKind.EqualsEqualsEqualsToken:\n                case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n                    if (isExpressionNaN(node.right) || isExpressionNaN(node.left)) {\n                        ctx.addFailureAtNode(node, Rule.FAILURE_STRING + node.getText(ctx.sourceFile));\n                    }\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction isExpressionNaN(node) {\n    return node.kind === ts.SyntaxKind.Identifier && node.text === \"NaN\";\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/cyclomaticComplexityRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new CyclomaticComplexityWalker(sourceFile, this.getOptions(), this.threshold));\n    };\n    Rule.prototype.isEnabled = function () {\n        // Disable the rule if the option is provided but non-numeric or less than the minimum.\n        var isThresholdValid = typeof this.threshold === \"number\" && this.threshold >= Rule.MINIMUM_THRESHOLD;\n        return _super.prototype.isEnabled.call(this) && isThresholdValid;\n    };\n    Object.defineProperty(Rule.prototype, \"threshold\", {\n        get: function () {\n            if (this.ruleArguments[0] !== undefined) {\n                return this.ruleArguments[0];\n            }\n            return Rule.DEFAULT_THRESHOLD;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.DEFAULT_THRESHOLD = 20;\nRule.MINIMUM_THRESHOLD = 2;\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"cyclomatic-complexity\",\n    description: \"Enforces a threshold of cyclomatic complexity.\",\n    descriptionDetails: (_a = [\"\\n            Cyclomatic complexity is assessed for each function of any type. A starting value of 20\\n            is assigned and this value is then incremented for every statement which can branch the\\n            control flow within the function. The following statements and expressions contribute\\n            to cyclomatic complexity:\\n            * `catch`\\n            * `if` and `? :`\\n            * `||` and `&&` due to short-circuit evaluation\\n            * `for`, `for in` and `for of` loops\\n            * `while` and `do while` loops\"], _a.raw = [\"\\n            Cyclomatic complexity is assessed for each function of any type. A starting value of 20\\n            is assigned and this value is then incremented for every statement which can branch the\\n            control flow within the function. The following statements and expressions contribute\\n            to cyclomatic complexity:\\n            * \\\\`catch\\\\`\\n            * \\\\`if\\\\` and \\\\`? :\\\\`\\n            * \\\\`||\\\\` and \\\\`&&\\\\` due to short-circuit evaluation\\n            * \\\\`for\\\\`, \\\\`for in\\\\` and \\\\`for of\\\\` loops\\n            * \\\\`while\\\\` and \\\\`do while\\\\` loops\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            Cyclomatic complexity is a code metric which indicates the level of complexity in a\\n            function. High cyclomatic complexity indicates confusing code which may be prone to\\n            errors or difficult to modify.\"], _b.raw = [\"\\n            Cyclomatic complexity is a code metric which indicates the level of complexity in a\\n            function. High cyclomatic complexity indicates confusing code which may be prone to\\n            errors or difficult to modify.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: (_c = [\"\\n            An optional upper limit for cyclomatic complexity can be specified. If no limit option\\n            is provided a default value of $(Rule.DEFAULT_THRESHOLD) will be used.\"], _c.raw = [\"\\n            An optional upper limit for cyclomatic complexity can be specified. If no limit option\\n            is provided a default value of $(Rule.DEFAULT_THRESHOLD) will be used.\"], Lint.Utils.dedent(_c)),\n    options: {\n        type: \"number\",\n        minimum: \"$(Rule.MINIMUM_THRESHOLD)\",\n    },\n    optionExamples: [\"true\", \"[true, 20]\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.ANONYMOUS_FAILURE_STRING = function (expected, actual) {\n    return \"The function has a cyclomatic complexity of \" + actual + \" which is higher than the threshold of \" + expected;\n};\nRule.NAMED_FAILURE_STRING = function (expected, actual, name) {\n    return \"The function \" + name + \" has a cyclomatic complexity of \" + actual + \" which is higher than the threshold of \" + expected;\n};\nexports.Rule = Rule;\nvar CyclomaticComplexityWalker = (function (_super) {\n    __extends(CyclomaticComplexityWalker, _super);\n    function CyclomaticComplexityWalker(sourceFile, options, threshold) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.threshold = threshold;\n        _this.functions = [];\n        return _this;\n    }\n    CyclomaticComplexityWalker.prototype.visitArrowFunction = function (node) {\n        this.startFunction();\n        _super.prototype.visitArrowFunction.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitBinaryExpression = function (node) {\n        switch (node.operatorToken.kind) {\n            case ts.SyntaxKind.BarBarToken:\n            case ts.SyntaxKind.AmpersandAmpersandToken:\n                this.incrementComplexity();\n                break;\n            default:\n                break;\n        }\n        _super.prototype.visitBinaryExpression.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitCaseClause = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitCaseClause.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitCatchClause = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitCatchClause.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitConditionalExpression = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitConditionalExpression.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitConstructorDeclaration = function (node) {\n        this.startFunction();\n        _super.prototype.visitConstructorDeclaration.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitDoStatement = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitDoStatement.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitForStatement = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitForStatement.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitForInStatement = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitForInStatement.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitForOfStatement = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitForOfStatement.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.startFunction();\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitFunctionExpression = function (node) {\n        this.startFunction();\n        _super.prototype.visitFunctionExpression.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitGetAccessor = function (node) {\n        this.startFunction();\n        _super.prototype.visitGetAccessor.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitIfStatement = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitIfStatement.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.visitMethodDeclaration = function (node) {\n        this.startFunction();\n        _super.prototype.visitMethodDeclaration.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitSetAccessor = function (node) {\n        this.startFunction();\n        _super.prototype.visitSetAccessor.call(this, node);\n        this.endFunction(node);\n    };\n    CyclomaticComplexityWalker.prototype.visitWhileStatement = function (node) {\n        this.incrementComplexity();\n        _super.prototype.visitWhileStatement.call(this, node);\n    };\n    CyclomaticComplexityWalker.prototype.startFunction = function () {\n        // Push an initial complexity value to the stack for the new function.\n        this.functions.push(1);\n    };\n    CyclomaticComplexityWalker.prototype.endFunction = function (node) {\n        var complexity = this.functions.pop();\n        // Check for a violation.\n        if (complexity !== undefined && complexity > this.threshold) {\n            var failureString = void 0;\n            // Attempt to find a name for the function.\n            if (node.name && node.name.kind === ts.SyntaxKind.Identifier) {\n                failureString = Rule.NAMED_FAILURE_STRING(this.threshold, complexity, node.name.text);\n            }\n            else {\n                failureString = Rule.ANONYMOUS_FAILURE_STRING(this.threshold, complexity);\n            }\n            this.addFailureAtNode(node, failureString);\n        }\n    };\n    CyclomaticComplexityWalker.prototype.incrementComplexity = function () {\n        if (this.functions.length) {\n            this.functions[this.functions.length - 1]++;\n        }\n    };\n    return CyclomaticComplexityWalker;\n}(Lint.RuleWalker));\nvar _a, _b, _c;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/eoflineRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var length = sourceFile.text.length;\n        if (length === 0 ||\n            sourceFile.text[length - 1] === \"\\n\") {\n            return [];\n        }\n        var fix;\n        var lines = sourceFile.getLineStarts();\n        if (lines.length > 1) {\n            fix = Lint.Replacement.appendText(length, sourceFile.text[lines[1] - 2] === \"\\r\" ? \"\\r\\n\" : \"\\n\");\n        }\n        return this.filterFailures([\n            new Lint.RuleFailure(sourceFile, length, length, Rule.FAILURE_STRING, this.ruleName, fix),\n        ]);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"eofline\",\n    description: \"Ensures the file ends with a newline.\",\n    rationale: \"It is a [standard convention](http://stackoverflow.com/q/729692/3124288) to end files with a newline.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    hasFix: true,\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"file should end with a newline\";\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/indentRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_USE_TABS = \"tabs\";\nvar OPTION_USE_SPACES = \"spaces\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new IndentWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"indent\",\n    description: \"Enforces indentation with tabs or spaces.\",\n    rationale: (_a = [\"\\n            Using only one of tabs or spaces for indentation leads to more consistent editor behavior,\\n            cleaner diffs in version control, and easier programmatic manipulation.\"], _a.raw = [\"\\n            Using only one of tabs or spaces for indentation leads to more consistent editor behavior,\\n            cleaner diffs in version control, and easier programmatic manipulation.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: (_b = [\"\\n            One of the following arguments must be provided:\\n\\n            * `\\\"spaces\\\"` enforces consistent spaces.\\n            * `\\\"tabs\\\"` enforces consistent tabs.\"], _b.raw = [\"\\n            One of the following arguments must be provided:\\n\\n            * \\\\`\\\"spaces\\\"\\\\` enforces consistent spaces.\\n            * \\\\`\\\"tabs\\\"\\\\` enforces consistent tabs.\"], Lint.Utils.dedent(_b)),\n    options: {\n        type: \"string\",\n        enum: [\"tabs\", \"spaces\"],\n    },\n    optionExamples: ['[true, \"spaces\"]'],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_TABS = \"tab indentation expected\";\nRule.FAILURE_STRING_SPACES = \"space indentation expected\";\nexports.Rule = Rule;\n// visit every token and enforce that only the right character is used for indentation\nvar IndentWalker = (function (_super) {\n    __extends(IndentWalker, _super);\n    function IndentWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        if (_this.hasOption(OPTION_USE_TABS)) {\n            _this.regExp = new RegExp(\" \");\n            _this.failureString = Rule.FAILURE_STRING_TABS;\n        }\n        else if (_this.hasOption(OPTION_USE_SPACES)) {\n            _this.regExp = new RegExp(\"\\t\");\n            _this.failureString = Rule.FAILURE_STRING_SPACES;\n        }\n        return _this;\n    }\n    IndentWalker.prototype.visitSourceFile = function (node) {\n        if (!this.hasOption(OPTION_USE_TABS) && !this.hasOption(OPTION_USE_SPACES)) {\n            // if we don't have either option, no need to check anything, and no need to call super, so just return\n            return;\n        }\n        var endOfComment = -1;\n        var endOfTemplateString = -1;\n        var scanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, node.text);\n        for (var _i = 0, _a = node.getLineStarts(); _i < _a.length; _i++) {\n            var lineStart = _a[_i];\n            if (lineStart < endOfComment || lineStart < endOfTemplateString) {\n                // skip checking lines inside multi-line comments or template strings\n                continue;\n            }\n            scanner.setTextPos(lineStart);\n            var currentScannedType = scanner.scan();\n            var fullLeadingWhitespace = \"\";\n            var lastStartPos = -1;\n            while (currentScannedType === ts.SyntaxKind.WhitespaceTrivia) {\n                var startPos = scanner.getStartPos();\n                if (startPos === lastStartPos) {\n                    break;\n                }\n                lastStartPos = startPos;\n                fullLeadingWhitespace += scanner.getTokenText();\n                currentScannedType = scanner.scan();\n            }\n            var commentRanges = ts.getTrailingCommentRanges(node.text, lineStart);\n            if (commentRanges) {\n                endOfComment = commentRanges[commentRanges.length - 1].end;\n            }\n            else {\n                var scanType = currentScannedType;\n                // scan until we reach end of line, skipping over template strings\n                while (scanType !== ts.SyntaxKind.NewLineTrivia && scanType !== ts.SyntaxKind.EndOfFileToken) {\n                    if (scanType === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {\n                        // template string without expressions - skip past it\n                        endOfTemplateString = scanner.getStartPos() + scanner.getTokenText().length;\n                    }\n                    else if (scanType === ts.SyntaxKind.TemplateHead) {\n                        // find end of template string containing expressions...\n                        while (scanType !== ts.SyntaxKind.TemplateTail && scanType !== ts.SyntaxKind.EndOfFileToken) {\n                            scanType = scanner.scan();\n                            if (scanType === ts.SyntaxKind.CloseBraceToken) {\n                                scanType = scanner.reScanTemplateToken();\n                            }\n                        }\n                        // ... and skip past it\n                        endOfTemplateString = scanner.getStartPos() + scanner.getTokenText().length;\n                    }\n                    scanType = scanner.scan();\n                }\n            }\n            if (currentScannedType === ts.SyntaxKind.SingleLineCommentTrivia\n                || currentScannedType === ts.SyntaxKind.MultiLineCommentTrivia\n                || currentScannedType === ts.SyntaxKind.NewLineTrivia) {\n                // ignore lines that have comments before the first token\n                continue;\n            }\n            if (fullLeadingWhitespace.match(this.regExp)) {\n                this.addFailureAt(lineStart, fullLeadingWhitespace.length, this.failureString);\n            }\n        }\n        // no need to call super to visit the rest of the nodes, so don't call super here\n    };\n    return IndentWalker;\n}(Lint.RuleWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/linebreakStyleRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar OPTION_LINEBREAK_STYLE_CRLF = \"CRLF\";\nvar OPTION_LINEBREAK_STYLE_LF = \"LF\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.ruleArguments.indexOf(OPTION_LINEBREAK_STYLE_CRLF) !== -1);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"linebreak-style\",\n    description: \"Enforces a consistent linebreak style.\",\n    optionsDescription: (_a = [\"\\n            One of the following options must be provided:\\n\\n            * `\\\"\", \"\\\"` requires LF (`\\\\n`) linebreaks\\n            * `\\\"\", \"\\\"` requires CRLF (`\\\\r\\\\n`) linebreaks\"], _a.raw = [\"\\n            One of the following options must be provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` requires LF (\\\\`\\\\\\\\n\\\\`) linebreaks\\n            * \\\\`\\\"\", \"\\\"\\\\` requires CRLF (\\\\`\\\\\\\\r\\\\\\\\n\\\\`) linebreaks\"], Lint.Utils.dedent(_a, OPTION_LINEBREAK_STYLE_LF, OPTION_LINEBREAK_STYLE_CRLF)),\n    options: {\n        type: \"string\",\n        enum: [OPTION_LINEBREAK_STYLE_LF, OPTION_LINEBREAK_STYLE_CRLF],\n    },\n    optionExamples: [\"[true, \\\"\" + OPTION_LINEBREAK_STYLE_LF + \"\\\"]\", \"[true, \\\"\" + OPTION_LINEBREAK_STYLE_CRLF + \"\\\"]\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n    hasFix: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_CRLF = \"Expected linebreak to be '\" + OPTION_LINEBREAK_STYLE_CRLF + \"'\";\nRule.FAILURE_LF = \"Expected linebreak to be '\" + OPTION_LINEBREAK_STYLE_LF + \"'\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var expectedCr = ctx.options;\n    var sourceText = ctx.sourceFile.text;\n    var lineStarts = ctx.sourceFile.getLineStarts();\n    for (var i = 1; i < lineStarts.length; ++i) {\n        var lineEnd = lineStarts[i] - 1;\n        if (sourceText[lineEnd - 1] === \"\\r\") {\n            if (!expectedCr) {\n                ctx.addFailure(lineStarts[i - 1], lineEnd - 1, Rule.FAILURE_LF, Lint.Replacement.deleteText(lineEnd - 1, 1));\n            }\n        }\n        else if (expectedCr) {\n            ctx.addFailure(lineStarts[i - 1], lineEnd, Rule.FAILURE_CRLF, Lint.Replacement.appendText(lineEnd, \"\\r\"));\n        }\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/maxClassesPerFileRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new MaxClassesPerFileWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"max-classes-per-file\",\n    description: (_a = [\"\\n            A file may not contain more than the specified number of classes\"], _a.raw = [\"\\n            A file may not contain more than the specified number of classes\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            Ensures that files have a single responsibility so that that classes each exist in their own files\"], _b.raw = [\"\\n            Ensures that files have a single responsibility so that that classes each exist in their own files\"], Lint.Utils.dedent(_b)),\n    optionsDescription: (_c = [\"\\n            The one required argument is an integer indicating the maximum number of classes that can appear in a file.\"], _c.raw = [\"\\n            The one required argument is an integer indicating the maximum number of classes that can appear in a file.\"], Lint.Utils.dedent(_c)),\n    options: {\n        type: \"array\",\n        items: [\n            {\n                type: \"number\",\n                minimum: 1,\n            },\n        ],\n        additionalItems: false,\n        minLength: 1,\n        maxLength: 2,\n    },\n    optionExamples: [\"[true, 1]\", \"[true, 5]\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (maxCount) {\n    var maxClassWord = maxCount === 1 ? \"class per file is\" : \"classes per file are\";\n    return \"A maximum of \" + maxCount + \" \" + maxClassWord + \" allowed\";\n};\nexports.Rule = Rule;\nvar MaxClassesPerFileWalker = (function (_super) {\n    __extends(MaxClassesPerFileWalker, _super);\n    function MaxClassesPerFileWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.classCount = 0;\n        if (options.ruleArguments[0] === undefined\n            || isNaN(options.ruleArguments[0])\n            || options.ruleArguments[0] < 1) {\n            _this.maxClassCount = 1;\n        }\n        else {\n            _this.maxClassCount = options.ruleArguments[0];\n        }\n        return _this;\n    }\n    MaxClassesPerFileWalker.prototype.visitClassDeclaration = function (node) {\n        this.increaseClassCount(node);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    MaxClassesPerFileWalker.prototype.visitClassExpression = function (node) {\n        this.increaseClassCount(node);\n        _super.prototype.visitClassExpression.call(this, node);\n    };\n    MaxClassesPerFileWalker.prototype.increaseClassCount = function (node) {\n        this.classCount++;\n        if (this.classCount > this.maxClassCount) {\n            var msg = Rule.FAILURE_STRING_FACTORY(this.maxClassCount);\n            this.addFailureAtNode(node, msg);\n        }\n    };\n    return MaxClassesPerFileWalker;\n}(Lint.RuleWalker));\nvar _a, _b, _c;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/maxFileLineCountRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && this.ruleArguments[0] > 0;\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var ruleFailures = [];\n        var ruleArguments = this.getOptions().ruleArguments;\n        var lineLimit = ruleArguments[0];\n        var lineCount = sourceFile.getLineStarts().length;\n        var disabledIntervals = this.getOptions().disabledIntervals;\n        if (lineCount > lineLimit && disabledIntervals.length === 0) {\n            var errorString = Rule.FAILURE_STRING_FACTORY(lineCount, lineLimit);\n            ruleFailures.push(new Lint.RuleFailure(sourceFile, 0, 1, errorString, this.getOptions().ruleName));\n        }\n        return ruleFailures;\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"max-file-line-count\",\n    description: \"Requires files to remain under a certain number of lines\",\n    rationale: (_a = [\"\\n            Limiting the number of lines allowed in a file allows files to remain small,\\n            single purpose, and maintainable.\"], _a.raw = [\"\\n            Limiting the number of lines allowed in a file allows files to remain small,\\n            single purpose, and maintainable.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"An integer indicating the maximum number of lines.\",\n    options: {\n        type: \"number\",\n        minimum: \"1\",\n    },\n    optionExamples: [\"[true, 300]\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (lineCount, lineLimit) {\n    var msg = \"This file has \" + lineCount + \" lines, which exceeds the maximum of \" + lineLimit + \" lines allowed. \";\n    msg += \"Consider breaking this file up into smaller parts\";\n    return msg;\n};\nexports.Rule = Rule;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/maxLineLengthRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && this.ruleArguments[0] > 0;\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.ruleArguments[0]);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"max-line-length\",\n    description: \"Requires lines to be under a certain max length.\",\n    rationale: (_a = [\"\\n            Limiting the length of a line of code improves code readability.\\n            It also makes comparing code side-by-side easier and improves compatibility with\\n            various editors, IDEs, and diff viewers.\"], _a.raw = [\"\\n            Limiting the length of a line of code improves code readability.\\n            It also makes comparing code side-by-side easier and improves compatibility with\\n            various editors, IDEs, and diff viewers.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"An integer indicating the max length of lines.\",\n    options: {\n        type: \"number\",\n        minimum: \"1\",\n    },\n    optionExamples: [\"[true, 120]\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (lineLimit) {\n    return \"Exceeds maximum line length of \" + lineLimit;\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var limit = ctx.options;\n    for (var _i = 0, _a = tsutils_1.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        if (line.contentLength > limit) {\n            ctx.addFailureAt(line.pos, line.contentLength, Rule.FAILURE_STRING_FACTORY(limit));\n        }\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noDefaultExportRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoDefaultExportWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-default-export\",\n    description: \"Disallows default exports in ES6-style modules.\",\n    descriptionDetails: \"Use named exports instead.\",\n    rationale: (_a = [\"\\n            Named imports/exports [promote clarity](https://github.com/palantir/tslint/issues/1182#issue-151780453).\\n            In addition, current tooling differs on the correct way to handle default imports/exports.\\n            Avoiding them all together can help avoid tooling bugs and conflicts.\"], _a.raw = [\"\\n            Named imports/exports [promote clarity](https://github.com/palantir/tslint/issues/1182#issue-151780453).\\n            In addition, current tooling differs on the correct way to handle default imports/exports.\\n            Avoiding them all together can help avoid tooling bugs and conflicts.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Use of default exports is forbidden\";\nexports.Rule = Rule;\nvar NoDefaultExportWalker = (function (_super) {\n    __extends(NoDefaultExportWalker, _super);\n    function NoDefaultExportWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoDefaultExportWalker.prototype.visitExportAssignment = function (node) {\n        var exportMember = node.getChildAt(1);\n        if (exportMember != null && exportMember.kind === ts.SyntaxKind.DefaultKeyword) {\n            this.addFailureAtNode(exportMember, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitExportAssignment.call(this, node);\n    };\n    // inline class declaration and function declaration exports use modifiers\n    NoDefaultExportWalker.prototype.visitNode = function (node) {\n        if (node.kind === ts.SyntaxKind.DefaultKeyword && node.parent != null) {\n            var nodes = node.parent.modifiers;\n            if (nodes != null &&\n                nodes.length === 2 &&\n                nodes[0].kind === ts.SyntaxKind.ExportKeyword &&\n                nodes[1].kind === ts.SyntaxKind.DefaultKeyword) {\n                this.addFailureAtNode(nodes[1], Rule.FAILURE_STRING);\n            }\n        }\n        _super.prototype.visitNode.call(this, node);\n    };\n    return NoDefaultExportWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noMergeableNamespaceRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.failureStringFactory = function (name, seenBeforeLine) {\n        return \"Mergeable namespace '\" + name + \"' found. Merge its contents with the namespace on line \" + seenBeforeLine + \".\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-mergeable-namespace\",\n    description: \"Disallows mergeable namespaces in the same file.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"maintainability\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitSourceFile = function (node) {\n        this.checkStatements(node.statements);\n        // All tree-walking handled by 'checkStatements'\n    };\n    Walker.prototype.checkStatements = function (statements) {\n        var seen = new Map();\n        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {\n            var statement = statements_1[_i];\n            if (statement.kind !== ts.SyntaxKind.ModuleDeclaration) {\n                continue;\n            }\n            var name = statement.name;\n            if (name.kind === ts.SyntaxKind.Identifier) {\n                var text = name.text;\n                var prev = seen.get(text);\n                if (prev) {\n                    this.addFailureAtNode(name, Rule.failureStringFactory(text, this.getLineOfNode(prev)));\n                }\n                seen.set(text, statement);\n            }\n            // Recursively check in all module declarations\n            this.checkModuleDeclaration(statement);\n        }\n    };\n    Walker.prototype.checkModuleDeclaration = function (decl) {\n        var body = decl.body;\n        if (!body) {\n            return;\n        }\n        switch (body.kind) {\n            case ts.SyntaxKind.ModuleBlock:\n                this.checkStatements(body.statements);\n                break;\n            case ts.SyntaxKind.ModuleDeclaration:\n                this.checkModuleDeclaration(body);\n                break;\n            default:\n                break;\n        }\n    };\n    Walker.prototype.getLineOfNode = function (node) {\n        return this.getLineAndCharacterOfPosition(node.pos).line;\n    };\n    return Walker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noRequireImportsRule.js":"/**\n * @license\n * Copyright 2015 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoRequireImportsWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-require-imports\",\n    description: \"Disallows invocation of `require()`.\",\n    rationale: \"Prefer the newer ES6-style imports over `require()`.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"require() style import is forbidden\";\nexports.Rule = Rule;\nvar NoRequireImportsWalker = (function (_super) {\n    __extends(NoRequireImportsWalker, _super);\n    function NoRequireImportsWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoRequireImportsWalker.prototype.visitCallExpression = function (node) {\n        if (node.arguments != null && node.expression != null) {\n            var callExpressionText = node.expression.getText(this.getSourceFile());\n            if (callExpressionText === \"require\") {\n                this.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    NoRequireImportsWalker.prototype.visitImportEqualsDeclaration = function (node) {\n        var moduleReference = node.moduleReference;\n        if (moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {\n            this.addFailureAtNode(moduleReference, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitImportEqualsDeclaration.call(this, node);\n    };\n    return NoRequireImportsWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noTrailingWhitespaceRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar noConsecutiveBlankLinesRule_1 = require(\"./noConsecutiveBlankLinesRule\");\nvar OPTION_IGNORE_COMMENTS = \"ignore-comments\";\nvar OPTION_IGNORE_JSDOC = \"ignore-jsdoc\";\nvar OPTION_IGNORE_TEMPLATE_STRINGS = \"ignore-template-strings\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var ignoreComments = this.ruleArguments.indexOf(OPTION_IGNORE_COMMENTS) !== -1;\n        return this.applyWithFunction(sourceFile, walk, {\n            ignoreComments: ignoreComments,\n            ignoreJsDoc: ignoreComments || this.ruleArguments.indexOf(OPTION_IGNORE_JSDOC) !== -1,\n            ignoreTemplates: this.ruleArguments.indexOf(OPTION_IGNORE_TEMPLATE_STRINGS) !== -1,\n        });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-trailing-whitespace\",\n    description: \"Disallows trailing whitespace at the end of a line.\",\n    rationale: \"Keeps version control diffs clean as it prevents accidental whitespace from being committed.\",\n    optionsDescription: (_a = [\"\\n            Possible settings are:\\n\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace in template strings.\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace in comments.\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace only in JSDoc comments.\"], _a.raw = [\"\\n            Possible settings are:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace in template strings.\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace in comments.\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace only in JSDoc comments.\"], Lint.Utils.dedent(_a, OPTION_IGNORE_TEMPLATE_STRINGS, OPTION_IGNORE_COMMENTS, OPTION_IGNORE_JSDOC)),\n    hasFix: true,\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_IGNORE_COMMENTS, OPTION_IGNORE_JSDOC, OPTION_IGNORE_TEMPLATE_STRINGS],\n        },\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"\" + OPTION_IGNORE_COMMENTS + \"\\\"]\",\n        \"[true, \\\"\" + OPTION_IGNORE_JSDOC + \"\\\"]\",\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"trailing whitespace\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var possibleFailures = [];\n    var sourceFile = ctx.sourceFile;\n    var text = sourceFile.text;\n    for (var _i = 0, _a = tsutils_1.getLineRanges(sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        var match = text.substr(line.pos, line.contentLength).match(/\\s+$/);\n        if (match !== null) {\n            possibleFailures.push({\n                end: line.pos + line.contentLength,\n                pos: line.pos + match.index,\n            });\n        }\n    }\n    if (possibleFailures.length === 0) {\n        return;\n    }\n    var excludedRanges;\n    if (ctx.options.ignoreTemplates) {\n        excludedRanges = ctx.options.ignoreJsDoc ? getExcludedRanges(sourceFile, ctx.options) : noConsecutiveBlankLinesRule_1.getTemplateRanges(sourceFile);\n    }\n    else if (ctx.options.ignoreJsDoc) {\n        excludedRanges = getExcludedComments(sourceFile, ctx.options);\n    }\n    else {\n        excludedRanges = [];\n    }\n    var _loop_1 = function (possibleFailure) {\n        if (!excludedRanges.some(function (range) { return range.pos < possibleFailure.pos && possibleFailure.pos < range.end; })) {\n            ctx.addFailure(possibleFailure.pos, possibleFailure.end, Rule.FAILURE_STRING, Lint.Replacement.deleteFromTo(possibleFailure.pos, possibleFailure.end));\n        }\n    };\n    for (var _b = 0, possibleFailures_1 = possibleFailures; _b < possibleFailures_1.length; _b++) {\n        var possibleFailure = possibleFailures_1[_b];\n        _loop_1(possibleFailure);\n    }\n}\nfunction getExcludedRanges(sourceFile, options) {\n    var intervals = [];\n    tsutils_1.forEachTokenWithTrivia(sourceFile, function (text, kind, range) {\n        if (kind >= ts.SyntaxKind.FirstTemplateToken && kind <= ts.SyntaxKind.LastTemplateToken) {\n            intervals.push(range);\n        }\n        else if (options.ignoreComments) {\n            if (kind === ts.SyntaxKind.SingleLineCommentTrivia || kind === ts.SyntaxKind.MultiLineCommentTrivia) {\n                intervals.push(range);\n            }\n        }\n        else if (options.ignoreJsDoc) {\n            if (isJsDoc(text, kind, range)) {\n                intervals.push(range);\n            }\n        }\n    });\n    return intervals;\n}\nfunction getExcludedComments(sourceFile, options) {\n    var intervals = [];\n    tsutils_1.forEachComment(sourceFile, function (text, comment) {\n        if (options.ignoreComments ||\n            options.ignoreJsDoc && isJsDoc(text, comment.kind, comment)) {\n            intervals.push(comment);\n        }\n    });\n    return intervals;\n}\nfunction isJsDoc(sourceText, kind, range) {\n    return kind === ts.SyntaxKind.MultiLineCommentTrivia && sourceText[range.pos + 2] === \"*\" && sourceText[range.pos + 3] !== \"*\";\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noConsecutiveBlankLinesRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (allowed) {\n        return allowed === 1\n            ? \"Consecutive blank lines are forbidden\"\n            : \"Exceeds the \" + allowed + \" allowed consecutive blank lines\";\n    };\n    /**\n     * Disable the rule if the option is provided but non-numeric or less than the minimum.\n     */\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && (!this.ruleArguments[0] || this.ruleArguments[0] > 0);\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var limit = this.ruleArguments[0] || Rule.DEFAULT_ALLOWED_BLANKS;\n        return this.applyWithFunction(sourceFile, walk, limit);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.DEFAULT_ALLOWED_BLANKS = 1;\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-consecutive-blank-lines\",\n    description: \"Disallows one or more blank lines in a row.\",\n    hasFix: true,\n    rationale: \"Helps maintain a readable style in your codebase.\",\n    optionsDescription: (_a = [\"\\n            An optional number of maximum allowed sequential blanks can be specified. If no value\\n            is provided, a default of $(Rule.DEFAULT_ALLOWED_BLANKS) will be used.\"], _a.raw = [\"\\n            An optional number of maximum allowed sequential blanks can be specified. If no value\\n            is provided, a default of $(Rule.DEFAULT_ALLOWED_BLANKS) will be used.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"number\",\n        minimum: \"$(Rule.MINIMUM_ALLOWED_BLANKS)\",\n    },\n    optionExamples: [\"true\", \"[true, 2]\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceText = ctx.sourceFile.text;\n    var threshold = ctx.options + 1;\n    var possibleFailures = [];\n    var consecutiveBlankLines = 0;\n    for (var _i = 0, _a = utils.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        if (line.contentLength === 0 || sourceText.substr(line.pos, line.contentLength).search(/\\S/) === -1) {\n            ++consecutiveBlankLines;\n            if (consecutiveBlankLines === threshold) {\n                possibleFailures.push({\n                    end: line.end,\n                    pos: line.pos,\n                });\n            }\n            else if (consecutiveBlankLines > threshold) {\n                possibleFailures[possibleFailures.length - 1].end = line.end;\n            }\n        }\n        else {\n            consecutiveBlankLines = 0;\n        }\n    }\n    if (possibleFailures.length === 0) {\n        return;\n    }\n    var failureString = Rule.FAILURE_STRING_FACTORY(ctx.options);\n    var templateRanges = getTemplateRanges(ctx.sourceFile);\n    var _loop_1 = function (possibleFailure) {\n        if (!templateRanges.some(function (template) { return template.pos < possibleFailure.pos && possibleFailure.pos < template.end; })) {\n            ctx.addFailureAt(possibleFailure.pos, 1, failureString, [\n                Lint.Replacement.deleteFromTo(\n                // special handling for fixing blank lines at the end of the file\n                // to fix this we need to cut off the line break of the last allowed blank line, too\n                possibleFailure.end === sourceText.length ? getStartOfLineBreak(sourceText, possibleFailure.pos) : possibleFailure.pos, possibleFailure.end),\n            ]);\n        }\n    };\n    for (var _b = 0, possibleFailures_1 = possibleFailures; _b < possibleFailures_1.length; _b++) {\n        var possibleFailure = possibleFailures_1[_b];\n        _loop_1(possibleFailure);\n    }\n}\nfunction getStartOfLineBreak(sourceText, pos) {\n    return sourceText[pos - 2] === \"\\r\" ? pos - 1 : pos - 1;\n}\nfunction getTemplateRanges(sourceFile) {\n    var intervals = [];\n    var cb = function (node) {\n        if (node.kind >= ts.SyntaxKind.FirstTemplateToken &&\n            node.kind <= ts.SyntaxKind.LastTemplateToken) {\n            intervals.push({\n                end: node.end,\n                pos: node.getStart(sourceFile),\n            });\n        }\n        else {\n            return ts.forEachChild(node, cb);\n        }\n    };\n    ts.forEachChild(sourceFile, cb);\n    return intervals;\n}\nexports.getTemplateRanges = getTemplateRanges;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/objectLiteralSortKeysRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ObjectLiteralSortKeysWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"object-literal-sort-keys\",\n    description: \"Requires keys in object literals to be sorted alphabetically\",\n    rationale: \"Useful in preventing merge conflicts\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (name) {\n    return \"The key '\" + name + \"' is not sorted alphabetically\";\n};\nexports.Rule = Rule;\nvar ObjectLiteralSortKeysWalker = (function (_super) {\n    __extends(ObjectLiteralSortKeysWalker, _super);\n    function ObjectLiteralSortKeysWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // stacks are used to maintain state while recursing through nested object literals\n        _this.lastSortedKeyStack = [];\n        _this.multilineFlagStack = [];\n        _this.sortedStateStack = [];\n        return _this;\n    }\n    ObjectLiteralSortKeysWalker.prototype.visitObjectLiteralExpression = function (node) {\n        // char code 0; every string should be >= to this\n        this.lastSortedKeyStack.push(\"\");\n        // sorted state is always initially true\n        this.sortedStateStack.push(true);\n        this.multilineFlagStack.push(this.isMultilineListNode(node));\n        _super.prototype.visitObjectLiteralExpression.call(this, node);\n        this.multilineFlagStack.pop();\n        this.lastSortedKeyStack.pop();\n        this.sortedStateStack.pop();\n    };\n    ObjectLiteralSortKeysWalker.prototype.visitPropertyAssignment = function (node) {\n        var sortedState = this.sortedStateStack[this.sortedStateStack.length - 1];\n        var isMultiline = this.multilineFlagStack[this.multilineFlagStack.length - 1];\n        // skip remainder of object literal scan if a previous key was found\n        // in an unsorted position. This ensures only one error is thrown at\n        // a time and keeps error output clean. Skip also single line objects.\n        if (sortedState && isMultiline) {\n            var lastSortedKey = this.lastSortedKeyStack[this.lastSortedKeyStack.length - 1];\n            var keyNode = node.name;\n            if (isIdentifierOrStringLiteral(keyNode)) {\n                var key = keyNode.text;\n                if (key < lastSortedKey) {\n                    var failureString = Rule.FAILURE_STRING_FACTORY(key);\n                    this.addFailureAtNode(keyNode, failureString);\n                    this.sortedStateStack[this.sortedStateStack.length - 1] = false;\n                }\n                else {\n                    this.lastSortedKeyStack[this.lastSortedKeyStack.length - 1] = key;\n                }\n            }\n        }\n        _super.prototype.visitPropertyAssignment.call(this, node);\n    };\n    ObjectLiteralSortKeysWalker.prototype.isMultilineListNode = function (node) {\n        var startLineOfNode = this.getLineAndCharacterOfPosition(node.getStart()).line;\n        var endLineOfNode = this.getLineAndCharacterOfPosition(node.getEnd()).line;\n        return endLineOfNode !== startLineOfNode;\n    };\n    return ObjectLiteralSortKeysWalker;\n}(Lint.RuleWalker));\nfunction isIdentifierOrStringLiteral(node) {\n    return node.kind === ts.SyntaxKind.Identifier || node.kind === ts.SyntaxKind.StringLiteral;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/preferConstRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils = require(\"tsutils\");\nvar OPTION_DESTRUCTURING_ALL = \"all\";\nvar OPTION_DESTRUCTURING_ANY = \"any\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var options = {\n            destructuringAll: this.ruleArguments.length !== 0 &&\n                this.ruleArguments[0].destructuring === OPTION_DESTRUCTURING_ALL,\n        };\n        var preferConstWalker = new PreferConstWalker(sourceFile, this.ruleName, options);\n        return this.applyWithWalker(preferConstWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"prefer-const\",\n    description: \"Requires that variable declarations use `const` instead of `let` and `var` if possible.\",\n    descriptionDetails: (_a = [\"\\n            If a variable is only assigned to once when it is declared, it should be declared using 'const'\"], _a.raw = [\"\\n            If a variable is only assigned to once when it is declared, it should be declared using 'const'\"], Lint.Utils.dedent(_a)),\n    hasFix: true,\n    optionsDescription: (_b = [\"\\n            An optional object containing the property \\\"destructuring\\\" with two possible values:\\n\\n            * \\\"\", \"\\\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\\n            * \\\"\", \"\\\" - Only warns if all variables in destructuring can be const.\"], _b.raw = [\"\\n            An optional object containing the property \\\"destructuring\\\" with two possible values:\\n\\n            * \\\"\", \"\\\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\\n            * \\\"\", \"\\\" - Only warns if all variables in destructuring can be const.\"], Lint.Utils.dedent(_b, OPTION_DESTRUCTURING_ANY, OPTION_DESTRUCTURING_ALL)),\n    options: {\n        type: \"object\",\n        properties: {\n            destructuring: {\n                type: \"string\",\n                enum: [OPTION_DESTRUCTURING_ALL, OPTION_DESTRUCTURING_ANY],\n            },\n        },\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, {\\\"destructuring\\\": \\\"\" + OPTION_DESTRUCTURING_ALL + \"\\\"}]\",\n    ],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (identifier, blockScoped) {\n    return \"Identifier '\" + identifier + \"' is never reassigned; use 'const' instead of '\" + (blockScoped ? \"let\" : \"var\") + \"'.\";\n};\nexports.Rule = Rule;\nvar Scope = (function () {\n    function Scope(functionScope) {\n        this.variables = new Map();\n        this.reassigned = new Set();\n        // if no functionScope is provided we are in the process of creating a new function scope, which for consistency links to itself\n        this.functionScope = functionScope || this;\n    }\n    Scope.prototype.addVariable = function (identifier, declarationInfo, destructuringInfo) {\n        // block scoped variables go to the block scope, function scoped variables to the containing function scope\n        var scope = declarationInfo.isBlockScoped ? this : this.functionScope;\n        scope.variables.set(identifier.text, {\n            declarationInfo: declarationInfo,\n            destructuringInfo: destructuringInfo,\n            identifier: identifier,\n            reassigned: false,\n        });\n    };\n    return Scope;\n}());\nvar PreferConstWalker = (function (_super) {\n    __extends(PreferConstWalker, _super);\n    function PreferConstWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PreferConstWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        this.scope = new Scope();\n        var cb = function (node) {\n            var savedScope = _this.scope;\n            var boundary = utils.isScopeBoundary(node);\n            if (boundary !== 0 /* None */) {\n                if (boundary === 1 /* Function */) {\n                    _this.scope = new Scope();\n                    if (utils.isFunctionDeclaration(node) ||\n                        utils.isMethodDeclaration(node) ||\n                        utils.isFunctionExpression(node) ||\n                        utils.isArrowFunction(node) ||\n                        utils.isConstructorDeclaration(node)) {\n                        // special handling for function parameters\n                        // each parameter initializer can only reassign preceding parameters of variables of the containing scope\n                        if (node.body !== undefined) {\n                            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {\n                                var param = _a[_i];\n                                cb(param);\n                                _this.settle(savedScope);\n                            }\n                            cb(node.body);\n                            _this.onScopeEnd(savedScope);\n                        }\n                        _this.scope = savedScope;\n                        return;\n                    }\n                }\n                else {\n                    _this.scope = new Scope(_this.scope.functionScope);\n                }\n            }\n            if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n                _this.handleVariableDeclaration(node);\n            }\n            else if (node.kind === ts.SyntaxKind.CatchClause) {\n                _this.handleBindingName(node.variableDeclaration.name, {\n                    canBeConst: false,\n                    isBlockScoped: true,\n                });\n            }\n            else if (node.kind === ts.SyntaxKind.Parameter) {\n                _this.handleBindingName(node.name, {\n                    canBeConst: false,\n                    isBlockScoped: true,\n                });\n            }\n            else if (utils.isPostfixUnaryExpression(node) ||\n                utils.isPrefixUnaryExpression(node) &&\n                    (node.operator === ts.SyntaxKind.PlusPlusToken || node.operator === ts.SyntaxKind.MinusMinusToken)) {\n                if (utils.isIdentifier(node.operand)) {\n                    _this.scope.reassigned.add(node.operand.text);\n                }\n            }\n            else if (utils.isBinaryExpression(node) && utils.isAssignmentKind(node.operatorToken.kind)) {\n                _this.handleExpression(node.left);\n            }\n            if (boundary) {\n                ts.forEachChild(node, cb);\n                _this.onScopeEnd(savedScope);\n                _this.scope = savedScope;\n            }\n            else {\n                return ts.forEachChild(node, cb);\n            }\n        };\n        if (ts.isExternalModule(sourceFile)) {\n            ts.forEachChild(sourceFile, cb);\n            this.onScopeEnd();\n        }\n        else {\n            return ts.forEachChild(sourceFile, cb);\n        }\n    };\n    PreferConstWalker.prototype.handleExpression = function (node) {\n        if (node.kind === ts.SyntaxKind.Identifier) {\n            this.scope.reassigned.add(node.text);\n        }\n        else if (node.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            return this.handleExpression(node.expression);\n        }\n        else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {\n                var element = _a[_i];\n                if (element.kind === ts.SyntaxKind.SpreadElement) {\n                    this.handleExpression(element.expression);\n                }\n                else {\n                    this.handleExpression(element);\n                }\n            }\n        }\n        else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {\n                var property = _c[_b];\n                if (property.kind === ts.SyntaxKind.ShorthandPropertyAssignment) {\n                    this.scope.reassigned.add(property.name.text);\n                }\n                else if (property.kind === ts.SyntaxKind.SpreadAssignment) {\n                    if (property.name !== undefined) {\n                        this.scope.reassigned.add(property.name.text);\n                    }\n                    else {\n                        // handle `...(variable)`\n                        this.handleExpression(property.expression);\n                    }\n                }\n                else {\n                    this.handleExpression(property.initializer);\n                }\n            }\n        }\n    };\n    PreferConstWalker.prototype.handleBindingName = function (name, declarationInfo) {\n        var _this = this;\n        if (name.kind === ts.SyntaxKind.Identifier) {\n            this.scope.addVariable(name, declarationInfo);\n        }\n        else {\n            var destructuringInfo_1 = {\n                reassignedSiblings: false,\n            };\n            utils.forEachDestructuringIdentifier(name, function (declaration) { return _this.scope.addVariable(declaration.name, declarationInfo, destructuringInfo_1); });\n        }\n    };\n    PreferConstWalker.prototype.handleVariableDeclaration = function (declarationList) {\n        var declarationInfo;\n        var kind = utils.getVariableDeclarationKind(declarationList);\n        if (kind === 2 /* Const */ ||\n            utils.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword)) {\n            declarationInfo = {\n                canBeConst: false,\n                isBlockScoped: true,\n            };\n        }\n        else {\n            declarationInfo = {\n                allInitialized: declarationList.parent.kind === ts.SyntaxKind.ForOfStatement ||\n                    declarationList.parent.kind === ts.SyntaxKind.ForInStatement ||\n                    declarationList.declarations.every(function (declaration) { return declaration.initializer !== undefined; }),\n                canBeConst: true,\n                declarationList: declarationList,\n                isBlockScoped: kind === 1 /* Let */,\n                isForLoop: declarationList.parent.kind === ts.SyntaxKind.ForStatement,\n                reassignedSiblings: false,\n            };\n        }\n        for (var _i = 0, _a = declarationList.declarations; _i < _a.length; _i++) {\n            var declaration = _a[_i];\n            this.handleBindingName(declaration.name, declarationInfo);\n        }\n    };\n    PreferConstWalker.prototype.settle = function (parent) {\n        var _a = this.scope, variables = _a.variables, reassigned = _a.reassigned;\n        reassigned.forEach(function (name) {\n            var variableInfo = variables.get(name);\n            if (variableInfo !== undefined) {\n                if (variableInfo.declarationInfo.canBeConst) {\n                    variableInfo.reassigned = true;\n                    variableInfo.declarationInfo.reassignedSiblings = true;\n                    if (variableInfo.destructuringInfo !== undefined) {\n                        variableInfo.destructuringInfo.reassignedSiblings = true;\n                    }\n                }\n            }\n            else if (parent !== undefined) {\n                // if the reassigned variable was not declared in this scope we defer to the parent scope\n                parent.reassigned.add(name);\n            }\n        });\n        reassigned.clear();\n    };\n    PreferConstWalker.prototype.onScopeEnd = function (parent) {\n        var _this = this;\n        this.settle(parent);\n        var appliedFixes = new Set();\n        this.scope.variables.forEach(function (info, name) {\n            if (info.declarationInfo.canBeConst &&\n                !info.reassigned &&\n                // don't add failures for reassigned variables in for loop initializer\n                !(info.declarationInfo.reassignedSiblings && info.declarationInfo.isForLoop) &&\n                // if {destructuring: \"all\"} is set, only add a failure if all variables in a destructuring assignment can be const\n                (!_this.options.destructuringAll ||\n                    info.destructuringInfo === undefined ||\n                    !info.destructuringInfo.reassignedSiblings)) {\n                var fix = void 0;\n                // only apply fixes if the VariableDeclarationList has no reassigned variables\n                // and the variable is block scoped aka `let` and initialized\n                if (info.declarationInfo.allInitialized &&\n                    !info.declarationInfo.reassignedSiblings &&\n                    info.declarationInfo.isBlockScoped &&\n                    !appliedFixes.has(info.declarationInfo.declarationList)) {\n                    fix = new Lint.Replacement(info.declarationInfo.declarationList.getStart(_this.sourceFile), 3, \"const\");\n                    // add only one fixer per VariableDeclarationList\n                    appliedFixes.add(info.declarationInfo.declarationList);\n                }\n                _this.addFailureAtNode(info.identifier, Rule.FAILURE_STRING_FACTORY(name, info.declarationInfo.isBlockScoped), fix);\n            }\n        });\n    };\n    return PreferConstWalker;\n}(Lint.AbstractWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/trailingCommaRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new TrailingCommaWalker(sourceFile, this.ruleName, this.ruleArguments[0]));\n    };\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && this.ruleArguments.length !== 0;\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"trailing-comma\",\n    description: (_a = [\"\\n            Requires or disallows trailing commas in array and object literals, destructuring assignments, function typings,\\n            named imports and exports and function parameters.\"], _a.raw = [\"\\n            Requires or disallows trailing commas in array and object literals, destructuring assignments, function typings,\\n            named imports and exports and function parameters.\"], Lint.Utils.dedent(_a)),\n    hasFix: true,\n    optionsDescription: (_b = [\"\\n            One argument which is an object with the keys `multiline` and `singleline`.\\n            Both should be set to either `\\\"always\\\"` or `\\\"never\\\"`.\\n\\n            * `\\\"multiline\\\"` checks multi-line object literals.\\n            * `\\\"singleline\\\"` checks single-line object literals.\\n\\n            A array is considered \\\"multiline\\\" if its closing bracket is on a line\\n            after the last array element. The same general logic is followed for\\n            object literals, function typings, named import statements\\n            and function parameters.\"], _b.raw = [\"\\n            One argument which is an object with the keys \\\\`multiline\\\\` and \\\\`singleline\\\\`.\\n            Both should be set to either \\\\`\\\"always\\\"\\\\` or \\\\`\\\"never\\\"\\\\`.\\n\\n            * \\\\`\\\"multiline\\\"\\\\` checks multi-line object literals.\\n            * \\\\`\\\"singleline\\\"\\\\` checks single-line object literals.\\n\\n            A array is considered \\\"multiline\\\" if its closing bracket is on a line\\n            after the last array element. The same general logic is followed for\\n            object literals, function typings, named import statements\\n            and function parameters.\"], Lint.Utils.dedent(_b)),\n    options: {\n        type: \"object\",\n        properties: {\n            multiline: {\n                type: \"string\",\n                enum: [\"always\", \"never\"],\n            },\n            singleline: {\n                type: \"string\",\n                enum: [\"always\", \"never\"],\n            },\n        },\n        additionalProperties: false,\n    },\n    optionExamples: ['[true, {\"multiline\": \"always\", \"singleline\": \"never\"}]'],\n    type: \"maintainability\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_NEVER = \"Unnecessary trailing comma\";\nRule.FAILURE_STRING_ALWAYS = \"Missing trailing comma\";\nexports.Rule = Rule;\nvar TrailingCommaWalker = (function (_super) {\n    __extends(TrailingCommaWalker, _super);\n    function TrailingCommaWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TrailingCommaWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            switch (node.kind) {\n                case ts.SyntaxKind.ArrayLiteralExpression:\n                case ts.SyntaxKind.ArrayBindingPattern:\n                case ts.SyntaxKind.ObjectBindingPattern:\n                case ts.SyntaxKind.NamedImports:\n                case ts.SyntaxKind.NamedExports:\n                    _this.checkList(node.elements, node.end);\n                    break;\n                case ts.SyntaxKind.ObjectLiteralExpression:\n                    _this.checkList(node.properties, node.end);\n                    break;\n                case ts.SyntaxKind.EnumDeclaration:\n                    _this.checkList(node.members, node.end);\n                    break;\n                case ts.SyntaxKind.NewExpression:\n                    if (node.arguments === undefined) {\n                        break;\n                    }\n                // falls through\n                case ts.SyntaxKind.CallExpression:\n                    _this.checkList(node.arguments, node.end);\n                    break;\n                case ts.SyntaxKind.ArrowFunction:\n                case ts.SyntaxKind.Constructor:\n                case ts.SyntaxKind.FunctionDeclaration:\n                case ts.SyntaxKind.FunctionExpression:\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.SetAccessor:\n                case ts.SyntaxKind.MethodSignature:\n                case ts.SyntaxKind.ConstructSignature:\n                case ts.SyntaxKind.ConstructorType:\n                case ts.SyntaxKind.FunctionType:\n                case ts.SyntaxKind.CallSignature:\n                    _this.checkListWithEndToken(node, node.parameters, ts.SyntaxKind.CloseParenToken);\n                    break;\n                case ts.SyntaxKind.TypeLiteral:\n                    _this.checkTypeLiteral(node);\n                    break;\n                default:\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    TrailingCommaWalker.prototype.checkTypeLiteral = function (node) {\n        var members = node.members;\n        if (members.length === 0) {\n            return;\n        }\n        var sourceText = this.sourceFile.text;\n        for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n            var member = members_1[_i];\n            // PropertySignature in TypeLiteral can end with semicolon or comma. If one ends with a semicolon don't check for trailing comma\n            if (sourceText[member.end - 1] === \";\") {\n                return;\n            }\n        }\n        // The trailing comma is part of the last member and therefore not present as hasTrailingComma on the NodeArray\n        var hasTrailingComma = sourceText[members.end - 1] === \",\";\n        return this.checkComma(hasTrailingComma, members, node.end);\n    };\n    TrailingCommaWalker.prototype.checkListWithEndToken = function (node, list, closeTokenKind) {\n        if (list.length === 0) {\n            return;\n        }\n        var token = tsutils_1.getChildOfKind(node, closeTokenKind, this.sourceFile);\n        if (token !== undefined) {\n            return this.checkComma(list.hasTrailingComma, list, token.end);\n        }\n    };\n    TrailingCommaWalker.prototype.checkList = function (list, closeElementPos) {\n        if (list.length === 0) {\n            return;\n        }\n        return this.checkComma(list.hasTrailingComma, list, closeElementPos);\n    };\n    /* Expects `list.length !== 0` */\n    TrailingCommaWalker.prototype.checkComma = function (hasTrailingComma, list, closeTokenPos) {\n        var lastElementLine = ts.getLineAndCharacterOfPosition(this.sourceFile, list[list.length - 1].end).line;\n        var closeTokenLine = ts.getLineAndCharacterOfPosition(this.sourceFile, closeTokenPos).line;\n        var option = lastElementLine === closeTokenLine ? this.options.singleline : this.options.multiline;\n        if (hasTrailingComma && option === \"never\") {\n            this.addFailureAt(list.end - 1, 1, Rule.FAILURE_STRING_NEVER, Lint.Replacement.deleteText(list.end - 1, 1));\n        }\n        else if (!hasTrailingComma && option === \"always\") {\n            this.addFailureAt(list.end, 0, Rule.FAILURE_STRING_ALWAYS, Lint.Replacement.appendText(list.end, \",\"));\n        }\n    };\n    return TrailingCommaWalker;\n}(Lint.AbstractWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/alignRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new AlignWalker(sourceFile, this.ruleName, {\n            arguments: this.ruleArguments.indexOf(Rule.ARGUMENTS_OPTION) !== -1,\n            parameters: this.ruleArguments.indexOf(Rule.PARAMETERS_OPTION) !== -1,\n            statements: this.ruleArguments.indexOf(Rule.STATEMENTS_OPTION) !== -1,\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"align\",\n    description: \"Enforces vertical alignment.\",\n    hasFix: true,\n    rationale: \"Helps maintain a readable, consistent style in your codebase.\",\n    optionsDescription: (_a = [\"\\n            Three arguments may be optionally provided:\\n\\n            * `\\\"parameters\\\"` checks alignment of function parameters.\\n            * `\\\"arguments\\\"` checks alignment of function call arguments.\\n            * `\\\"statements\\\"` checks alignment of statements.\"], _a.raw = [\"\\n            Three arguments may be optionally provided:\\n\\n            * \\\\`\\\"parameters\\\"\\\\` checks alignment of function parameters.\\n            * \\\\`\\\"arguments\\\"\\\\` checks alignment of function call arguments.\\n            * \\\\`\\\"statements\\\"\\\\` checks alignment of statements.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [\"arguments\", \"parameters\", \"statements\"],\n        },\n        minLength: 1,\n        maxLength: 3,\n    },\n    optionExamples: ['[true, \"parameters\", \"statements\"]'],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.PARAMETERS_OPTION = \"parameters\";\nRule.ARGUMENTS_OPTION = \"arguments\";\nRule.STATEMENTS_OPTION = \"statements\";\nRule.FAILURE_STRING_SUFFIX = \" are not aligned\";\nexports.Rule = Rule;\nvar AlignWalker = (function (_super) {\n    __extends(AlignWalker, _super);\n    function AlignWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AlignWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (_this.options.statements && utils.isBlockLike(node)) {\n                _this.checkAlignment(node.statements, Rule.STATEMENTS_OPTION);\n            }\n            else if (_this.options.parameters) {\n                switch (node.kind) {\n                    case ts.SyntaxKind.FunctionDeclaration:\n                    case ts.SyntaxKind.FunctionExpression:\n                    case ts.SyntaxKind.Constructor:\n                    case ts.SyntaxKind.MethodDeclaration:\n                    case ts.SyntaxKind.ArrowFunction:\n                    case ts.SyntaxKind.CallSignature:\n                    case ts.SyntaxKind.ConstructSignature:\n                    case ts.SyntaxKind.MethodSignature:\n                    case ts.SyntaxKind.FunctionType:\n                    case ts.SyntaxKind.ConstructorType:\n                        _this.checkAlignment(node.parameters, Rule.PARAMETERS_OPTION);\n                }\n            }\n            else if (_this.options.arguments &&\n                (node.kind === ts.SyntaxKind.CallExpression ||\n                    node.kind === ts.SyntaxKind.NewExpression && node.arguments !== undefined)) {\n                _this.checkAlignment(node.arguments, Rule.ARGUMENTS_OPTION);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return cb(sourceFile);\n    };\n    AlignWalker.prototype.checkAlignment = function (nodes, kind) {\n        if (nodes.length <= 1) {\n            return;\n        }\n        var sourceFile = this.sourceFile;\n        var pos = ts.getLineAndCharacterOfPosition(sourceFile, nodes[0].getStart(sourceFile));\n        var alignToColumn = pos.character;\n        var line = pos.line;\n        // skip first node in list\n        for (var i = 1; i < nodes.length; ++i) {\n            var node = nodes[i];\n            var start = node.getStart(sourceFile);\n            pos = ts.getLineAndCharacterOfPosition(sourceFile, start);\n            if (line !== pos.line && pos.character !== alignToColumn) {\n                var diff = alignToColumn - pos.character;\n                var fix = void 0;\n                if (0 < diff) {\n                    fix = Lint.Replacement.appendText(start, \" \".repeat(diff));\n                }\n                else if (node.pos <= start + diff && /^\\s+$/.test(sourceFile.text.substring(start + diff, start))) {\n                    // only delete text if there is only whitespace\n                    fix = Lint.Replacement.deleteText(start + diff, -diff);\n                }\n                this.addFailure(start, node.end, kind + Rule.FAILURE_STRING_SUFFIX, fix);\n            }\n            line = pos.line;\n        }\n    };\n    return AlignWalker;\n}(Lint.AbstractWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/arrayTypeRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ARRAY = \"array\";\nvar OPTION_GENERIC = \"generic\";\nvar OPTION_ARRAY_SIMPLE = \"array-simple\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.ruleArguments[0]);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"array-type\",\n    description: \"Requires using either 'T[]' or 'Array<T>' for arrays.\",\n    hasFix: true,\n    optionsDescription: (_a = [\"\\n            One of the following arguments must be provided:\\n\\n            * `\\\"\", \"\\\"` enforces use of `T[]` for all types T.\\n            * `\\\"\", \"\\\"` enforces use of `Array<T>` for all types T.\\n            * `\\\"\", \"\\\"` enforces use of `T[]` if `T` is a simple type (primitive or type reference).\"], _a.raw = [\"\\n            One of the following arguments must be provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces use of \\\\`T[]\\\\` for all types T.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces use of \\\\`Array<T>\\\\` for all types T.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces use of \\\\`T[]\\\\` if \\\\`T\\\\` is a simple type (primitive or type reference).\"], Lint.Utils.dedent(_a, OPTION_ARRAY, OPTION_GENERIC, OPTION_ARRAY_SIMPLE)),\n    options: {\n        type: \"string\",\n        enum: [OPTION_ARRAY, OPTION_GENERIC, OPTION_ARRAY_SIMPLE],\n    },\n    optionExamples: [\"[true, \\\"\" + OPTION_ARRAY + \"\\\"]\", \"[true, \\\"\" + OPTION_GENERIC + \"\\\"]\", \"[true, \\\"\" + OPTION_ARRAY_SIMPLE + \"\\\"]\"],\n    type: \"style\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_ARRAY = \"Array type using 'Array<T>' is forbidden. Use 'T[]' instead.\";\nRule.FAILURE_STRING_GENERIC = \"Array type using 'T[]' is forbidden. Use 'Array<T>' instead.\";\nRule.FAILURE_STRING_ARRAY_SIMPLE = \"Array type using 'Array<T>' is forbidden for simple types. Use 'T[]' instead.\";\nRule.FAILURE_STRING_GENERIC_SIMPLE = \"Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, option = ctx.options;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ArrayType:\n                checkArrayType(node);\n                break;\n            case ts.SyntaxKind.TypeReference:\n                checkTypeReference(node);\n                break;\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkArrayType(node) {\n        var elementType = node.elementType, parent = node.parent;\n        if (option === \"array\" || option === \"array-simple\" && isSimpleType(elementType)) {\n            return;\n        }\n        var failureString = option === \"generic\" ? Rule.FAILURE_STRING_GENERIC : Rule.FAILURE_STRING_GENERIC_SIMPLE;\n        var parens = elementType.kind === ts.SyntaxKind.ParenthesizedType ? 1 : 0;\n        // Add a space if the type is preceded by 'as' and the node has no leading whitespace\n        var space = !parens && parent.kind === ts.SyntaxKind.AsExpression && node.getStart() === node.getFullStart();\n        var fix = [\n            new Lint.Replacement(elementType.getStart(), parens, (space ? \" \" : \"\") + \"Array<\"),\n            // Delete the square brackets and replace with an angle bracket\n            Lint.Replacement.replaceFromTo(elementType.getEnd() - parens, node.getEnd(), \">\"),\n        ];\n        ctx.addFailureAtNode(node, failureString, fix);\n    }\n    function checkTypeReference(node) {\n        var typeName = node.typeName, typeArguments = node.typeArguments;\n        if (option === \"generic\" || !isArrayIdentifier(typeName)) {\n            return;\n        }\n        var failureString = option === \"array\" ? Rule.FAILURE_STRING_ARRAY : Rule.FAILURE_STRING_ARRAY_SIMPLE;\n        if (!typeArguments || typeArguments.length === 0) {\n            // Create an 'any' array\n            var fix_1 = Lint.Replacement.replaceFromTo(node.getStart(), node.getEnd(), \"any[]\");\n            ctx.addFailureAtNode(node, failureString, fix_1);\n            return;\n        }\n        if (typeArguments.length !== 1 || (option === \"array-simple\" && !isSimpleType(typeArguments[0]))) {\n            return;\n        }\n        var type = typeArguments[0];\n        var parens = typeNeedsParentheses(type);\n        var fix = [\n            // Delete 'Array<'\n            Lint.Replacement.replaceFromTo(node.getStart(), type.getStart(), parens ? \"(\" : \"\"),\n            // Delete '>' and replace with '[]\n            Lint.Replacement.replaceFromTo(type.getEnd(), node.getEnd(), parens ? \")[]\" : \"[]\"),\n        ];\n        ctx.addFailureAtNode(node, failureString, fix);\n    }\n}\nfunction typeNeedsParentheses(type) {\n    switch (type.kind) {\n        case ts.SyntaxKind.UnionType:\n        case ts.SyntaxKind.FunctionType:\n        case ts.SyntaxKind.IntersectionType:\n        case ts.SyntaxKind.TypeOperator:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isArrayIdentifier(name) {\n    return name.kind === ts.SyntaxKind.Identifier && name.text === \"Array\";\n}\nfunction isSimpleType(nodeType) {\n    switch (nodeType.kind) {\n        case ts.SyntaxKind.AnyKeyword:\n        case ts.SyntaxKind.ArrayType:\n        case ts.SyntaxKind.BooleanKeyword:\n        case ts.SyntaxKind.NullKeyword:\n        case ts.SyntaxKind.ObjectKeyword:\n        case ts.SyntaxKind.UndefinedKeyword:\n        case ts.SyntaxKind.NumberKeyword:\n        case ts.SyntaxKind.StringKeyword:\n        case ts.SyntaxKind.SymbolKeyword:\n        case ts.SyntaxKind.VoidKeyword:\n        case ts.SyntaxKind.NeverKeyword:\n            return true;\n        case ts.SyntaxKind.TypeReference:\n            // TypeReferences must be non-generic or be another Array with a simple type\n            var _a = nodeType, typeName = _a.typeName, typeArguments = _a.typeArguments;\n            if (!typeArguments) {\n                return true;\n            }\n            switch (typeArguments.length) {\n                case 0:\n                    return true;\n                case 1:\n                    return typeName.kind === ts.SyntaxKind.Identifier && typeName.text === \"Array\" && isSimpleType(typeArguments[0]);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/arrowParensRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar BAN_SINGLE_ARG_PARENS = \"ban-single-arg-parens\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, {\n            banSingleArgParens: this.ruleArguments.indexOf(BAN_SINGLE_ARG_PARENS) !== -1,\n        });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"arrow-parens\",\n    description: \"Requires parentheses around the parameters of arrow function definitions.\",\n    hasFix: true,\n    rationale: \"Maintains stylistic consistency with other arrow function definitions.\",\n    optionsDescription: (_a = [\"\\n            If `\", \"` is specified, then arrow functions with one parameter\\n            must not have parentheses if removing them is allowed by TypeScript.\"], _a.raw = [\"\\n            If \\\\`\", \"\\\\` is specified, then arrow functions with one parameter\\n            must not have parentheses if removing them is allowed by TypeScript.\"], Lint.Utils.dedent(_a, BAN_SINGLE_ARG_PARENS)),\n    options: {\n        type: \"string\",\n        enum: [BAN_SINGLE_ARG_PARENS],\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + BAN_SINGLE_ARG_PARENS + \"\\\"]\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_MISSING = \"Parentheses are required around the parameters of an arrow function definition\";\nRule.FAILURE_STRING_EXISTS = \"Parentheses are prohibited around the parameter in this single parameter arrow function\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    function cb(node) {\n        if (tsutils_1.isArrowFunction(node) && parensAreOptional(node)) {\n            var openParen = tsutils_1.getChildOfKind(node, ts.SyntaxKind.OpenParenToken);\n            if (openParen === undefined) {\n                if (!ctx.options.banSingleArgParens) {\n                    var parameter = node.parameters[0];\n                    var start = parameter.getStart(ctx.sourceFile);\n                    var end = parameter.end;\n                    ctx.addFailure(start, end, Rule.FAILURE_STRING_MISSING, [\n                        Lint.Replacement.appendText(start, \"(\"),\n                        Lint.Replacement.appendText(end, \")\"),\n                    ]);\n                }\n            }\n            else if (ctx.options.banSingleArgParens) {\n                var closeParen = tsutils_1.getChildOfKind(node, ts.SyntaxKind.CloseParenToken);\n                ctx.addFailureAtNode(node.parameters[0], Rule.FAILURE_STRING_EXISTS, [\n                    Lint.Replacement.deleteText(openParen.end - 1, 1),\n                    Lint.Replacement.deleteText(closeParen.end - 1, 1),\n                ]);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    }\n    return ts.forEachChild(ctx.sourceFile, cb);\n}\nfunction parensAreOptional(node) {\n    return node.parameters.length === 1 &&\n        node.typeParameters === undefined &&\n        node.type === undefined &&\n        isSimpleParameter(node.parameters[0]);\n}\nfunction isSimpleParameter(parameter) {\n    return parameter.name.kind === ts.SyntaxKind.Identifier\n        && parameter.dotDotDotToken === undefined\n        && parameter.initializer === undefined\n        && parameter.questionToken === undefined\n        && parameter.type === undefined;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/arrowReturnShorthandRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../language/utils\");\nvar OPTION_MULTILINE = \"multiline\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (isObjectLiteral) {\n        var start = \"This arrow function body can be simplified by omitting the curly braces and the keyword 'return'\";\n        return start + (isObjectLiteral ? \", and wrapping the object literal in parentheses.\" : \".\");\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, { multiline: this.ruleArguments.indexOf(OPTION_MULTILINE) !== -1 });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"arrow-return-shorthand\",\n    description: \"Suggests to convert `() => { return x; }` to `() => x`.\",\n    hasFix: true,\n    optionsDescription: (_a = [\"\\n            If `\", \"` is specified, then this will warn even if the function spans multiple lines.\"], _a.raw = [\"\\n            If \\\\`\", \"\\\\` is specified, then this will warn even if the function spans multiple lines.\"], Lint.Utils.dedent(_a, OPTION_MULTILINE)),\n    options: {\n        type: \"string\",\n        enum: [OPTION_MULTILINE],\n    },\n    optionExamples: [\n        \"[true]\",\n        \"[true, \\\"\" + OPTION_MULTILINE + \"\\\"]\",\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, multiline = ctx.options.multiline;\n    ts.forEachChild(sourceFile, function cb(node) {\n        if (utils.isArrowFunction(node) && utils.isBlock(node.body)) {\n            var expr = getSimpleReturnExpression(node.body);\n            if (expr !== undefined && (multiline || !node.body.getText(sourceFile).includes(\"\\n\"))) {\n                var isObjectLiteral = expr.kind === ts.SyntaxKind.ObjectLiteralExpression;\n                ctx.addFailureAtNode(node.body, Rule.FAILURE_STRING(isObjectLiteral), createFix(node, node.body, expr, sourceFile.text));\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction createFix(arrowFunction, body, expr, text) {\n    var statement = expr.parent;\n    var returnKeyword = Lint.childOfKind(statement, ts.SyntaxKind.ReturnKeyword);\n    var arrow = Lint.childOfKind(arrowFunction, ts.SyntaxKind.EqualsGreaterThanToken);\n    var openBrace = Lint.childOfKind(body, ts.SyntaxKind.OpenBraceToken);\n    var closeBrace = Lint.childOfKind(body, ts.SyntaxKind.CloseBraceToken);\n    var semicolon = Lint.childOfKind(statement, ts.SyntaxKind.SemicolonToken);\n    var anyComments = hasComments(arrow) || hasComments(openBrace) || hasComments(statement) || hasComments(returnKeyword) ||\n        hasComments(expr) || (semicolon && hasComments(semicolon)) || hasComments(closeBrace);\n    return anyComments ? undefined : (expr.kind === ts.SyntaxKind.ObjectLiteralExpression ? [\n        Lint.Replacement.appendText(expr.getStart(), \"(\"),\n        Lint.Replacement.appendText(expr.getEnd(), \")\"),\n    ] : []).concat([\n        // \" {\"\n        Lint.Replacement.deleteFromTo(arrow.end, openBrace.end),\n        // \"return \"\n        Lint.Replacement.deleteFromTo(statement.getStart(), expr.getStart()),\n        // \" }\" (may include semicolon)\n        Lint.Replacement.deleteFromTo(expr.end, closeBrace.end),\n    ]);\n    function hasComments(node) {\n        return utils_1.hasCommentAfterPosition(text, node.getEnd());\n    }\n}\n/** Given `{ return x; }`, return `x`. */\nfunction getSimpleReturnExpression(block) {\n    return block.statements.length === 1 && block.statements[0].kind === ts.SyntaxKind.ReturnStatement\n        ? block.statements[0].expression\n        : undefined;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/callableTypesRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.failureStringForInterface = function (name, sigSuggestion) {\n        return \"Interface has only a call signature \\u2014 use `type \" + name + \" = \" + sigSuggestion + \"` instead.\";\n    };\n    Rule.failureStringForTypeLiteral = function (sigSuggestion) {\n        return \"Type literal has only a call signature \\u2014 use `\" + sigSuggestion + \"` instead.\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"callable-types\",\n    description: \"An interface or literal type with just a call signature can be written as a function type.\",\n    rationale: \"style\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    type: \"style\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitInterfaceDeclaration = function (node) {\n        if (noSupertype(node.heritageClauses)) {\n            this.check(node);\n        }\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    Walker.prototype.visitTypeLiteral = function (node) {\n        this.check(node);\n        _super.prototype.visitTypeLiteral.call(this, node);\n    };\n    Walker.prototype.check = function (node) {\n        if (node.members.length === 1 && node.members[0].kind === ts.SyntaxKind.CallSignature) {\n            var call = node.members[0];\n            if (!call.type) {\n                // Bad parse\n                return;\n            }\n            var suggestion = renderSuggestion(call);\n            if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {\n                this.addFailureAtNode(node.name, Rule.failureStringForInterface(node.name.getText(), suggestion));\n            }\n            else {\n                this.addFailureAtNode(call, Rule.failureStringForTypeLiteral(suggestion));\n            }\n        }\n    };\n    return Walker;\n}(Lint.RuleWalker));\n/** True if there is no supertype or if the supertype is `Function`. */\nfunction noSupertype(heritageClauses) {\n    if (!heritageClauses) {\n        return true;\n    }\n    if (heritageClauses.length === 1) {\n        var expr = heritageClauses[0].types[0].expression;\n        if (expr.kind === ts.SyntaxKind.Identifier && expr.text === \"Function\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction renderSuggestion(call) {\n    var typeParameters = call.typeParameters && call.typeParameters.map(function (p) { return p.getText(); }).join(\", \");\n    var parameters = call.parameters.map(function (p) { return p.getText(); }).join(\", \");\n    var returnType = call.type === undefined ? \"void\" : call.type.getText();\n    var res = \"(\" + parameters + \") => \" + returnType;\n    if (typeParameters) {\n        res = \"<\" + typeParameters + \">\" + res;\n    }\n    return res;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/classNameRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NameWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"class-name\",\n    description: \"Enforces PascalCased class and interface names.\",\n    rationale: \"Makes it easy to differentiate classes from regular variables at a glance.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Class name must be in pascal case\";\nexports.Rule = Rule;\nvar NameWalker = (function (_super) {\n    __extends(NameWalker, _super);\n    function NameWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NameWalker.prototype.visitClassDeclaration = function (node) {\n        // classes declared as default exports will be unnamed\n        if (node.name != null) {\n            var className = node.name.getText();\n            if (!this.isPascalCased(className)) {\n                this.addFailureAtNode(node.name, Rule.FAILURE_STRING);\n            }\n        }\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    NameWalker.prototype.visitInterfaceDeclaration = function (node) {\n        var interfaceName = node.name.getText();\n        if (!this.isPascalCased(interfaceName)) {\n            this.addFailureAtNode(node.name, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    NameWalker.prototype.isPascalCased = function (name) {\n        if (name.length <= 0) {\n            return true;\n        }\n        var firstCharacter = name.charAt(0);\n        return ((firstCharacter === firstCharacter.toUpperCase()) && name.indexOf(\"_\") === -1);\n    };\n    return NameWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/commentFormatRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../utils\");\nvar OPTION_SPACE = \"check-space\";\nvar OPTION_LOWERCASE = \"check-lowercase\";\nvar OPTION_UPPERCASE = \"check-uppercase\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new CommentWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"comment-format\",\n    description: \"Enforces formatting rules for single-line comments.\",\n    rationale: \"Helps maintain a consistent, readable style in your codebase.\",\n    optionsDescription: (_a = [\"\\n            Three arguments may be optionally provided:\\n\\n            * `\\\"check-space\\\"` requires that all single-line comments must begin with a space, as in `// comment`\\n                * note that comments starting with `///` are also allowed, for things such as `///<reference>`\\n            * `\\\"check-lowercase\\\"` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\\n            * `\\\"check-uppercase\\\"` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\\n\\n            Exceptions to `\\\"check-lowercase\\\"` or `\\\"check-uppercase\\\"` can be managed with object that may be passed as last argument.\\n\\n            One of two options can be provided in this object:\\n\\n                * `\\\"ignore-words\\\"`  - array of strings - words that will be ignored at the beginning of the comment.\\n                * `\\\"ignore-pattern\\\"` - string - RegExp pattern that will be ignored at the beginning of the comment.\\n            \"], _a.raw = [\"\\n            Three arguments may be optionally provided:\\n\\n            * \\\\`\\\"check-space\\\"\\\\` requires that all single-line comments must begin with a space, as in \\\\`// comment\\\\`\\n                * note that comments starting with \\\\`///\\\\` are also allowed, for things such as \\\\`///<reference>\\\\`\\n            * \\\\`\\\"check-lowercase\\\"\\\\` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\\n            * \\\\`\\\"check-uppercase\\\"\\\\` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\\n\\n            Exceptions to \\\\`\\\"check-lowercase\\\"\\\\` or \\\\`\\\"check-uppercase\\\"\\\\` can be managed with object that may be passed as last argument.\\n\\n            One of two options can be provided in this object:\\n\\n                * \\\\`\\\"ignore-words\\\"\\\\`  - array of strings - words that will be ignored at the beginning of the comment.\\n                * \\\\`\\\"ignore-pattern\\\"\\\\` - string - RegExp pattern that will be ignored at the beginning of the comment.\\n            \"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            anyOf: [\n                {\n                    type: \"string\",\n                    enum: [\n                        \"check-space\",\n                        \"check-lowercase\",\n                        \"check-uppercase\",\n                    ],\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        \"ignore-words\": {\n                            type: \"array\",\n                            items: {\n                                type: \"string\",\n                            },\n                        },\n                        \"ignore-pattern\": {\n                            type: \"string\",\n                        },\n                    },\n                    minProperties: 1,\n                    maxProperties: 1,\n                },\n            ],\n        },\n        minLength: 1,\n        maxLength: 4,\n    },\n    optionExamples: [\n        '[true, \"check-space\", \"check-uppercase\"]',\n        '[true, \"check-lowercase\", {\"ignore-words\": [\"TODO\", \"HACK\"]}]',\n        '[true, \"check-lowercase\", {\"ignore-pattern\": \"STD\\\\w{2,3}\\\\b\"}]',\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.LOWERCASE_FAILURE = \"comment must start with lowercase letter\";\nRule.UPPERCASE_FAILURE = \"comment must start with uppercase letter\";\nRule.LEADING_SPACE_FAILURE = \"comment must start with a space\";\nRule.IGNORE_WORDS_FAILURE_FACTORY = function (words) { return \" or the word(s): \" + words.join(\", \"); };\nRule.IGNORE_PATTERN_FAILURE_FACTORY = function (pattern) { return \" or its start must match the regex pattern \\\"\" + pattern + \"\\\"\"; };\nexports.Rule = Rule;\nvar CommentWalker = (function (_super) {\n    __extends(CommentWalker, _super);\n    function CommentWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.failureIgnorePart = \"\";\n        _this.exceptionsRegExp = _this.composeExceptionsRegExp();\n        return _this;\n    }\n    CommentWalker.prototype.visitSourceFile = function (node) {\n        var _this = this;\n        utils.forEachComment(node, function (fullText, comment) {\n            if (comment.kind === ts.SyntaxKind.SingleLineCommentTrivia) {\n                var commentText = fullText.substring(comment.pos, comment.end);\n                var startPosition = comment.pos + 2;\n                var width = commentText.length - 2;\n                if (_this.hasOption(OPTION_SPACE)) {\n                    if (!startsWithSpace(commentText)) {\n                        _this.addFailureAt(startPosition, width, Rule.LEADING_SPACE_FAILURE);\n                    }\n                }\n                if (_this.hasOption(OPTION_LOWERCASE)) {\n                    if (!startsWithLowercase(commentText) && !_this.startsWithException(commentText)) {\n                        _this.addFailureAt(startPosition, width, Rule.LOWERCASE_FAILURE + _this.failureIgnorePart);\n                    }\n                }\n                if (_this.hasOption(OPTION_UPPERCASE)) {\n                    if (!startsWithUppercase(commentText) && !isEnableDisableFlag(commentText) && !_this.startsWithException(commentText)) {\n                        _this.addFailureAt(startPosition, width, Rule.UPPERCASE_FAILURE + _this.failureIgnorePart);\n                    }\n                }\n            }\n        });\n    };\n    CommentWalker.prototype.startsWithException = function (commentText) {\n        if (this.exceptionsRegExp == null) {\n            return false;\n        }\n        return this.exceptionsRegExp.test(commentText);\n    };\n    CommentWalker.prototype.composeExceptionsRegExp = function () {\n        var optionsList = this.getOptions();\n        var exceptionsObject = optionsList[optionsList.length - 1];\n        // early return if last element is string instead of exceptions object\n        if (typeof exceptionsObject === \"string\" || !exceptionsObject) {\n            return null;\n        }\n        if (exceptionsObject[\"ignore-pattern\"]) {\n            var ignorePattern = exceptionsObject[\"ignore-pattern\"];\n            this.failureIgnorePart = Rule.IGNORE_PATTERN_FAILURE_FACTORY(ignorePattern);\n            // regex is \"start of string\"//\"any amount of whitespace\" followed by user provided ignore pattern\n            return new RegExp(\"^//\\\\s*(\" + ignorePattern + \")\");\n        }\n        if (exceptionsObject[\"ignore-words\"]) {\n            var ignoreWords = exceptionsObject[\"ignore-words\"];\n            this.failureIgnorePart = Rule.IGNORE_WORDS_FAILURE_FACTORY(ignoreWords);\n            // Converts all exceptions values to strings, trim whitespace, escapes RegExp special characters and combines into alternation\n            var wordsPattern = ignoreWords\n                .map(String)\n                .map(function (str) { return str.trim(); })\n                .map(utils_1.escapeRegExp)\n                .join(\"|\");\n            // regex is \"start of string\"//\"any amount of whitespace\"(\"any word from ignore list\") followed by non alphanumeric character\n            return new RegExp(\"^//\\\\s*(\" + wordsPattern + \")\\\\b\");\n        }\n        return null;\n    };\n    return CommentWalker;\n}(Lint.RuleWalker));\nfunction startsWith(commentText, changeCase) {\n    if (commentText.length <= 2) {\n        return true; // comment is \"//\"? Technically not a violation.\n    }\n    // regex is \"start of string\"//\"any amount of whitespace\"(\"word character\")\n    var firstCharacterMatch = commentText.match(/^\\/\\/\\s*(\\w)/);\n    if (firstCharacterMatch != null) {\n        // the first group matched, i.e. the thing in the parens, is the first non-space character, if it's alphanumeric\n        var firstCharacter = firstCharacterMatch[1];\n        return firstCharacter === changeCase(firstCharacter);\n    }\n    else {\n        // first character isn't alphanumeric/doesn't exist? Technically not a violation\n        return true;\n    }\n}\nfunction startsWithLowercase(commentText) {\n    return startsWith(commentText, function (c) { return c.toLowerCase(); });\n}\nfunction startsWithUppercase(commentText) {\n    return startsWith(commentText, function (c) { return c.toUpperCase(); });\n}\nfunction startsWithSpace(commentText) {\n    if (commentText.length <= 2) {\n        return true; // comment is \"//\"? Technically not a violation.\n    }\n    var commentBody = commentText.substring(2);\n    // whitelist //#region and //#endregion\n    if ((/^#(end)?region/).test(commentBody)) {\n        return true;\n    }\n    // whitelist JetBrains IDEs' \"//noinspection ...\"\n    if ((/^noinspection\\s/).test(commentBody)) {\n        return true;\n    }\n    var firstCharacter = commentBody.charAt(0);\n    // three slashes (///) also works, to allow for ///<reference>\n    return firstCharacter === \" \" || firstCharacter === \"/\";\n}\nfunction isEnableDisableFlag(commentText) {\n    // regex is: start of string followed by \"/*\" or \"//\"\n    // followed by any amount of whitespace followed by \"tslint:\"\n    // followed by either \"enable\" or \"disable\"\n    return /^(\\/\\*|\\/\\/)\\s*tslint:(enable|disable)/.test(commentText);\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/completedDocsRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nexports.ALL = \"all\";\nexports.ARGUMENT_CLASSES = \"classes\";\nexports.ARGUMENT_ENUMS = \"enums\";\nexports.ARGUMENT_FUNCTIONS = \"functions\";\nexports.ARGUMENT_INTERFACES = \"interfaces\";\nexports.ARGUMENT_METHODS = \"methods\";\nexports.ARGUMENT_NAMESPACES = \"namespaces\";\nexports.ARGUMENT_PROPERTIES = \"properties\";\nexports.ARGUMENT_TYPES = \"types\";\nexports.ARGUMENT_VARIABLES = \"variables\";\nexports.DESCRIPTOR_LOCATIONS = \"locations\";\nexports.DESCRIPTOR_PRIVACIES = \"privacies\";\nexports.DESCRIPTOR_VISIBILITIES = \"visibilities\";\nexports.LOCATION_INSTANCE = \"instance\";\nexports.LOCATION_STATIC = \"static\";\nexports.PRIVACY_PRIVATE = \"private\";\nexports.PRIVACY_PROTECTED = \"protected\";\nexports.PRIVACY_PUBLIC = \"public\";\nexports.VISIBILITY_EXPORTED = \"exported\";\nexports.VISIBILITY_INTERNAL = \"internal\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var options = this.getOptions();\n        var completedDocsWalker = new CompletedDocsWalker(sourceFile, options, program);\n        completedDocsWalker.setRequirements(this.getRequirements(options.ruleArguments));\n        return this.applyWithWalker(completedDocsWalker);\n    };\n    Rule.prototype.getRequirements = function (ruleArguments) {\n        if (ruleArguments.length === 0) {\n            ruleArguments = Rule.defaultArguments;\n        }\n        return Requirement.constructRequirements(ruleArguments);\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\nRule.FAILURE_STRING_EXIST = \"Documentation must exist for \";\nRule.defaultArguments = [\n    exports.ARGUMENT_CLASSES,\n    exports.ARGUMENT_FUNCTIONS,\n    exports.ARGUMENT_METHODS,\n    exports.ARGUMENT_PROPERTIES,\n];\nRule.ARGUMENT_DESCRIPTOR_BLOCK = {\n    properties: (_a = {},\n        _a[exports.DESCRIPTOR_VISIBILITIES] = {\n            enum: [\n                exports.ALL,\n                exports.VISIBILITY_EXPORTED,\n                exports.VISIBILITY_INTERNAL,\n            ],\n            type: \"string\",\n        },\n        _a),\n    type: \"object\",\n};\nRule.ARGUMENT_DESCRIPTOR_CLASS = {\n    properties: (_b = {},\n        _b[exports.DESCRIPTOR_LOCATIONS] = {\n            enum: [\n                exports.ALL,\n                exports.LOCATION_INSTANCE,\n                exports.LOCATION_STATIC,\n            ],\n            type: \"string\",\n        },\n        _b[exports.DESCRIPTOR_PRIVACIES] = {\n            enum: [\n                exports.ALL,\n                exports.PRIVACY_PRIVATE,\n                exports.PRIVACY_PROTECTED,\n                exports.PRIVACY_PUBLIC,\n            ],\n            type: \"string\",\n        },\n        _b),\n    type: \"object\",\n};\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"completed-docs\",\n    description: \"Enforces documentation for important items be filled out.\",\n    optionsDescription: (_c = [\"\\n            `true` to enable for [\\\"\", \"\\\", \\\"\", \"\\\", \\\"\", \"\\\", \\\"\", \"\\\"],\\n            or an array with each item in one of two formats:\\n\\n            * `string` to enable for that type\\n            * `object` keying types to when their documentation is required:\\n                * `\\\"\", \"\\\"` and `\\\"\", \"\\\"` may specify:\\n                    * `\\\"\", \"\\\"`:\\n                        * `\\\"\", \"\\\"`\\n                        * `\\\"\", \"\\\"`\\n                        * `\\\"\", \"\\\"`\\n                        * `\\\"\", \"\\\"`\\n                    * `\\\"\", \"\\\"`:\\n                        * `\\\"\", \"\\\"`\\n                        * `\\\"\", \"\\\"`\\n                        * `\\\"\", \"\\\"`\\n                * All other types may specify `\\\"\", \"\\\"`:\\n                    * `\\\"\", \"\\\"`\\n                    * `\\\"\", \"\\\"`\\n                    * `\\\"\", \"\\\"`\\n\\n            Types that may be enabled are:\\n\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\\n                * `\\\"\", \"\\\"`\"], _c.raw = [\"\\n            \\\\`true\\\\` to enable for [\\\"\", \"\\\", \\\"\", \"\\\", \\\"\", \"\\\", \\\"\", \"\\\"],\\n            or an array with each item in one of two formats:\\n\\n            * \\\\`string\\\\` to enable for that type\\n            * \\\\`object\\\\` keying types to when their documentation is required:\\n                * \\\\`\\\"\", \"\\\"\\\\` and \\\\`\\\"\", \"\\\"\\\\` may specify:\\n                    * \\\\`\\\"\", \"\\\"\\\\`:\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                    * \\\\`\\\"\", \"\\\"\\\\`:\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                        * \\\\`\\\"\", \"\\\"\\\\`\\n                * All other types may specify \\\\`\\\"\", \"\\\"\\\\`:\\n                    * \\\\`\\\"\", \"\\\"\\\\`\\n                    * \\\\`\\\"\", \"\\\"\\\\`\\n                    * \\\\`\\\"\", \"\\\"\\\\`\\n\\n            Types that may be enabled are:\\n\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\\n                * \\\\`\\\"\", \"\\\"\\\\`\"], Lint.Utils.dedent(_c, exports.ARGUMENT_CLASSES, exports.ARGUMENT_FUNCTIONS, exports.ARGUMENT_METHODS, exports.ARGUMENT_PROPERTIES, exports.ARGUMENT_METHODS, exports.ARGUMENT_PROPERTIES, exports.DESCRIPTOR_PRIVACIES, exports.ALL, exports.PRIVACY_PRIVATE, exports.PRIVACY_PROTECTED, exports.PRIVACY_PUBLIC, exports.DESCRIPTOR_LOCATIONS, exports.ALL, exports.LOCATION_INSTANCE, exports.LOCATION_STATIC, exports.DESCRIPTOR_VISIBILITIES, exports.ALL, exports.VISIBILITY_EXPORTED, exports.VISIBILITY_INTERNAL, exports.ARGUMENT_CLASSES, exports.ARGUMENT_ENUMS, exports.ARGUMENT_FUNCTIONS, exports.ARGUMENT_INTERFACES, exports.ARGUMENT_METHODS, exports.ARGUMENT_NAMESPACES, exports.ARGUMENT_PROPERTIES, exports.ARGUMENT_TYPES, exports.ARGUMENT_VARIABLES)),\n    options: {\n        type: \"array\",\n        items: {\n            anyOf: [\n                {\n                    enum: Rule.defaultArguments,\n                    type: \"string\",\n                },\n                {\n                    type: \"object\",\n                    properties: (_d = {},\n                        _d[exports.ARGUMENT_CLASSES] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d[exports.ARGUMENT_ENUMS] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d[exports.ARGUMENT_FUNCTIONS] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d[exports.ARGUMENT_INTERFACES] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d[exports.ARGUMENT_METHODS] = Rule.ARGUMENT_DESCRIPTOR_CLASS,\n                        _d[exports.ARGUMENT_NAMESPACES] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d[exports.ARGUMENT_PROPERTIES] = Rule.ARGUMENT_DESCRIPTOR_CLASS,\n                        _d[exports.ARGUMENT_TYPES] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d[exports.ARGUMENT_VARIABLES] = Rule.ARGUMENT_DESCRIPTOR_BLOCK,\n                        _d),\n                },\n            ],\n        },\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"\" + exports.ARGUMENT_ENUMS + \"\\\", \\\"\" + exports.ARGUMENT_FUNCTIONS + \"\\\", \\\"\" + exports.ARGUMENT_METHODS + \"\\\"]\",\n        \"[true, {\\n                \\\"\" + exports.ARGUMENT_ENUMS + \"\\\": true,\\n                \\\"\" + exports.ARGUMENT_FUNCTIONS + \"\\\": {\\n                    \\\"\" + exports.DESCRIPTOR_VISIBILITIES + \"\\\": [\\\"\" + exports.VISIBILITY_EXPORTED + \"\\\"]\\n                },\\n                \\\"\" + exports.ARGUMENT_METHODS + \"\\\": {\\n                    \\\"\" + exports.DESCRIPTOR_LOCATIONS + \"\\\": [\\\"\" + exports.LOCATION_INSTANCE + \"\\\"]\\n                    \\\"\" + exports.DESCRIPTOR_PRIVACIES + \"\\\": [\\\"\" + exports.PRIVACY_PUBLIC + \"\\\", \\\"\" + exports.PRIVACY_PROTECTED + \"\\\"]\\n                }\\n            }]\"\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nvar Requirement = (function () {\n    function Requirement(descriptor) {\n        if (descriptor === void 0) { descriptor = {}; }\n        this.descriptor = descriptor;\n    }\n    Requirement.constructRequirements = function (ruleArguments) {\n        var requirements = new Map();\n        for (var _i = 0, ruleArguments_1 = ruleArguments; _i < ruleArguments_1.length; _i++) {\n            var ruleArgument = ruleArguments_1[_i];\n            Requirement.addRequirements(requirements, ruleArgument);\n        }\n        return requirements;\n    };\n    Requirement.addRequirements = function (requirements, descriptor) {\n        if (typeof descriptor === \"string\") {\n            requirements.set(descriptor, new BlockRequirement());\n            return;\n        }\n        for (var type in descriptor) {\n            if (descriptor.hasOwnProperty(type)) {\n                requirements.set(type, (type === \"methods\" || type === \"properties\")\n                    ? new ClassRequirement(descriptor[type])\n                    : new BlockRequirement(descriptor[type]));\n            }\n        }\n    };\n    Requirement.prototype.createSet = function (values) {\n        if (!values || values.length === 0) {\n            values = [exports.ALL];\n        }\n        return new Set(values);\n    };\n    return Requirement;\n}());\nvar BlockRequirement = (function (_super) {\n    __extends(BlockRequirement, _super);\n    function BlockRequirement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.visibilities = _this.createSet(_this.descriptor.visibilities);\n        return _this;\n    }\n    BlockRequirement.prototype.shouldNodeBeDocumented = function (node) {\n        if (this.visibilities.has(exports.ALL)) {\n            return true;\n        }\n        if (Lint.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {\n            return this.visibilities.has(exports.VISIBILITY_EXPORTED);\n        }\n        return this.visibilities.has(exports.VISIBILITY_INTERNAL);\n    };\n    return BlockRequirement;\n}(Requirement));\nvar ClassRequirement = (function (_super) {\n    __extends(ClassRequirement, _super);\n    function ClassRequirement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.locations = _this.createSet(_this.descriptor.locations);\n        _this.privacies = _this.createSet(_this.descriptor.privacies);\n        return _this;\n    }\n    ClassRequirement.prototype.shouldNodeBeDocumented = function (node) {\n        return this.shouldLocationBeDocumented(node) && this.shouldPrivacyBeDocumented(node);\n    };\n    ClassRequirement.prototype.shouldLocationBeDocumented = function (node) {\n        if (this.locations.has(exports.ALL)) {\n            return true;\n        }\n        if (Lint.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword)) {\n            return this.locations.has(exports.LOCATION_STATIC);\n        }\n        return this.locations.has(exports.LOCATION_INSTANCE);\n    };\n    ClassRequirement.prototype.shouldPrivacyBeDocumented = function (node) {\n        if (this.privacies.has(exports.ALL)) {\n            return true;\n        }\n        if (Lint.hasModifier(node.modifiers, ts.SyntaxKind.PrivateKeyword)) {\n            return this.privacies.has(exports.PRIVACY_PRIVATE);\n        }\n        if (Lint.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword)) {\n            return this.privacies.has(exports.PRIVACY_PROTECTED);\n        }\n        return Lint.hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword);\n    };\n    return ClassRequirement;\n}(Requirement));\nvar CompletedDocsWalker = (function (_super) {\n    __extends(CompletedDocsWalker, _super);\n    function CompletedDocsWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CompletedDocsWalker.prototype.setRequirements = function (requirements) {\n        this.requirements = requirements;\n    };\n    CompletedDocsWalker.prototype.visitClassDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_CLASSES);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitEnumDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_ENUMS);\n        _super.prototype.visitEnumDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_FUNCTIONS);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitInterfaceDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_INTERFACES);\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitMethodDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_METHODS);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitModuleDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_NAMESPACES);\n        _super.prototype.visitModuleDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitPropertyDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_PROPERTIES);\n        _super.prototype.visitPropertyDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitTypeAliasDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_TYPES);\n        _super.prototype.visitTypeAliasDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.visitVariableDeclaration = function (node) {\n        this.checkNode(node, exports.ARGUMENT_VARIABLES);\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    CompletedDocsWalker.prototype.checkNode = function (node, nodeType) {\n        if (node.name === undefined) {\n            return;\n        }\n        var requirement = this.requirements.get(nodeType);\n        if (!requirement || !requirement.shouldNodeBeDocumented(node)) {\n            return;\n        }\n        var symbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n        if (!symbol) {\n            return;\n        }\n        var comments = symbol.getDocumentationComment();\n        this.checkComments(node, nodeType, comments);\n    };\n    CompletedDocsWalker.prototype.checkComments = function (node, nodeDescriptor, comments) {\n        if (comments.map(function (comment) { return comment.text; }).join(\"\").trim() === \"\") {\n            this.addDocumentationFailure(node, nodeDescriptor);\n        }\n    };\n    CompletedDocsWalker.prototype.addDocumentationFailure = function (node, nodeType) {\n        var start = node.getStart();\n        var width = node.getText().split(/\\r|\\n/g)[0].length;\n        var description = this.describeDocumentationFailure(node, nodeType);\n        this.addFailureAt(start, width, description);\n    };\n    CompletedDocsWalker.prototype.describeDocumentationFailure = function (node, nodeType) {\n        var _this = this;\n        var description = Rule.FAILURE_STRING_EXIST;\n        if (node.modifiers) {\n            description += node.modifiers.map(function (modifier) { return _this.describeModifier(modifier.kind); }) + \" \";\n        }\n        return description + nodeType + \".\";\n    };\n    CompletedDocsWalker.prototype.describeModifier = function (kind) {\n        var description = ts.SyntaxKind[kind].toLowerCase().split(\"keyword\")[0];\n        return CompletedDocsWalker.modifierAliases[description] || description;\n    };\n    return CompletedDocsWalker;\n}(Lint.ProgramAwareRuleWalker));\nCompletedDocsWalker.modifierAliases = {\n    export: \"exported\",\n};\nvar _a, _b, _c, _d;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/importSpacingRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar LINE_BREAK_REGEX = /\\n|\\r\\n/;\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var comparisonWalker = new ImportStatementWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(comparisonWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"import-spacing\",\n    description: \"Ensures proper spacing between import statement keywords\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\nRule.ADD_SPACE_AFTER_IMPORT = \"Add space after 'import'\";\nRule.TOO_MANY_SPACES_AFTER_IMPORT = \"Too many spaces after 'import'\";\nRule.ADD_SPACE_AFTER_STAR = \"Add space after '*'\";\nRule.TOO_MANY_SPACES_AFTER_STAR = \"Too many spaces after '*'\";\nRule.ADD_SPACE_AFTER_FROM = \"Add space after 'from'\";\nRule.TOO_MANY_SPACES_AFTER_FROM = \"Too many spaces after 'from'\";\nRule.ADD_SPACE_BEFORE_FROM = \"Add space before 'from'\";\nRule.TOO_MANY_SPACES_BEFORE_FROM = \"Too many spaces before 'from'\";\nRule.NO_LINE_BREAKS = \"Line breaks are not allowed in import declaration\";\nexports.Rule = Rule;\nvar ImportStatementWalker = (function (_super) {\n    __extends(ImportStatementWalker, _super);\n    function ImportStatementWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImportStatementWalker.prototype.visitImportDeclaration = function (node) {\n        if (!node.importClause) {\n            this.checkModuleWithSideEffect(node);\n        }\n        else {\n            var nodeStart = node.getStart();\n            var importKeywordEnd = node.getStart() + \"import\".length;\n            var moduleSpecifierStart = node.moduleSpecifier.getStart();\n            var importClauseEnd = node.importClause.getEnd();\n            var importClauseStart = node.importClause.getStart();\n            if (importKeywordEnd === importClauseStart) {\n                this.addFailureAt(nodeStart, \"import\".length, Rule.ADD_SPACE_AFTER_IMPORT);\n            }\n            else if (importClauseStart > (importKeywordEnd + 1)) {\n                this.addFailureFromStartToEnd(nodeStart, importClauseStart, Rule.TOO_MANY_SPACES_AFTER_IMPORT);\n            }\n            var fromString = node.getText().substring(importClauseEnd - nodeStart, moduleSpecifierStart - nodeStart);\n            if (/from$/.test(fromString)) {\n                this.addFailureAt(importClauseEnd, fromString.length, Rule.ADD_SPACE_AFTER_FROM);\n            }\n            else if (/from\\s{2,}$/.test(fromString)) {\n                this.addFailureAt(importClauseEnd, fromString.length, Rule.TOO_MANY_SPACES_AFTER_FROM);\n            }\n            if (/^\\s{2,}from/.test(fromString)) {\n                this.addFailureAt(importClauseEnd, fromString.length, Rule.TOO_MANY_SPACES_BEFORE_FROM);\n            }\n            else if (/^from/.test(fromString)) {\n                this.addFailureAt(importClauseEnd, fromString.length, Rule.ADD_SPACE_BEFORE_FROM);\n            }\n            var text = node.getText();\n            var beforeImportClauseText = text.substring(0, importClauseStart - nodeStart);\n            var afterImportClauseText = text.substring(importClauseEnd - nodeStart);\n            if (LINE_BREAK_REGEX.test(beforeImportClauseText)) {\n                this.addFailureFromStartToEnd(nodeStart, importClauseStart - 1, Rule.NO_LINE_BREAKS);\n            }\n            if (LINE_BREAK_REGEX.test(afterImportClauseText)) {\n                this.addFailureFromStartToEnd(importClauseEnd, node.getEnd(), Rule.NO_LINE_BREAKS);\n            }\n        }\n        _super.prototype.visitImportDeclaration.call(this, node);\n    };\n    ImportStatementWalker.prototype.visitNamespaceImport = function (node) {\n        var text = node.getText();\n        if (text.indexOf(\"*as\") > -1) {\n            this.addFailureAtNode(node, Rule.ADD_SPACE_AFTER_STAR);\n        }\n        else if (/\\*\\s{2,}as/.test(text)) {\n            this.addFailureAtNode(node, Rule.TOO_MANY_SPACES_AFTER_STAR);\n        }\n        else if (LINE_BREAK_REGEX.test(text)) {\n            this.addFailureAtNode(node, Rule.NO_LINE_BREAKS);\n        }\n        _super.prototype.visitNamespaceImport.call(this, node);\n    };\n    ImportStatementWalker.prototype.checkModuleWithSideEffect = function (node) {\n        var moduleSpecifierStart = node.moduleSpecifier.getStart();\n        var nodeStart = node.getStart();\n        if ((nodeStart + \"import\".length + 1) < moduleSpecifierStart) {\n            this.addFailureFromStartToEnd(nodeStart, moduleSpecifierStart, Rule.TOO_MANY_SPACES_AFTER_IMPORT);\n        }\n        else if ((nodeStart + \"import\".length) === moduleSpecifierStart) {\n            this.addFailureAt(nodeStart, \"import\".length, Rule.ADD_SPACE_AFTER_IMPORT);\n        }\n        if (LINE_BREAK_REGEX.test(node.getText())) {\n            this.addFailureAt(nodeStart, node.getWidth(), Rule.NO_LINE_BREAKS);\n        }\n    };\n    return ImportStatementWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/interfaceNameRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar variableNameRule_1 = require(\"./variableNameRule\");\nvar OPTION_ALWAYS = \"always-prefix\";\nvar OPTION_NEVER = \"never-prefix\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, { never: this.ruleArguments.indexOf(OPTION_NEVER) !== -1 });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"interface-name\",\n    description: \"Requires interface names to begin with a capital 'I'\",\n    rationale: \"Makes it easy to differentiate interfaces from regular classes at a glance.\",\n    optionsDescription: (_a = [\"\\n            One of the following two options must be provided:\\n\\n            * `\\\"\", \"\\\"` requires interface names to start with an \\\"I\\\"\\n            * `\\\"\", \"\\\"` requires interface names to not have an \\\"I\\\" prefix\"], _a.raw = [\"\\n            One of the following two options must be provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` requires interface names to start with an \\\"I\\\"\\n            * \\\\`\\\"\", \"\\\"\\\\` requires interface names to not have an \\\"I\\\" prefix\"], Lint.Utils.dedent(_a, OPTION_ALWAYS, OPTION_NEVER)),\n    options: {\n        type: \"string\",\n        enum: [OPTION_ALWAYS, OPTION_NEVER],\n    },\n    optionExamples: [\"[true, \\\"\" + OPTION_ALWAYS + \"\\\"]\", \"[true, \\\"\" + OPTION_NEVER + \"\\\"]\"],\n    type: \"style\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"interface name must start with a capitalized I\";\nRule.FAILURE_STRING_NO_PREFIX = \"interface name must not have an \\\"I\\\" prefix\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var never = ctx.options.never;\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (utils.isInterfaceDeclaration(node)) {\n            var name = node.name;\n            if (never && hasPrefixI(name.text)) {\n                ctx.addFailureAtNode(name, Rule.FAILURE_STRING_NO_PREFIX);\n            }\n            else if (!never && name.text[0] !== \"I\") {\n                ctx.addFailureAtNode(name, Rule.FAILURE_STRING);\n            }\n        }\n        else {\n            return ts.forEachChild(node, cb);\n        }\n    });\n}\nfunction hasPrefixI(name) {\n    // Allow IndexedDB interfaces\n    return name.length >= 2 && name[0] === \"I\" && variableNameRule_1.isUpperCase(name[1]) && !name.startsWith(\"IDB\");\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/variableNameRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// tslint:disable object-literal-sort-keys\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar BANNED_KEYWORDS = [\"any\", \"Number\", \"number\", \"String\", \"string\", \"Boolean\", \"boolean\", \"Undefined\", \"undefined\"];\nvar bannedKeywordsSet = new Set(BANNED_KEYWORDS);\nvar bannedKeywordsStr = BANNED_KEYWORDS.map(function (kw) { return \"`\" + kw + \"`\"; }).join(\", \");\nvar OPTION_LEADING_UNDERSCORE = \"allow-leading-underscore\";\nvar OPTION_TRAILING_UNDERSCORE = \"allow-trailing-underscore\";\nvar OPTION_BAN_KEYWORDS = \"ban-keywords\";\nvar OPTION_CHECK_FORMAT = \"check-format\";\nvar OPTION_ALLOW_PASCAL_CASE = \"allow-pascal-case\";\nvar OPTION_ALLOW_SNAKE_CASE = \"allow-snake-case\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, parseOptions(this.ruleArguments));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: \"variable-name\",\n    description: \"Checks variable names for various errors.\",\n    optionsDescription: (_a = [\"\\n            Five arguments may be optionally provided:\\n\\n            * `\\\"\", \"\\\"`: allows only camelCased or UPPER_CASED variable names\\n              * `\\\"\", \"\\\"` allows underscores at the beginning (only has an effect if \\\"check-format\\\" specified)\\n              * `\\\"\", \"\\\"` allows underscores at the end. (only has an effect if \\\"check-format\\\" specified)\\n              * `\\\"\", \"\\\"` allows PascalCase in addition to camelCase.\\n              * `\\\"\", \"\\\"` allows snake_case in addition to camelCase.\\n            * `\\\"\", \"\\\"`: disallows the use of certain TypeScript keywords as variable or parameter names.\\n              * These are: \", \"\"], _a.raw = [\"\\n            Five arguments may be optionally provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\`: allows only camelCased or UPPER_CASED variable names\\n              * \\\\`\\\"\", \"\\\"\\\\` allows underscores at the beginning (only has an effect if \\\"check-format\\\" specified)\\n              * \\\\`\\\"\", \"\\\"\\\\` allows underscores at the end. (only has an effect if \\\"check-format\\\" specified)\\n              * \\\\`\\\"\", \"\\\"\\\\` allows PascalCase in addition to camelCase.\\n              * \\\\`\\\"\", \"\\\"\\\\` allows snake_case in addition to camelCase.\\n            * \\\\`\\\"\", \"\\\"\\\\`: disallows the use of certain TypeScript keywords as variable or parameter names.\\n              * These are: \", \"\"], Lint.Utils.dedent(_a, OPTION_CHECK_FORMAT, OPTION_LEADING_UNDERSCORE, OPTION_TRAILING_UNDERSCORE, OPTION_ALLOW_PASCAL_CASE, OPTION_ALLOW_SNAKE_CASE, OPTION_BAN_KEYWORDS, bannedKeywordsStr)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [\n                OPTION_CHECK_FORMAT,\n                OPTION_LEADING_UNDERSCORE,\n                OPTION_TRAILING_UNDERSCORE,\n                OPTION_ALLOW_PASCAL_CASE,\n                OPTION_ALLOW_SNAKE_CASE,\n                OPTION_BAN_KEYWORDS,\n            ],\n        },\n        minLength: 0,\n        maxLength: 5,\n    },\n    optionExamples: ['[true, \"ban-keywords\", \"check-format\", \"allow-leading-underscore\"]'],\n    type: \"style\",\n    typescriptOnly: false,\n};\nRule.KEYWORD_FAILURE = \"variable name clashes with keyword/type\";\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments) {\n    var banKeywords = hasOption(OPTION_BAN_KEYWORDS);\n    return {\n        banKeywords: banKeywords,\n        // check variable name formatting by default if no options are specified\n        checkFormat: !banKeywords || hasOption(OPTION_CHECK_FORMAT),\n        leadingUnderscore: hasOption(OPTION_LEADING_UNDERSCORE),\n        trailingUnderscore: hasOption(OPTION_TRAILING_UNDERSCORE),\n        allowPascalCase: hasOption(OPTION_ALLOW_PASCAL_CASE),\n        allowSnakeCase: hasOption(OPTION_ALLOW_SNAKE_CASE),\n    };\n    function hasOption(name) {\n        return ruleArguments.indexOf(name) !== -1;\n    }\n}\nfunction walk(ctx) {\n    var options = ctx.options, sourceFile = ctx.sourceFile;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.BindingElement: {\n                var _a = node, initializer = _a.initializer, name = _a.name, propertyName = _a.propertyName;\n                if (name.kind === ts.SyntaxKind.Identifier) {\n                    handleVariableNameKeyword(name);\n                    // A destructuring pattern that does not rebind an expression is always an alias, e.g. `var {Foo} = ...;`.\n                    // Only check if the name is rebound (`var {Foo: bar} = ...;`).\n                    if (node.parent.kind !== ts.SyntaxKind.ObjectBindingPattern || propertyName) {\n                        handleVariableNameFormat(name, initializer);\n                    }\n                }\n                break;\n            }\n            case ts.SyntaxKind.VariableStatement:\n                // skip 'declare' keywords\n                if (Lint.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword)) {\n                    return;\n                }\n                break;\n            case ts.SyntaxKind.Parameter:\n            case ts.SyntaxKind.PropertyDeclaration:\n            case ts.SyntaxKind.VariableDeclaration: {\n                var _b = node, name = _b.name, initializer = _b.initializer;\n                if (name.kind === ts.SyntaxKind.Identifier) {\n                    handleVariableNameFormat(name, initializer);\n                    // do not check property declarations for keywords, they are allowed to be keywords\n                    if (node.kind !== ts.SyntaxKind.PropertyDeclaration) {\n                        handleVariableNameKeyword(name);\n                    }\n                }\n                break;\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function handleVariableNameFormat(name, initializer) {\n        if (!options.checkFormat) {\n            return;\n        }\n        var text = name.text;\n        if (initializer && isAlias(text, initializer)) {\n            return;\n        }\n        if (!isCamelCase(text, options) && !isUpperCase(text)) {\n            ctx.addFailureAtNode(name, formatFailure());\n        }\n    }\n    function handleVariableNameKeyword(name) {\n        if (options.banKeywords && bannedKeywordsSet.has(name.text)) {\n            ctx.addFailureAtNode(name, Rule.KEYWORD_FAILURE);\n        }\n    }\n    function formatFailure() {\n        var failureMessage = \"variable name must be in camelcase\";\n        if (options.allowPascalCase) {\n            failureMessage += \", pascalcase\";\n        }\n        if (options.allowSnakeCase) {\n            failureMessage += \", snakecase\";\n        }\n        return failureMessage + \" or uppercase\";\n    }\n}\nfunction isAlias(name, initializer) {\n    switch (initializer.kind) {\n        case ts.SyntaxKind.PropertyAccessExpression:\n            return initializer.name.text === name;\n        case ts.SyntaxKind.Identifier:\n            return initializer.text === name;\n        default:\n            return false;\n    }\n}\nfunction isCamelCase(name, options) {\n    var firstCharacter = name[0];\n    var lastCharacter = name[name.length - 1];\n    var middle = name.slice(1, -1);\n    if (!options.leadingUnderscore && firstCharacter === \"_\") {\n        return false;\n    }\n    if (!options.trailingUnderscore && lastCharacter === \"_\") {\n        return false;\n    }\n    if (!options.allowPascalCase && !isLowerCase(firstCharacter)) {\n        return false;\n    }\n    if (!options.allowSnakeCase && middle.indexOf(\"_\") !== -1) {\n        return false;\n    }\n    return true;\n}\nfunction isLowerCase(name) {\n    return name === name.toLowerCase();\n}\nfunction isUpperCase(name) {\n    return name === name.toUpperCase();\n}\nexports.isUpperCase = isUpperCase;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/interfaceOverTypeLiteralRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new InterfaceOverTypeLiteralWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"interface-over-type-literal\",\n    description: \"Prefer an interface declaration over a type literal (`type T = { ... }`)\",\n    rationale: \"Interfaces are generally preferred over type literals because interfaces can be implemented, extended and merged.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Use an interface instead of a type literal.\";\nexports.Rule = Rule;\nvar InterfaceOverTypeLiteralWalker = (function (_super) {\n    __extends(InterfaceOverTypeLiteralWalker, _super);\n    function InterfaceOverTypeLiteralWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    InterfaceOverTypeLiteralWalker.prototype.visitTypeAliasDeclaration = function (node) {\n        if (node.type.kind === ts.SyntaxKind.TypeLiteral) {\n            this.addFailureAtNode(node.name, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitTypeAliasDeclaration.call(this, node);\n    };\n    return InterfaceOverTypeLiteralWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/jsdocFormatRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new JsdocWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"jsdoc-format\",\n    description: \"Enforces basic format rules for JSDoc comments.\",\n    descriptionDetails: (_a = [\"\\n            The following rules are enforced for JSDoc comments (comments starting with `/**`):\\n\\n            * each line contains an asterisk and asterisks must be aligned\\n            * each asterisk must be followed by either a space or a newline (except for the first and the last)\\n            * the only characters before the asterisk on each line must be whitespace characters\\n            * one line comments must start with `/** ` and end with `*/`\"], _a.raw = [\"\\n            The following rules are enforced for JSDoc comments (comments starting with \\\\`/**\\\\`):\\n\\n            * each line contains an asterisk and asterisks must be aligned\\n            * each asterisk must be followed by either a space or a newline (except for the first and the last)\\n            * the only characters before the asterisk on each line must be whitespace characters\\n            * one line comments must start with \\\\`/** \\\\` and end with \\\\`*/\\\\`\"], Lint.Utils.dedent(_a)),\n    rationale: \"Helps maintain a consistent, readable style for JSDoc comments.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.ALIGNMENT_FAILURE_STRING = \"asterisks in jsdoc must be aligned\";\nRule.FORMAT_FAILURE_STRING = \"jsdoc is not formatted correctly on this line\";\nexports.Rule = Rule;\nvar JsdocWalker = (function (_super) {\n    __extends(JsdocWalker, _super);\n    function JsdocWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    JsdocWalker.prototype.visitSourceFile = function (node) {\n        var _this = this;\n        utils.forEachComment(node, function (fullText, comment) {\n            if (comment.kind === ts.SyntaxKind.MultiLineCommentTrivia) {\n                _this.findFailuresForJsdocComment(fullText.substring(comment.pos, comment.end), comment.pos);\n            }\n        });\n    };\n    JsdocWalker.prototype.findFailuresForJsdocComment = function (commentText, startingPosition) {\n        var currentPosition = startingPosition;\n        // the file may be different depending on the OS it was originally authored on\n        // can't rely on require('os').EOL or process.platform as that is the execution env\n        // regex is: split optionally on \\r\\n, but alwasy split on \\n if no \\r exists\n        var lines = commentText.split(/\\r?\\n/);\n        var firstLine = lines[0];\n        var jsdocPosition = currentPosition;\n        // regex is: start of string, followed by any amount of whitespace, followed by /** but not more than 2 **\n        var isJsdocMatch = firstLine.match(/^\\s*\\/\\*\\*([^*]|$)/);\n        if (isJsdocMatch != null) {\n            if (lines.length === 1) {\n                var firstLineMatch = firstLine.match(/^\\s*\\/\\*\\* (.* )?\\*\\/$/);\n                if (firstLineMatch == null) {\n                    this.addFailureAt(jsdocPosition, firstLine.length, Rule.FORMAT_FAILURE_STRING);\n                }\n                return;\n            }\n            var indexToMatch = firstLine.indexOf(\"**\") + this.getLineAndCharacterOfPosition(currentPosition).character;\n            // all lines but the first and last\n            var otherLines = lines.splice(1, lines.length - 2);\n            jsdocPosition += firstLine.length + 1; // + 1 for the splitted-out newline\n            for (var _i = 0, otherLines_1 = otherLines; _i < otherLines_1.length; _i++) {\n                var line = otherLines_1[_i];\n                // regex is: start of string, followed by any amount of whitespace, followed by *,\n                // followed by either a space or the end of the string\n                var asteriskMatch = line.match(/^\\s*\\*( |$)/);\n                if (asteriskMatch == null) {\n                    this.addFailureAt(jsdocPosition, line.length, Rule.FORMAT_FAILURE_STRING);\n                }\n                var asteriskIndex = line.indexOf(\"*\");\n                if (asteriskIndex !== indexToMatch) {\n                    this.addFailureAt(jsdocPosition, line.length, Rule.ALIGNMENT_FAILURE_STRING);\n                }\n                jsdocPosition += line.length + 1; // + 1 for the splitted-out newline\n            }\n            var lastLine = lines[lines.length - 1];\n            // regex is: start of string, followed by any amount of whitespace, followed by */,\n            // followed by the end of the string\n            var endBlockCommentMatch = lastLine.match(/^\\s*\\*\\/$/);\n            if (endBlockCommentMatch == null) {\n                this.addFailureAt(jsdocPosition, lastLine.length, Rule.FORMAT_FAILURE_STRING);\n            }\n            var lastAsteriskIndex = lastLine.indexOf(\"*\");\n            if (lastAsteriskIndex !== indexToMatch) {\n                this.addFailureAt(jsdocPosition, lastLine.length, Rule.ALIGNMENT_FAILURE_STRING);\n            }\n        }\n    };\n    return JsdocWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/matchDefaultExportNameRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (importName, exportName) {\n        return \"Expected import '\" + importName + \"' to match the default export '\" + exportName + \"'.\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"match-default-export-name\",\n    description: (_a = [\"\\n            Requires that a default import have the same name as the declaration it imports.\\n            Does nothing for anonymous default exports.\"], _a.raw = [\"\\n            Requires that a default import have the same name as the declaration it imports.\\n            Does nothing for anonymous default exports.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitSourceFile = function (node) {\n        for (var _i = 0, _a = node.statements; _i < _a.length; _i++) {\n            var statement = _a[_i];\n            if (statement.kind !== ts.SyntaxKind.ImportDeclaration) {\n                continue;\n            }\n            var importClause = statement.importClause;\n            if (importClause && importClause.name) {\n                this.checkDefaultImport(importClause.name);\n            }\n        }\n    };\n    Walker.prototype.checkDefaultImport = function (defaultImport) {\n        var declarations = this.getTypeChecker().getAliasedSymbol(this.getTypeChecker().getSymbolAtLocation(defaultImport)).declarations;\n        var name = declarations && declarations[0] && declarations[0].name;\n        if (name && name.kind === ts.SyntaxKind.Identifier && defaultImport.text !== name.text) {\n            this.addFailureAtNode(defaultImport, Rule.FAILURE_STRING(defaultImport.text, name.text));\n        }\n    };\n    return Walker;\n}(Lint.ProgramAwareRuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/newParensRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"new-parens\",\n    description: \"Requires parentheses when invoking a constructor via the `new` keyword.\",\n    rationale: \"Maintains stylistic consistency with other function calls.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Parentheses are required when invoking a constructor\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.NewExpression && node.arguments === undefined) {\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/newlineBeforeReturnRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NewlineBeforeReturnWalker(sourceFile, this.ruleName, undefined));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"newline-before-return\",\n    description: \"Enforces blank line before return when not the only line in the block.\",\n    rationale: \"Helps maintain a readable style in your codebase.\",\n    optionsDescription: \"Not configurable.\",\n    options: {},\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Missing blank line before return\";\nexports.Rule = Rule;\nvar NewlineBeforeReturnWalker = (function (_super) {\n    __extends(NewlineBeforeReturnWalker, _super);\n    function NewlineBeforeReturnWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NewlineBeforeReturnWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (node.kind === ts.SyntaxKind.ReturnStatement) {\n                _this.visitReturnStatement(node);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    NewlineBeforeReturnWalker.prototype.visitReturnStatement = function (node) {\n        var prev = tsutils_1.getPreviousStatement(node);\n        if (prev === undefined) {\n            // return is not within a block (e.g. the only child of an IfStatement) or the first statement of the block\n            // no need to check for preceding newline\n            return;\n        }\n        var start = node.getStart(this.sourceFile);\n        var line = ts.getLineAndCharacterOfPosition(this.sourceFile, start).line;\n        var comments = ts.getLeadingCommentRanges(this.sourceFile.text, node.pos);\n        if (comments) {\n            // check for blank lines between comments\n            for (var i = comments.length - 1; i >= 0; --i) {\n                var endLine = ts.getLineAndCharacterOfPosition(this.sourceFile, comments[i].end).line;\n                if (endLine < line - 1) {\n                    return;\n                }\n                start = comments[i].pos;\n                line = ts.getLineAndCharacterOfPosition(this.sourceFile, start).line;\n            }\n        }\n        var prevLine = ts.getLineAndCharacterOfPosition(this.sourceFile, prev.end).line;\n        if (prevLine >= line - 1) {\n            // Previous statement is on the same or previous line\n            this.addFailure(start, start, Rule.FAILURE_STRING);\n        }\n    };\n    return NewlineBeforeReturnWalker;\n}(Lint.AbstractWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noAngleBracketTypeAssertionRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-angle-bracket-type-assertion\",\n    description: \"Requires the use of `as Type` for type assertions instead of `<Type>`.\",\n    hasFix: true,\n    rationale: (_a = [\"\\n            Both formats of type assertions have the same effect, but only `as` type assertions\\n            work in `.tsx` files. This rule ensures that you have a consistent type assertion style\\n            across your codebase.\"], _a.raw = [\"\\n            Both formats of type assertions have the same effect, but only \\\\`as\\\\` type assertions\\n            work in \\\\`.tsx\\\\` files. This rule ensures that you have a consistent type assertion style\\n            across your codebase.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Type assertion using the '<>' syntax is forbidden. Use the 'as' syntax instead.\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isTypeAssertion(node)) {\n            var start = node.getStart(ctx.sourceFile);\n            ctx.addFailure(start, node.end, Rule.FAILURE_STRING, [\n                Lint.Replacement.appendText(node.end, \" as \" + node.type.getText(ctx.sourceFile)),\n                Lint.Replacement.deleteFromTo(start, node.expression.getStart(ctx.sourceFile)),\n            ]);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noBooleanLiteralCompareRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (negate) {\n        return \"This expression is unnecessarily compared to a boolean. Just \" + (negate ? \"negate it\" : \"use it directly\") + \".\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-boolean-literal-compare\",\n    description: \"Warns on comparison to a boolean literal, as in `x === true`.\",\n    hasFix: true,\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (utils.isBinaryExpression(node)) {\n            var cmp = getBooleanComparison(node, checker);\n            if (cmp) {\n                ctx.addFailureAtNode(cmp.expression, Rule.FAILURE_STRING(cmp.negate), fix(node, cmp));\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction getBooleanComparison(node, checker) {\n    var cmp = deconstructComparison(node);\n    return cmp === undefined || !Lint.isTypeFlagSet(checker.getTypeAtLocation(cmp.expression), ts.TypeFlags.Boolean) ? undefined : cmp;\n}\nfunction fix(node, _a) {\n    var negate = _a.negate, expression = _a.expression;\n    var deleted = node.left === expression\n        ? Lint.Replacement.deleteFromTo(node.left.end, node.end)\n        : Lint.Replacement.deleteFromTo(node.getStart(), node.right.getStart());\n    if (!negate) {\n        return deleted;\n    }\n    else if (needsParenthesesForNegate(expression)) {\n        return [\n            deleted,\n            Lint.Replacement.appendText(node.getStart(), \"!(\"),\n            Lint.Replacement.appendText(node.getEnd(), \")\"),\n        ];\n    }\n    else {\n        return [\n            deleted,\n            Lint.Replacement.appendText(node.getStart(), \"!\"),\n        ];\n    }\n}\nfunction needsParenthesesForNegate(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.AsExpression:\n        case ts.SyntaxKind.BinaryExpression:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction deconstructComparison(node) {\n    var left = node.left, operatorToken = node.operatorToken, right = node.right;\n    var eq = Lint.getEqualsKind(operatorToken);\n    if (!eq) {\n        return undefined;\n    }\n    var leftValue = booleanFromExpression(left);\n    if (leftValue !== undefined) {\n        return { negate: leftValue !== eq.isPositive, expression: right };\n    }\n    var rightValue = booleanFromExpression(right);\n    if (rightValue !== undefined) {\n        return { negate: rightValue !== eq.isPositive, expression: left };\n    }\n    return undefined;\n}\nfunction booleanFromExpression(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.TrueKeyword:\n            return true;\n        case ts.SyntaxKind.FalseKeyword:\n            return false;\n        default:\n            return undefined;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noParameterPropertiesRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoParameterPropertiesWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-parameter-properties\",\n    description: \"Disallows parameter properties in class constructors.\",\n    rationale: (_a = [\"\\n            Parameter properties can be confusing to those new to TS as they are less explicit\\n            than other ways of declaring and initializing class members.\"], _a.raw = [\"\\n            Parameter properties can be confusing to those new to TS as they are less explicit\\n            than other ways of declaring and initializing class members.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_FACTORY = function (ident) {\n    return \"Property '\" + ident + \"' cannot be declared in the constructor\";\n};\nexports.Rule = Rule;\nvar NoParameterPropertiesWalker = (function (_super) {\n    __extends(NoParameterPropertiesWalker, _super);\n    function NoParameterPropertiesWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoParameterPropertiesWalker.prototype.visitConstructorDeclaration = function (node) {\n        var parameters = node.parameters;\n        for (var _i = 0, parameters_1 = parameters; _i < parameters_1.length; _i++) {\n            var parameter = parameters_1[_i];\n            if (parameter.modifiers != null && parameter.modifiers.length > 0) {\n                var errorMessage = Rule.FAILURE_STRING_FACTORY(parameter.name.text);\n                var lastModifier = parameter.modifiers[parameter.modifiers.length - 1];\n                this.addFailureFromStartToEnd(parameter.getStart(), lastModifier.getEnd(), errorMessage);\n            }\n        }\n        _super.prototype.visitConstructorDeclaration.call(this, node);\n    };\n    return NoParameterPropertiesWalker;\n}(Lint.RuleWalker));\nexports.NoParameterPropertiesWalker = NoParameterPropertiesWalker;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noReferenceImportRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (moduleReference) {\n        return \"No need to reference \\\"\" + moduleReference + \"\\\", since it is imported.\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-reference-import\",\n    description: 'Don\\'t <reference types=\"foo\" /> if you import \"foo\" anyway.',\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    type: \"style\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile;\n    if (sourceFile.typeReferenceDirectives.length === 0) {\n        return;\n    }\n    var imports = allImports(sourceFile);\n    for (var _i = 0, _a = sourceFile.typeReferenceDirectives; _i < _a.length; _i++) {\n        var ref = _a[_i];\n        if (imports.has(ref.fileName)) {\n            ctx.addFailure(ref.pos, ref.end, Rule.FAILURE_STRING(ref.fileName));\n        }\n    }\n}\nfunction allImports(sourceFile) {\n    var imports = new Set();\n    for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {\n        var statement = _a[_i];\n        recur(statement);\n    }\n    return imports;\n    function recur(node) {\n        if (utils.isImportEqualsDeclaration(node)) {\n            var ref = node.moduleReference;\n            if (ref.kind === ts.SyntaxKind.ExternalModuleReference) {\n                if (ref.expression) {\n                    addImport(ref.expression);\n                }\n            }\n        }\n        else if (utils.isImportDeclaration(node)) {\n            addImport(node.moduleSpecifier);\n        }\n        else if (utils.isModuleDeclaration(node)) {\n            if (!sourceFile.isDeclarationFile) {\n                // Can't be any imports in a module augmentation.\n                return;\n            }\n            var body = moduleDeclarationBody(node);\n            if (body) {\n                for (var _i = 0, _a = body.statements; _i < _a.length; _i++) {\n                    var statement = _a[_i];\n                    recur(statement);\n                }\n            }\n        }\n    }\n    function addImport(moduleReference) {\n        if (utils.isStringLiteral(moduleReference)) {\n            imports.add(moduleReference.text);\n        }\n    }\n}\nfunction moduleDeclarationBody(node) {\n    var body = node.body;\n    while (body && body.kind === ts.SyntaxKind.ModuleDeclaration) {\n        body = body.body;\n    }\n    return body && body.kind === ts.SyntaxKind.ModuleBlock ? body : undefined;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnnecessaryCallbackWrapperRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (cbText) {\n        return \"No need to wrap '\" + cbText + \"' in another function. Just use it directly.\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unnecessary-callback-wrapper\",\n    description: (_a = [\"\\n            Replaces `x => f(x)` with just `f`.\\n            To catch more cases, enable `only-arrow-functions` and `arrow-return-shorthand` too.\"], _a.raw = [\"\\n            Replaces \\\\`x => f(x)\\\\` with just \\\\`f\\\\`.\\n            To catch more cases, enable \\\\`only-arrow-functions\\\\` and \\\\`arrow-return-shorthand\\\\` too.\"], Lint.Utils.dedent(_a)),\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, cb);\n    function cb(node) {\n        if (tsutils_1.isArrowFunction(node) && !tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.AsyncKeyword) &&\n            tsutils_1.isCallExpression(node.body) && tsutils_1.isIdentifier(node.body.expression) &&\n            isRedundantCallback(node.parameters, node.body.arguments)) {\n            var start = node.getStart(ctx.sourceFile);\n            ctx.addFailure(start, node.end, Rule.FAILURE_STRING(node.body.expression.text), [\n                Lint.Replacement.deleteFromTo(start, node.body.getStart(ctx.sourceFile)),\n                Lint.Replacement.deleteFromTo(node.body.expression.end, node.end),\n            ]);\n        }\n        else {\n            return ts.forEachChild(node, cb);\n        }\n    }\n}\nfunction isRedundantCallback(parameters, args) {\n    if (parameters.length !== args.length) {\n        return false;\n    }\n    for (var i = 0; i < parameters.length; ++i) {\n        var _a = parameters[i], dotDotDotToken = _a.dotDotDotToken, name = _a.name;\n        var arg = args[i];\n        if (dotDotDotToken !== undefined) {\n            if (!tsutils_1.isSpreadElement(arg)) {\n                return false;\n            }\n            arg = arg.expression;\n        }\n        if (!tsutils_1.isIdentifier(name) || !tsutils_1.isIdentifier(arg) || name.text !== arg.text) {\n            return false;\n        }\n    }\n    return true;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnnecessaryInitializerRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unnecessary-initializer\",\n    description: \"Forbids a 'var'/'let' statement or destructuring initializer to be initialized to 'undefined'.\",\n    hasFix: true,\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Unnecessary initialization to 'undefined'.\";\nRule.FAILURE_STRING_PARAMETER = \"Use an optional parameter instead of initializing to 'undefined'. \" +\n    \"Also, the type declaration does not need to include '| undefined'.\";\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitVariableDeclaration = function (node) {\n        if (utils.isBindingPattern(node.name)) {\n            for (var _i = 0, _a = node.name.elements; _i < _a.length; _i++) {\n                var elem = _a[_i];\n                if (elem.kind === ts.SyntaxKind.BindingElement) {\n                    this.checkInitializer(elem);\n                }\n            }\n        }\n        else if (!Lint.isNodeFlagSet(node.parent, ts.NodeFlags.Const)) {\n            this.checkInitializer(node);\n        }\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    Walker.prototype.visitMethodDeclaration = function (node) {\n        this.checkSignature(node);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    Walker.prototype.visitFunctionDeclaration = function (node) {\n        this.checkSignature(node);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    Walker.prototype.visitConstructorDeclaration = function (node) {\n        this.checkSignature(node);\n        _super.prototype.visitConstructorDeclaration.call(this, node);\n    };\n    Walker.prototype.checkSignature = function (_a) {\n        var _this = this;\n        var parameters = _a.parameters;\n        parameters.forEach(function (parameter, i) {\n            if (isUndefined(parameter.initializer)) {\n                if (parametersAllOptionalAfter(parameters, i)) {\n                    // No fix since they may want to remove '| undefined' from the type.\n                    _this.addFailureAtNode(parameter, Rule.FAILURE_STRING_PARAMETER);\n                }\n                else {\n                    _this.failWithFix(parameter);\n                }\n            }\n        });\n    };\n    Walker.prototype.checkInitializer = function (node) {\n        if (isUndefined(node.initializer)) {\n            this.failWithFix(node);\n        }\n    };\n    Walker.prototype.failWithFix = function (node) {\n        var fix = this.deleteFromTo(Lint.childOfKind(node, ts.SyntaxKind.EqualsToken).pos, node.end);\n        this.addFailureAtNode(node, Rule.FAILURE_STRING, fix);\n    };\n    return Walker;\n}(Lint.RuleWalker));\nfunction parametersAllOptionalAfter(parameters, idx) {\n    for (var i = idx + 1; i < parameters.length; i++) {\n        if (parameters[i].questionToken) {\n            return true;\n        }\n        if (!parameters[i].initializer) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isUndefined(node) {\n    return node !== undefined &&\n        node.kind === ts.SyntaxKind.Identifier &&\n        node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noUnnecessaryQualifierRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (name) {\n        return \"Qualifier is unnecessary since '\" + name + \"' is in scope.\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-unnecessary-qualifier\",\n    description: \"Warns when a namespace qualifier (`A.x`) is unnecessary.\",\n    hasFix: true,\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: true,\n    requiresTypeInfo: true,\n};\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.namespacesInScope = [];\n        return _this;\n    }\n    Walker.prototype.visitModuleDeclaration = function (node) {\n        this.namespacesInScope.push(node);\n        _super.prototype.visitModuleDeclaration.call(this, node);\n        this.namespacesInScope.pop();\n    };\n    Walker.prototype.visitEnumDeclaration = function (node) {\n        this.namespacesInScope.push(node);\n        _super.prototype.visitEnumDeclaration.call(this, node);\n        this.namespacesInScope.pop();\n    };\n    Walker.prototype.visitNode = function (node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.QualifiedName:\n                var _a = node, left = _a.left, right = _a.right;\n                this.visitNamespaceAccess(node, left, right);\n                break;\n            case ts.SyntaxKind.PropertyAccessExpression:\n                var _b = node, expression = _b.expression, name = _b.name;\n                if (utils.isEntityNameExpression(expression)) {\n                    this.visitNamespaceAccess(node, expression, name);\n                    break;\n                }\n            // falls through\n            default:\n                _super.prototype.visitNode.call(this, node);\n        }\n    };\n    Walker.prototype.visitNamespaceAccess = function (node, qualifier, name) {\n        if (this.qualifierIsUnnecessary(qualifier, name)) {\n            var fix = this.deleteFromTo(qualifier.getStart(), name.getStart());\n            this.addFailureAtNode(qualifier, Rule.FAILURE_STRING(qualifier.getText()), fix);\n        }\n        else {\n            // Only look for nested qualifier errors if we didn't already fail on the outer qualifier.\n            _super.prototype.visitNode.call(this, node);\n        }\n    };\n    Walker.prototype.qualifierIsUnnecessary = function (qualifier, name) {\n        var namespaceSymbol = this.symbolAtLocation(qualifier);\n        if (namespaceSymbol === undefined || !this.symbolIsNamespaceInScope(namespaceSymbol)) {\n            return false;\n        }\n        var accessedSymbol = this.symbolAtLocation(name);\n        if (accessedSymbol === undefined) {\n            return false;\n        }\n        // If the symbol in scope is different, the qualifier is necessary.\n        var fromScope = this.getSymbolInScope(qualifier, accessedSymbol.flags, name.text);\n        return fromScope === undefined || fromScope === accessedSymbol;\n    };\n    Walker.prototype.getSymbolInScope = function (node, flags, name) {\n        // TODO:PERF `getSymbolsInScope` gets a long list. Is there a better way?\n        var scope = this.getTypeChecker().getSymbolsInScope(node, flags);\n        return scope.find(function (scopeSymbol) { return scopeSymbol.name === name; });\n    };\n    Walker.prototype.symbolAtLocation = function (node) {\n        return this.getTypeChecker().getSymbolAtLocation(node);\n    };\n    Walker.prototype.symbolIsNamespaceInScope = function (symbol) {\n        var _this = this;\n        if (symbol.getDeclarations().some(function (decl) { return _this.namespacesInScope.some(function (ns) { return ns === decl; }); })) {\n            return true;\n        }\n        var alias = this.tryGetAliasedSymbol(symbol);\n        return alias !== undefined && this.symbolIsNamespaceInScope(alias);\n    };\n    Walker.prototype.tryGetAliasedSymbol = function (symbol) {\n        return Lint.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? this.getTypeChecker().getAliasedSymbol(symbol) : undefined;\n    };\n    return Walker;\n}(Lint.ProgramAwareRuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/objectLiteralKeyQuotesRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var objectLiteralKeyQuotesWalker = new ObjectLiteralKeyQuotesWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(objectLiteralKeyQuotesWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"object-literal-key-quotes\",\n    description: \"Enforces consistent object literal property quote style.\",\n    descriptionDetails: (_a = [\"\\n            Object literal property names can be defined in two ways: using literals or using strings.\\n            For example, these two objects are equivalent:\\n\\n            var object1 = {\\n                property: true\\n            };\\n\\n            var object2 = {\\n                \\\"property\\\": true\\n            };\\n\\n            In many cases, it doesn\\u2019t matter if you choose to use an identifier instead of a string\\n            or vice-versa. Even so, you might decide to enforce a consistent style in your code.\\n\\n            This rules lets you enforce consistent quoting of property names. Either they should always\\n            be quoted (default behavior) or quoted only as needed (\\\"as-needed\\\").\"], _a.raw = [\"\\n            Object literal property names can be defined in two ways: using literals or using strings.\\n            For example, these two objects are equivalent:\\n\\n            var object1 = {\\n                property: true\\n            };\\n\\n            var object2 = {\\n                \\\"property\\\": true\\n            };\\n\\n            In many cases, it doesn\\u2019t matter if you choose to use an identifier instead of a string\\n            or vice-versa. Even so, you might decide to enforce a consistent style in your code.\\n\\n            This rules lets you enforce consistent quoting of property names. Either they should always\\n            be quoted (default behavior) or quoted only as needed (\\\"as-needed\\\").\"], Lint.Utils.dedent(_a)),\n    hasFix: true,\n    optionsDescription: (_b = [\"\\n            Possible settings are:\\n\\n            * `\\\"always\\\"`: Property names should always be quoted. (This is the default.)\\n            * `\\\"as-needed\\\"`: Only property names which require quotes may be quoted (e.g. those with spaces in them).\\n            * `\\\"consistent\\\"`: Property names should either all be quoted or unquoted.\\n            * `\\\"consistent-as-needed\\\"`: If any property name requires quotes, then all properties must be quoted. Otherwise, no\\n            property names may be quoted.\\n\\n            For ES6, computed property names (`{[name]: value}`) and methods (`{foo() {}}`) never need\\n            to be quoted.\"], _b.raw = [\"\\n            Possible settings are:\\n\\n            * \\\\`\\\"always\\\"\\\\`: Property names should always be quoted. (This is the default.)\\n            * \\\\`\\\"as-needed\\\"\\\\`: Only property names which require quotes may be quoted (e.g. those with spaces in them).\\n            * \\\\`\\\"consistent\\\"\\\\`: Property names should either all be quoted or unquoted.\\n            * \\\\`\\\"consistent-as-needed\\\"\\\\`: If any property name requires quotes, then all properties must be quoted. Otherwise, no\\n            property names may be quoted.\\n\\n            For ES6, computed property names (\\\\`{[name]: value}\\\\`) and methods (\\\\`{foo() {}}\\\\`) never need\\n            to be quoted.\"], Lint.Utils.dedent(_b)),\n    options: {\n        type: \"string\",\n        enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"],\n    },\n    optionExamples: [\"[true, \\\"as-needed\\\"]\", \"[true, \\\"always\\\"]\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.INCONSISTENT_PROPERTY = \"All property names in this object literal must be consistently quoted or unquoted.\";\nRule.UNNEEDED_QUOTES = function (name) {\n    return \"Unnecessarily quoted property '\" + name + \"' found.\";\n};\nRule.UNQUOTED_PROPERTY = function (name) {\n    return \"Unquoted property '\" + name + \"' found.\";\n};\nexports.Rule = Rule;\nvar ObjectLiteralKeyQuotesWalker = (function (_super) {\n    __extends(ObjectLiteralKeyQuotesWalker, _super);\n    function ObjectLiteralKeyQuotesWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.mode = _this.getOptions()[0] || \"always\";\n        return _this;\n    }\n    ObjectLiteralKeyQuotesWalker.prototype.visitObjectLiteralExpression = function (node) {\n        var properties = node.properties.filter(function (_a) {\n            var kind = _a.kind;\n            return kind !== ts.SyntaxKind.ShorthandPropertyAssignment && kind !== ts.SyntaxKind.SpreadAssignment;\n        });\n        switch (this.mode) {\n            case \"always\":\n                this.allMustHaveQuotes(properties);\n                break;\n            case \"as-needed\":\n                this.noneMayHaveQuotes(properties);\n                break;\n            case \"consistent\":\n                if (quotesAreInconsistent(properties)) {\n                    // No fix -- don't know if they would want to add quotes or remove them.\n                    this.addFailureAt(node.getStart(), 1, Rule.INCONSISTENT_PROPERTY);\n                }\n                break;\n            case \"consistent-as-needed\":\n                if (properties.some(function (_a) {\n                    var name = _a.name;\n                    return name !== undefined\n                        && name.kind === ts.SyntaxKind.StringLiteral && propertyNeedsQuotes(name.text);\n                })) {\n                    this.allMustHaveQuotes(properties);\n                }\n                else {\n                    this.noneMayHaveQuotes(properties, true);\n                }\n                break;\n            default:\n                break;\n        }\n        _super.prototype.visitObjectLiteralExpression.call(this, node);\n    };\n    ObjectLiteralKeyQuotesWalker.prototype.allMustHaveQuotes = function (properties) {\n        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n            var name = properties_1[_i].name;\n            if (name !== undefined && name.kind !== ts.SyntaxKind.StringLiteral && name.kind !== ts.SyntaxKind.ComputedPropertyName) {\n                var fix = [this.appendText(name.getStart(), '\"'), this.appendText(name.getEnd(), '\"')];\n                this.addFailureAtNode(name, Rule.UNQUOTED_PROPERTY(name.getText()), fix);\n            }\n        }\n    };\n    ObjectLiteralKeyQuotesWalker.prototype.noneMayHaveQuotes = function (properties, noneNeedQuotes) {\n        for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {\n            var name = properties_2[_i].name;\n            if (name !== undefined && name.kind === ts.SyntaxKind.StringLiteral && (noneNeedQuotes || !propertyNeedsQuotes(name.text))) {\n                var fix = [this.deleteText(name.getStart(), 1), this.deleteText(name.getEnd() - 1, 1)];\n                this.addFailureAtNode(name, Rule.UNNEEDED_QUOTES(name.text), fix);\n            }\n        }\n    };\n    return ObjectLiteralKeyQuotesWalker;\n}(Lint.RuleWalker));\nfunction quotesAreInconsistent(properties) {\n    var propertiesAreQuoted; // inferred on first (non-computed) property\n    for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {\n        var name = properties_3[_i].name;\n        if (name === undefined || name.kind === ts.SyntaxKind.ComputedPropertyName) {\n            continue;\n        }\n        var thisOneIsQuoted = name.kind === ts.SyntaxKind.StringLiteral;\n        if (propertiesAreQuoted === undefined) {\n            propertiesAreQuoted = thisOneIsQuoted;\n        }\n        else if (propertiesAreQuoted !== thisOneIsQuoted) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction propertyNeedsQuotes(property) {\n    return !IDENTIFIER_NAME_REGEX.test(property) && (Number(property).toString() !== property || property.startsWith(\"-\"));\n}\n// This is simplistic. See https://mothereff.in/js-properties for the gorey details.\nvar IDENTIFIER_NAME_REGEX = /^(?:[\\$A-Z_a-z])+$/;\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/objectLiteralShorthandRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var objectLiteralShorthandWalker = new ObjectLiteralShorthandWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(objectLiteralShorthandWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"object-literal-shorthand\",\n    description: \"Enforces use of ES6 object literal shorthand when possible.\",\n    hasFix: true,\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.LONGHAND_PROPERTY = \"Expected property shorthand in object literal \";\nRule.LONGHAND_METHOD = \"Expected method shorthand in object literal \";\nexports.Rule = Rule;\nvar ObjectLiteralShorthandWalker = (function (_super) {\n    __extends(ObjectLiteralShorthandWalker, _super);\n    function ObjectLiteralShorthandWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ObjectLiteralShorthandWalker.prototype.visitPropertyAssignment = function (node) {\n        var name = node.name;\n        var value = node.initializer;\n        if (name.kind === ts.SyntaxKind.Identifier &&\n            value.kind === ts.SyntaxKind.Identifier &&\n            name.getText() === value.getText()) {\n            // Delete from name start up to value to include the ':'.\n            var lengthToValueStart = value.getStart() - name.getStart();\n            var fix = this.deleteText(name.getStart(), lengthToValueStart);\n            this.addFailureAtNode(node, Rule.LONGHAND_PROPERTY + (\"('{\" + name.getText() + \"}').\"), fix);\n        }\n        if (value.kind === ts.SyntaxKind.FunctionExpression) {\n            var fnNode = value;\n            if (fnNode.name) {\n                return; // named function expressions are OK.\n            }\n            var star = fnNode.asteriskToken ? fnNode.asteriskToken.getText() : \"\";\n            this.addFailureAtNode(node, Rule.LONGHAND_METHOD + (\"('{\" + name.getText() + star + \"() {...}}').\"));\n        }\n        _super.prototype.visitPropertyAssignment.call(this, node);\n    };\n    return ObjectLiteralShorthandWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/oneLineRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_BRACE = \"check-open-brace\";\nvar OPTION_CATCH = \"check-catch\";\nvar OPTION_ELSE = \"check-else\";\nvar OPTION_FINALLY = \"check-finally\";\nvar OPTION_WHITESPACE = \"check-whitespace\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var oneLineWalker = new OneLineWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(oneLineWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"one-line\",\n    description: \"Requires the specified tokens to be on the same line as the expression preceding them.\",\n    optionsDescription: (_a = [\"\\n            Five arguments may be optionally provided:\\n\\n            * `\\\"check-catch\\\"` checks that `catch` is on the same line as the closing brace for `try`.\\n            * `\\\"check-finally\\\"` checks that `finally` is on the same line as the closing brace for `catch`.\\n            * `\\\"check-else\\\"` checks that `else` is on the same line as the closing brace for `if`.\\n            * `\\\"check-open-brace\\\"` checks that an open brace falls on the same line as its preceding expression.\\n            * `\\\"check-whitespace\\\"` checks preceding whitespace for the specified tokens.\"], _a.raw = [\"\\n            Five arguments may be optionally provided:\\n\\n            * \\\\`\\\"check-catch\\\"\\\\` checks that \\\\`catch\\\\` is on the same line as the closing brace for \\\\`try\\\\`.\\n            * \\\\`\\\"check-finally\\\"\\\\` checks that \\\\`finally\\\\` is on the same line as the closing brace for \\\\`catch\\\\`.\\n            * \\\\`\\\"check-else\\\"\\\\` checks that \\\\`else\\\\` is on the same line as the closing brace for \\\\`if\\\\`.\\n            * \\\\`\\\"check-open-brace\\\"\\\\` checks that an open brace falls on the same line as its preceding expression.\\n            * \\\\`\\\"check-whitespace\\\"\\\\` checks preceding whitespace for the specified tokens.\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [\"check-catch\", \"check-finally\", \"check-else\", \"check-open-brace\", \"check-whitespace\"],\n        },\n        minLength: 0,\n        maxLength: 5,\n    },\n    optionExamples: ['[true, \"check-catch\", \"check-finally\", \"check-else\"]'],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.BRACE_FAILURE_STRING = \"misplaced opening brace\";\nRule.CATCH_FAILURE_STRING = \"misplaced 'catch'\";\nRule.ELSE_FAILURE_STRING = \"misplaced 'else'\";\nRule.FINALLY_FAILURE_STRING = \"misplaced 'finally'\";\nRule.WHITESPACE_FAILURE_STRING = \"missing whitespace\";\nexports.Rule = Rule;\nvar OneLineWalker = (function (_super) {\n    __extends(OneLineWalker, _super);\n    function OneLineWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OneLineWalker.prototype.visitIfStatement = function (node) {\n        var thenStatement = node.thenStatement;\n        var thenIsBlock = thenStatement.kind === ts.SyntaxKind.Block;\n        if (thenIsBlock) {\n            var expressionCloseParen = node.getChildAt(3);\n            var thenOpeningBrace = thenStatement.getChildAt(0);\n            this.handleOpeningBrace(expressionCloseParen, thenOpeningBrace);\n        }\n        var elseStatement = node.elseStatement;\n        if (elseStatement != null) {\n            // find the else keyword\n            var elseKeyword = Lint.childOfKind(node, ts.SyntaxKind.ElseKeyword);\n            if (elseStatement.kind === ts.SyntaxKind.Block) {\n                var elseOpeningBrace = elseStatement.getChildAt(0);\n                this.handleOpeningBrace(elseKeyword, elseOpeningBrace);\n            }\n            if (thenIsBlock && this.hasOption(OPTION_ELSE)) {\n                var thenStatementEndLine = this.getLineAndCharacterOfPosition(thenStatement.getEnd()).line;\n                var elseKeywordLine = this.getLineAndCharacterOfPosition(elseKeyword.getStart()).line;\n                if (thenStatementEndLine !== elseKeywordLine) {\n                    this.addFailureAtNode(elseKeyword, Rule.ELSE_FAILURE_STRING);\n                }\n            }\n        }\n        _super.prototype.visitIfStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitCatchClause = function (node) {\n        var catchClosingParen = Lint.childOfKind(node, ts.SyntaxKind.CloseParenToken);\n        var catchOpeningBrace = node.block.getChildAt(0);\n        this.handleOpeningBrace(catchClosingParen, catchOpeningBrace);\n        _super.prototype.visitCatchClause.call(this, node);\n    };\n    OneLineWalker.prototype.visitTryStatement = function (node) {\n        var catchClause = node.catchClause;\n        var finallyBlock = node.finallyBlock;\n        var finallyKeyword = Lint.childOfKind(node, ts.SyntaxKind.FinallyKeyword);\n        // \"visit\" try block\n        var tryKeyword = node.getChildAt(0);\n        var tryBlock = node.tryBlock;\n        var tryOpeningBrace = tryBlock.getChildAt(0);\n        this.handleOpeningBrace(tryKeyword, tryOpeningBrace);\n        if (this.hasOption(OPTION_CATCH) && catchClause != null) {\n            var tryClosingBrace = node.tryBlock.getChildAt(node.tryBlock.getChildCount() - 1);\n            var catchKeyword = catchClause.getChildAt(0);\n            var tryClosingBraceLine = this.getLineAndCharacterOfPosition(tryClosingBrace.getEnd()).line;\n            var catchKeywordLine = this.getLineAndCharacterOfPosition(catchKeyword.getStart()).line;\n            if (tryClosingBraceLine !== catchKeywordLine) {\n                this.addFailureAtNode(catchKeyword, Rule.CATCH_FAILURE_STRING);\n            }\n        }\n        if (finallyBlock != null && finallyKeyword != null) {\n            var finallyOpeningBrace = finallyBlock.getChildAt(0);\n            this.handleOpeningBrace(finallyKeyword, finallyOpeningBrace);\n            if (this.hasOption(OPTION_FINALLY)) {\n                var previousBlock = catchClause != null ? catchClause.block : node.tryBlock;\n                var closingBrace = previousBlock.getChildAt(previousBlock.getChildCount() - 1);\n                var closingBraceLine = this.getLineAndCharacterOfPosition(closingBrace.getEnd()).line;\n                var finallyKeywordLine = this.getLineAndCharacterOfPosition(finallyKeyword.getStart()).line;\n                if (closingBraceLine !== finallyKeywordLine) {\n                    this.addFailureAtNode(finallyKeyword, Rule.FINALLY_FAILURE_STRING);\n                }\n            }\n        }\n        _super.prototype.visitTryStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitForStatement = function (node) {\n        this.handleIterationStatement(node);\n        _super.prototype.visitForStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitForInStatement = function (node) {\n        this.handleIterationStatement(node);\n        _super.prototype.visitForInStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitWhileStatement = function (node) {\n        this.handleIterationStatement(node);\n        _super.prototype.visitWhileStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitBinaryExpression = function (node) {\n        var rightkind = node.right.kind;\n        var opkind = node.operatorToken.kind;\n        if (opkind === ts.SyntaxKind.EqualsToken && rightkind === ts.SyntaxKind.ObjectLiteralExpression) {\n            var equalsToken = node.getChildAt(1);\n            var openBraceToken = node.right.getChildAt(0);\n            this.handleOpeningBrace(equalsToken, openBraceToken);\n        }\n        _super.prototype.visitBinaryExpression.call(this, node);\n    };\n    OneLineWalker.prototype.visitVariableDeclaration = function (node) {\n        var initializer = node.initializer;\n        if (initializer != null && initializer.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            var equalsToken = Lint.childOfKind(node, ts.SyntaxKind.EqualsToken);\n            var openBraceToken = initializer.getChildAt(0);\n            this.handleOpeningBrace(equalsToken, openBraceToken);\n        }\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitDoStatement = function (node) {\n        var doKeyword = node.getChildAt(0);\n        var statement = node.statement;\n        if (statement.kind === ts.SyntaxKind.Block) {\n            var openBraceToken = statement.getChildAt(0);\n            this.handleOpeningBrace(doKeyword, openBraceToken);\n        }\n        _super.prototype.visitDoStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitModuleDeclaration = function (node) {\n        var nameNode = node.name;\n        var body = node.body;\n        if (body != null && body.kind === ts.SyntaxKind.ModuleBlock) {\n            var openBraceToken = body.getChildAt(0);\n            this.handleOpeningBrace(nameNode, openBraceToken);\n        }\n        _super.prototype.visitModuleDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitEnumDeclaration = function (node) {\n        var nameNode = node.name;\n        var openBraceToken = Lint.childOfKind(node, ts.SyntaxKind.OpenBraceToken);\n        this.handleOpeningBrace(nameNode, openBraceToken);\n        _super.prototype.visitEnumDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitSwitchStatement = function (node) {\n        var closeParenToken = node.getChildAt(3);\n        var openBraceToken = node.caseBlock.getChildAt(0);\n        this.handleOpeningBrace(closeParenToken, openBraceToken);\n        _super.prototype.visitSwitchStatement.call(this, node);\n    };\n    OneLineWalker.prototype.visitInterfaceDeclaration = function (node) {\n        this.handleClassLikeDeclaration(node);\n        _super.prototype.visitInterfaceDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitClassDeclaration = function (node) {\n        this.handleClassLikeDeclaration(node);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.handleFunctionLikeDeclaration(node);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitMethodDeclaration = function (node) {\n        this.handleFunctionLikeDeclaration(node);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitConstructorDeclaration = function (node) {\n        this.handleFunctionLikeDeclaration(node);\n        _super.prototype.visitConstructorDeclaration.call(this, node);\n    };\n    OneLineWalker.prototype.visitArrowFunction = function (node) {\n        var body = node.body;\n        if (body != null && body.kind === ts.SyntaxKind.Block) {\n            var arrowToken = Lint.childOfKind(node, ts.SyntaxKind.EqualsGreaterThanToken);\n            var openBraceToken = body.getChildAt(0);\n            this.handleOpeningBrace(arrowToken, openBraceToken);\n        }\n        _super.prototype.visitArrowFunction.call(this, node);\n    };\n    OneLineWalker.prototype.handleFunctionLikeDeclaration = function (node) {\n        var body = node.body;\n        if (body != null && body.kind === ts.SyntaxKind.Block) {\n            var openBraceToken = body.getChildAt(0);\n            if (node.type != null) {\n                this.handleOpeningBrace(node.type, openBraceToken);\n            }\n            else {\n                var closeParenToken = Lint.childOfKind(node, ts.SyntaxKind.CloseParenToken);\n                this.handleOpeningBrace(closeParenToken, openBraceToken);\n            }\n        }\n    };\n    OneLineWalker.prototype.handleClassLikeDeclaration = function (node) {\n        var lastNodeOfDeclaration = node.name;\n        var openBraceToken = Lint.childOfKind(node, ts.SyntaxKind.OpenBraceToken);\n        if (node.heritageClauses != null) {\n            lastNodeOfDeclaration = node.heritageClauses[node.heritageClauses.length - 1];\n        }\n        else if (node.typeParameters != null) {\n            lastNodeOfDeclaration = node.typeParameters[node.typeParameters.length - 1];\n        }\n        this.handleOpeningBrace(lastNodeOfDeclaration, openBraceToken);\n    };\n    OneLineWalker.prototype.handleIterationStatement = function (node) {\n        // last child is the statement, second to last child is the close paren\n        var closeParenToken = node.getChildAt(node.getChildCount() - 2);\n        var statement = node.statement;\n        if (statement.kind === ts.SyntaxKind.Block) {\n            var openBraceToken = statement.getChildAt(0);\n            this.handleOpeningBrace(closeParenToken, openBraceToken);\n        }\n    };\n    OneLineWalker.prototype.handleOpeningBrace = function (previousNode, openBraceToken) {\n        if (previousNode == null || openBraceToken == null) {\n            return;\n        }\n        var previousNodeLine = this.getLineAndCharacterOfPosition(previousNode.getEnd()).line;\n        var openBraceLine = this.getLineAndCharacterOfPosition(openBraceToken.getStart()).line;\n        var failure;\n        if (this.hasOption(OPTION_BRACE) && previousNodeLine !== openBraceLine) {\n            failure = Rule.BRACE_FAILURE_STRING;\n        }\n        else if (this.hasOption(OPTION_WHITESPACE) && previousNode.getEnd() === openBraceToken.getStart()) {\n            failure = Rule.WHITESPACE_FAILURE_STRING;\n        }\n        if (failure) {\n            this.addFailureAtNode(openBraceToken, failure);\n        }\n    };\n    return OneLineWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/oneVariablePerDeclarationRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_IGNORE_FOR_LOOP = \"ignore-for-loop\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var oneVarWalker = new OneVariablePerDeclarationWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(oneVarWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"one-variable-per-declaration\",\n    description: \"Disallows multiple variable definitions in the same declaration statement.\",\n    optionsDescription: (_a = [\"\\n            One argument may be optionally provided:\\n\\n            * `\", \"` allows multiple variable definitions in a for loop declaration.\"], _a.raw = [\"\\n            One argument may be optionally provided:\\n\\n            * \\\\`\", \"\\\\` allows multiple variable definitions in a for loop declaration.\"], Lint.Utils.dedent(_a, OPTION_IGNORE_FOR_LOOP)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_IGNORE_FOR_LOOP],\n        },\n        minLength: 0,\n        maxLength: 1,\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + OPTION_IGNORE_FOR_LOOP + \"\\\"]\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Multiple variable declarations in the same statement are forbidden\";\nexports.Rule = Rule;\nvar OneVariablePerDeclarationWalker = (function (_super) {\n    __extends(OneVariablePerDeclarationWalker, _super);\n    function OneVariablePerDeclarationWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OneVariablePerDeclarationWalker.prototype.visitVariableStatement = function (node) {\n        var declarationList = node.declarationList;\n        if (declarationList.declarations.length > 1) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitVariableStatement.call(this, node);\n    };\n    OneVariablePerDeclarationWalker.prototype.visitForStatement = function (node) {\n        var initializer = node.initializer;\n        var shouldIgnoreForLoop = this.hasOption(OPTION_IGNORE_FOR_LOOP);\n        if (!shouldIgnoreForLoop\n            && initializer != null\n            && initializer.kind === ts.SyntaxKind.VariableDeclarationList\n            && initializer.declarations.length > 1) {\n            this.addFailureAtNode(initializer, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitForStatement.call(this, node);\n    };\n    return OneVariablePerDeclarationWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/orderedImportsRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var orderedImportsWalker = new OrderedImportsWalker(sourceFile, this.getOptions());\n        return this.applyWithWalker(orderedImportsWalker);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"ordered-imports\",\n    description: \"Requires that import statements be alphabetized.\",\n    descriptionDetails: (_a = [\"\\n            Enforce a consistent ordering for ES6 imports:\\n            - Named imports must be alphabetized (i.e. \\\"import {A, B, C} from \\\"foo\\\";\\\")\\n                - The exact ordering can be controlled by the named-imports-order option.\\n                - \\\"longName as name\\\" imports are ordered by \\\"longName\\\".\\n            - Import sources must be alphabetized within groups, i.e.:\\n                    import * as foo from \\\"a\\\";\\n                    import * as bar from \\\"b\\\";\\n            - Groups of imports are delineated by blank lines. You can use these to group imports\\n                however you like, e.g. by first- vs. third-party or thematically.\"], _a.raw = [\"\\n            Enforce a consistent ordering for ES6 imports:\\n            - Named imports must be alphabetized (i.e. \\\"import {A, B, C} from \\\"foo\\\";\\\")\\n                - The exact ordering can be controlled by the named-imports-order option.\\n                - \\\"longName as name\\\" imports are ordered by \\\"longName\\\".\\n            - Import sources must be alphabetized within groups, i.e.:\\n                    import * as foo from \\\"a\\\";\\n                    import * as bar from \\\"b\\\";\\n            - Groups of imports are delineated by blank lines. You can use these to group imports\\n                however you like, e.g. by first- vs. third-party or thematically.\"], Lint.Utils.dedent(_a)),\n    hasFix: true,\n    optionsDescription: (_b = [\"\\n            You may set the `\\\"import-sources-order\\\"` option to control the ordering of source\\n            imports (the `\\\"foo\\\"` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"import-sources-order\\\"` are:\\n\\n            * `\\\"case-insensitive'`: Correct order is `\\\"Bar\\\"`, `\\\"baz\\\"`, `\\\"Foo\\\"`. (This is the default.)\\n            * `\\\"lowercase-first\\\"`: Correct order is `\\\"baz\\\"`, `\\\"Bar\\\"`, `\\\"Foo\\\"`.\\n            * `\\\"lowercase-last\\\"`: Correct order is `\\\"Bar\\\"`, `\\\"Foo\\\"`, `\\\"baz\\\"`.\\n            * `\\\"any\\\"`: Allow any order.\\n\\n            You may set the `\\\"named-imports-order\\\"` option to control the ordering of named\\n            imports (the `{A, B, C}` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"named-imports-order\\\"` are:\\n\\n            * `\\\"case-insensitive'`: Correct order is `{A, b, C}`. (This is the default.)\\n            * `\\\"lowercase-first\\\"`: Correct order is `{b, A, C}`.\\n            * `\\\"lowercase-last\\\"`: Correct order is `{A, C, b}`.\\n            * `\\\"any\\\"`: Allow any order.\\n\\n        \"], _b.raw = [\"\\n            You may set the \\\\`\\\"import-sources-order\\\"\\\\` option to control the ordering of source\\n            imports (the \\\\`\\\"foo\\\"\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"import-sources-order\\\"\\\\` are:\\n\\n            * \\\\`\\\"case-insensitive'\\\\`: Correct order is \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"baz\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`. (This is the default.)\\n            * \\\\`\\\"lowercase-first\\\"\\\\`: Correct order is \\\\`\\\"baz\\\"\\\\`, \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`.\\n            * \\\\`\\\"lowercase-last\\\"\\\\`: Correct order is \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`, \\\\`\\\"baz\\\"\\\\`.\\n            * \\\\`\\\"any\\\"\\\\`: Allow any order.\\n\\n            You may set the \\\\`\\\"named-imports-order\\\"\\\\` option to control the ordering of named\\n            imports (the \\\\`{A, B, C}\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"named-imports-order\\\"\\\\` are:\\n\\n            * \\\\`\\\"case-insensitive'\\\\`: Correct order is \\\\`{A, b, C}\\\\`. (This is the default.)\\n            * \\\\`\\\"lowercase-first\\\"\\\\`: Correct order is \\\\`{b, A, C}\\\\`.\\n            * \\\\`\\\"lowercase-last\\\"\\\\`: Correct order is \\\\`{A, C, b}\\\\`.\\n            * \\\\`\\\"any\\\"\\\\`: Allow any order.\\n\\n        \"], Lint.Utils.dedent(_b)),\n    options: {\n        type: \"object\",\n        properties: {\n            \"import-sources-order\": {\n                type: \"string\",\n                enum: [\"case-insensitive\", \"lowercase-first\", \"lowercase-last\", \"any\"],\n            },\n            \"named-imports-order\": {\n                type: \"string\",\n                enum: [\"case-insensitive\", \"lowercase-first\", \"lowercase-last\", \"any\"],\n            },\n        },\n        additionalProperties: false,\n    },\n    optionExamples: [\n        \"true\",\n        '[true, {\"import-sources-order\": \"lowercase-last\", \"named-imports-order\": \"lowercase-first\"}]',\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.IMPORT_SOURCES_UNORDERED = \"Import sources within a group must be alphabetized.\";\nRule.NAMED_IMPORTS_UNORDERED = \"Named imports must be alphabetized.\";\nexports.Rule = Rule;\n// Convert aBcD --> AbCd\nfunction flipCase(x) {\n    return x.split(\"\").map(function (char) {\n        if (char >= \"a\" && char <= \"z\") {\n            return char.toUpperCase();\n        }\n        else if (char >= \"A\" && char <= \"Z\") {\n            return char.toLowerCase();\n        }\n        return char;\n    }).join(\"\");\n}\n// After applying a transformation, are the nodes sorted according to the text they contain?\n// If not, return the pair of nodes which are out of order.\nfunction findUnsortedPair(xs, transform) {\n    for (var i = 1; i < xs.length; i++) {\n        if (transform(xs[i].getText()) < transform(xs[i - 1].getText())) {\n            return [xs[i - 1], xs[i]];\n        }\n    }\n    return null;\n}\nfunction compare(a, b) {\n    var isLow = function (value) {\n        return [\".\", \"/\"].some(function (x) { return value[0] === x; });\n    };\n    if (isLow(a) && !isLow(b)) {\n        return 1;\n    }\n    else if (!isLow(a) && isLow(b)) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else if (a < b) {\n        return -1;\n    }\n    return 0;\n}\nfunction removeQuotes(value) {\n    // strip out quotes\n    if (value && value.length > 1 && (value[0] === \"'\" || value[0] === \"\\\"\")) {\n        value = value.substr(1, value.length - 2);\n    }\n    return value;\n}\nfunction sortByKey(xs, getSortKey) {\n    return xs.slice().sort(function (a, b) {\n        return compare(getSortKey(a), getSortKey(b));\n    });\n}\n// Transformations to apply to produce the desired ordering of imports.\n// The imports must be lexicographically sorted after applying the transform.\nvar TRANSFORMS = {\n    \"any\": function () { return \"\"; },\n    \"case-insensitive\": function (x) { return x.toLowerCase(); },\n    \"lowercase-first\": flipCase,\n    \"lowercase-last\": function (x) { return x; },\n};\nvar OrderedImportsWalker = (function (_super) {\n    __extends(OrderedImportsWalker, _super);\n    function OrderedImportsWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.currentImportsBlock = new ImportsBlock();\n        var optionSet = _this.getOptions()[0] || {};\n        _this.importSourcesOrderTransform =\n            TRANSFORMS[optionSet[\"import-sources-order\"] || \"case-insensitive\"];\n        _this.namedImportsOrderTransform =\n            TRANSFORMS[optionSet[\"named-imports-order\"] || \"case-insensitive\"];\n        return _this;\n    }\n    // e.g. \"import Foo from \"./foo\";\"\n    OrderedImportsWalker.prototype.visitImportDeclaration = function (node) {\n        var source = node.moduleSpecifier.getText();\n        source = removeQuotes(source);\n        source = this.importSourcesOrderTransform(source);\n        var previousSource = this.currentImportsBlock.getLastImportSource();\n        this.currentImportsBlock.addImportDeclaration(this.getSourceFile(), node, source);\n        if (previousSource && compare(source, previousSource) === -1) {\n            this.lastFix = [];\n            this.addFailureAtNode(node, Rule.IMPORT_SOURCES_UNORDERED, this.lastFix);\n        }\n        _super.prototype.visitImportDeclaration.call(this, node);\n    };\n    // This is the \"{A, B, C}\" of \"import {A, B, C} from \"./foo\";\".\n    // We need to make sure they're alphabetized.\n    OrderedImportsWalker.prototype.visitNamedImports = function (node) {\n        var _this = this;\n        var imports = node.elements;\n        var pair = findUnsortedPair(imports, this.namedImportsOrderTransform);\n        if (pair !== null) {\n            var a = pair[0], b = pair[1];\n            var sortedDeclarations = sortByKey(imports, function (x) { return _this.namedImportsOrderTransform(x.getText()); }).map(function (x) { return x.getText(); });\n            // replace in reverse order to preserve earlier offsets\n            for (var i = imports.length - 1; i >= 0; i--) {\n                var start = imports[i].getStart();\n                var length = imports[i].getText().length;\n                // replace the named imports one at a time to preserve whitespace\n                this.currentImportsBlock.replaceNamedImports(start, length, sortedDeclarations[i]);\n            }\n            this.lastFix = [];\n            this.addFailureFromStartToEnd(a.getStart(), b.getEnd(), Rule.NAMED_IMPORTS_UNORDERED, this.lastFix);\n        }\n        _super.prototype.visitNamedImports.call(this, node);\n    };\n    // keep reading the block of import declarations until the block ends, then replace the entire block\n    // this allows the reorder of named imports to work well with reordering lines\n    OrderedImportsWalker.prototype.visitNode = function (node) {\n        var prefixLength = node.getStart() - node.getFullStart();\n        var prefix = node.getFullText().slice(0, prefixLength);\n        var hasBlankLine = prefix.indexOf(\"\\n\\n\") >= 0 || prefix.indexOf(\"\\r\\n\\r\\n\") >= 0;\n        var notImportDeclaration = node.parent != null\n            && node.parent.kind === ts.SyntaxKind.SourceFile\n            && node.kind !== ts.SyntaxKind.ImportDeclaration;\n        if (hasBlankLine || notImportDeclaration) {\n            // end of block\n            if (this.lastFix != null) {\n                var replacement = this.currentImportsBlock.getReplacement();\n                if (replacement != null) {\n                    this.lastFix.push(replacement);\n                }\n                this.lastFix = null;\n            }\n            this.currentImportsBlock = new ImportsBlock();\n        }\n        _super.prototype.visitNode.call(this, node);\n    };\n    return OrderedImportsWalker;\n}(Lint.RuleWalker));\nvar ImportsBlock = (function () {\n    function ImportsBlock() {\n        this.importDeclarations = [];\n    }\n    ImportsBlock.prototype.addImportDeclaration = function (sourceFile, node, sourcePath) {\n        var start = this.getStartOffset(node);\n        var end = this.getEndOffset(sourceFile, node);\n        var text = sourceFile.text.substring(start, end);\n        if (start > node.getStart() || end === 0) {\n            // skip block if any statements don't end with a newline to simplify implementation\n            this.importDeclarations = [];\n            return;\n        }\n        this.importDeclarations.push({\n            node: node,\n            nodeEndOffset: end,\n            nodeStartOffset: start,\n            sourcePath: sourcePath,\n            text: text,\n        });\n    };\n    // replaces the named imports on the most recent import declaration\n    ImportsBlock.prototype.replaceNamedImports = function (fileOffset, length, replacement) {\n        var importDeclaration = this.getLastImportDeclaration();\n        if (importDeclaration == null) {\n            // nothing to replace. This can happen if the block is skipped\n            return;\n        }\n        var start = fileOffset - importDeclaration.nodeStartOffset;\n        if (start < 0 || start + length > importDeclaration.node.getEnd()) {\n            throw new Error(\"Unexpected named import position\");\n        }\n        var initialText = importDeclaration.text;\n        importDeclaration.text = initialText.substring(0, start) + replacement + initialText.substring(start + length);\n    };\n    ImportsBlock.prototype.getLastImportSource = function () {\n        if (this.importDeclarations.length === 0) {\n            return null;\n        }\n        return this.getLastImportDeclaration().sourcePath;\n    };\n    // creates a Lint.Replacement object with ordering fixes for the entire block\n    ImportsBlock.prototype.getReplacement = function () {\n        if (this.importDeclarations.length === 0) {\n            return null;\n        }\n        var sortedDeclarations = sortByKey(this.importDeclarations.slice(), function (x) { return x.sourcePath; });\n        var fixedText = sortedDeclarations.map(function (x) { return x.text; }).join(\"\");\n        var start = this.importDeclarations[0].nodeStartOffset;\n        var end = this.getLastImportDeclaration().nodeEndOffset;\n        return new Lint.Replacement(start, end - start, fixedText);\n    };\n    // gets the offset immediately after the end of the previous declaration to include comment above\n    ImportsBlock.prototype.getStartOffset = function (node) {\n        if (this.importDeclarations.length === 0) {\n            return node.getStart();\n        }\n        return this.getLastImportDeclaration().nodeEndOffset;\n    };\n    // gets the offset of the end of the import's line, including newline, to include comment to the right\n    ImportsBlock.prototype.getEndOffset = function (sourceFile, node) {\n        var endLineOffset = sourceFile.text.indexOf(\"\\n\", node.end) + 1;\n        return endLineOffset;\n    };\n    ImportsBlock.prototype.getLastImportDeclaration = function () {\n        return this.importDeclarations[this.importDeclarations.length - 1];\n    };\n    return ImportsBlock;\n}());\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/preferFunctionOverMethodRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_PUBLIC = \"allow-public\";\nvar OPTION_ALLOW_PROTECTED = \"allow-protected\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new PreferFunctionOverMethodWalker(sourceFile, this.ruleName, {\n            allowProtected: this.ruleArguments.indexOf(OPTION_ALLOW_PROTECTED) !== -1,\n            allowPublic: this.ruleArguments.indexOf(OPTION_ALLOW_PUBLIC) !== -1,\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"prefer-function-over-method\",\n    description: \"Warns for class methods that do not use 'this'.\",\n    optionsDescription: (_a = [\"\\n            \\\"\", \"\\\" excludes checking of public methods.\\n            \\\"\", \"\\\" excludes checking of protected methods.\"], _a.raw = [\"\\n            \\\"\", \"\\\" excludes checking of public methods.\\n            \\\"\", \"\\\" excludes checking of protected methods.\"], Lint.Utils.dedent(_a, OPTION_ALLOW_PUBLIC, OPTION_ALLOW_PROTECTED)),\n    options: {\n        type: \"string\",\n        enum: [OPTION_ALLOW_PUBLIC, OPTION_ALLOW_PROTECTED],\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"\" + OPTION_ALLOW_PUBLIC + \"\\\", \\\"\" + OPTION_ALLOW_PROTECTED + \"\\\"]\",\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Class method does not use 'this'. Use a function instead.\";\nexports.Rule = Rule;\nvar PreferFunctionOverMethodWalker = (function (_super) {\n    __extends(PreferFunctionOverMethodWalker, _super);\n    function PreferFunctionOverMethodWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PreferFunctionOverMethodWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (tsutils_1.isMethodDeclaration(node) && !_this.isExempt(node)) {\n                // currentScope is always undefined here, so we don't need to save it and just set it to undefined afterwards\n                var scope = _this.currentScope = {\n                    isThisUsed: false,\n                    name: tsutils_1.getPropertyName(node.name),\n                };\n                ts.forEachChild(node, cb);\n                if (!scope.isThisUsed) {\n                    _this.addFailureAtNode(node.name, Rule.FAILURE_STRING);\n                }\n                _this.currentScope = undefined;\n            }\n            else if (tsutils_1.hasOwnThisReference(node)) {\n                var scope = _this.currentScope;\n                _this.currentScope = undefined;\n                ts.forEachChild(node, cb);\n                _this.currentScope = scope;\n            }\n            else if (_this.currentScope !== undefined &&\n                (node.kind === ts.SyntaxKind.ThisKeyword && !isRecursiveCall(node, _this.currentScope.name) ||\n                    node.kind === ts.SyntaxKind.SuperKeyword)) {\n                _this.currentScope.isThisUsed = true;\n            }\n            else {\n                return ts.forEachChild(node, cb);\n            }\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    PreferFunctionOverMethodWalker.prototype.isExempt = function (node) {\n        // TODO: handle the override keyword once it lands in the language\n        return node.body === undefined ||\n            // exclude object methods\n            node.parent.kind !== ts.SyntaxKind.ClassDeclaration && node.parent.kind !== ts.SyntaxKind.ClassExpression ||\n            tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword) ||\n            this.options.allowProtected && tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword) ||\n            this.options.allowPublic && (tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword) ||\n                !tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword));\n    };\n    return PreferFunctionOverMethodWalker;\n}(Lint.AbstractWalker));\nfunction isRecursiveCall(node, name) {\n    return name !== undefined &&\n        node.parent.kind === ts.SyntaxKind.PropertyAccessExpression &&\n        node.parent.name.text === name;\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/preferMethodSignatureRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"prefer-method-signature\",\n    description: \"Prefer `foo(): void` over `foo: () => void` in interfaces and types.\",\n    hasFix: true,\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Use a method signature instead of a property signature of function type.\";\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitPropertySignature = function (node) {\n        var type = node.type;\n        if (type !== undefined && type.kind === ts.SyntaxKind.FunctionType) {\n            this.addFailureAtNode(node.name, Rule.FAILURE_STRING, this.createMethodSignatureFix(node, type));\n        }\n        _super.prototype.visitPropertySignature.call(this, node);\n    };\n    Walker.prototype.createMethodSignatureFix = function (node, type) {\n        return type.type && [\n            this.deleteFromTo(Lint.childOfKind(node, ts.SyntaxKind.ColonToken).getStart(), type.getStart()),\n            this.deleteFromTo(Lint.childOfKind(type, ts.SyntaxKind.EqualsGreaterThanToken).getStart(), type.type.getStart()),\n            this.appendText(Lint.childOfKind(type, ts.SyntaxKind.CloseParenToken).end, \":\"),\n        ];\n    };\n    return Walker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/preferTemplateRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_SINGLE_CONCAT = \"allow-single-concat\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        if (sourceFile.isDeclarationFile) {\n            return []; // Not possible in a declaration file\n        }\n        var allowSingleConcat = this.ruleArguments.indexOf(OPTION_SINGLE_CONCAT) !== -1;\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, allowSingleConcat); });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"prefer-template\",\n    description: \"Prefer a template expression over string literal concatenation.\",\n    optionsDescription: (_a = [\"\\n            If `\", \"` is specified, then a single concatenation (`x + y`) is allowed, but not more (`x + y + z`).\"], _a.raw = [\"\\n            If \\\\`\", \"\\\\` is specified, then a single concatenation (\\\\`x + y\\\\`) is allowed, but not more (\\\\`x + y + z\\\\`).\"], Lint.Utils.dedent(_a, OPTION_SINGLE_CONCAT)),\n    options: {\n        type: \"string\",\n        enum: [OPTION_SINGLE_CONCAT],\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + OPTION_SINGLE_CONCAT + \"\\\"]\"],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"Use a template literal instead of concatenating with a string literal.\";\nRule.FAILURE_STRING_MULTILINE = \"Use a multiline template literal instead of concatenating string literals with newlines.\";\nexports.Rule = Rule;\nfunction walk(ctx, allowSingleConcat) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        var failure = getError(node, allowSingleConcat);\n        if (failure) {\n            ctx.addFailureAtNode(node, failure);\n        }\n        else {\n            return ts.forEachChild(node, cb);\n        }\n    });\n}\nfunction getError(node, allowSingleConcat) {\n    if (!isPlusExpression(node)) {\n        return undefined;\n    }\n    var left = node.left, right = node.right;\n    var l = isStringLike(left);\n    var r = isStringLike(right);\n    if (l && r) {\n        // They're both strings.\n        // If they're joined by a newline, recommend a template expression instead.\n        // Otherwise ignore. (\"a\" + \"b\", probably writing a long newline-less string on many lines.)\n        return containsNewline(left) || containsNewline(right) ? Rule.FAILURE_STRING_MULTILINE : undefined;\n    }\n    else if (!l && !r) {\n        // Watch out for `\"a\" + b + c`.\n        return containsAnyStringLiterals(left) ? Rule.FAILURE_STRING : undefined;\n    }\n    else if (l) {\n        // `\"x\" + y`\n        return !allowSingleConcat ? Rule.FAILURE_STRING : undefined;\n    }\n    else {\n        // `? + \"b\"`\n        return !allowSingleConcat || isPlusExpression(left) ? Rule.FAILURE_STRING : undefined;\n    }\n}\nfunction containsNewline(node) {\n    if (node.kind === ts.SyntaxKind.TemplateExpression) {\n        return node.templateSpans.some(function (_a) {\n            var text = _a.literal.text;\n            return text.includes(\"\\n\");\n        });\n    }\n    else {\n        return node.text.includes(\"\\n\");\n    }\n}\nfunction containsAnyStringLiterals(node) {\n    if (!isPlusExpression(node)) {\n        return false;\n    }\n    var left = node.left, right = node.right;\n    return isStringLike(right) || isStringLike(left) || containsAnyStringLiterals(left);\n}\nfunction isPlusExpression(node) {\n    return tsutils_1.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.PlusToken;\n}\nfunction isStringLike(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n        case ts.SyntaxKind.TemplateExpression:\n            return true;\n        default:\n            return false;\n    }\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/quotemarkRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_SINGLE = \"single\";\nvar OPTION_DOUBLE = \"double\";\nvar OPTION_JSX_SINGLE = \"jsx-single\";\nvar OPTION_JSX_DOUBLE = \"jsx-double\";\nvar OPTION_AVOID_ESCAPE = \"avoid-escape\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (actual, expected) {\n        return actual + \" should be \" + expected;\n    };\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && (this.ruleArguments[0] === OPTION_SINGLE || this.ruleArguments[0] === OPTION_DOUBLE);\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var args = this.ruleArguments;\n        var quoteMark = args[0] === OPTION_SINGLE ? \"'\" : '\"';\n        return this.applyWithFunction(sourceFile, walk, {\n            quoteMark: quoteMark,\n            avoidEscape: args.indexOf(OPTION_AVOID_ESCAPE) !== -1,\n            jsxQuoteMark: args.indexOf(OPTION_JSX_SINGLE) !== -1\n                ? \"'\"\n                : args.indexOf(OPTION_JSX_DOUBLE) ? '\"' : quoteMark,\n        });\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"quotemark\",\n    description: \"Requires single or double quotes for string literals.\",\n    hasFix: true,\n    optionsDescription: (_a = [\"\\n            Five arguments may be optionally provided:\\n\\n            * `\\\"\", \"\\\"` enforces single quotes.\\n            * `\\\"\", \"\\\"` enforces double quotes.\\n            * `\\\"\", \"\\\"` enforces single quotes for JSX attributes.\\n            * `\\\"\", \"\\\"` enforces double quotes for JSX attributes.\\n            * `\\\"\", \"\\\"` allows you to use the \\\"other\\\" quotemark in cases where escaping would normally be required.\\n            For example, `[true, \\\"\", \"\\\", \\\"\", \"\\\"]` would not report a failure on the string literal\\n            `'Hello \\\"World\\\"'`.\"], _a.raw = [\"\\n            Five arguments may be optionally provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces single quotes.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces double quotes.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces single quotes for JSX attributes.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces double quotes for JSX attributes.\\n            * \\\\`\\\"\", \"\\\"\\\\` allows you to use the \\\"other\\\" quotemark in cases where escaping would normally be required.\\n            For example, \\\\`[true, \\\"\", \"\\\", \\\"\", \"\\\"]\\\\` would not report a failure on the string literal\\n            \\\\`'Hello \\\"World\\\"'\\\\`.\"], Lint.Utils.dedent(_a, OPTION_SINGLE, OPTION_DOUBLE, OPTION_JSX_SINGLE, OPTION_JSX_DOUBLE, OPTION_AVOID_ESCAPE, OPTION_DOUBLE, OPTION_AVOID_ESCAPE)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_SINGLE, OPTION_DOUBLE, OPTION_JSX_SINGLE, OPTION_JSX_DOUBLE, OPTION_AVOID_ESCAPE],\n        },\n        minLength: 0,\n        maxLength: 5,\n    },\n    optionExamples: [\n        \"[true, \\\"\" + OPTION_SINGLE + \"\\\", \\\"\" + OPTION_AVOID_ESCAPE + \"\\\"]\",\n        \"[true, \\\"\" + OPTION_SINGLE + \"\\\", \\\"\" + OPTION_JSX_DOUBLE + \"\\\"]\",\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (node.kind === ts.SyntaxKind.StringLiteral) {\n            var expectedQuoteMark = node.parent.kind === ts.SyntaxKind.JsxAttribute ? ctx.options.jsxQuoteMark : ctx.options.quoteMark;\n            var actualQuoteMark = ctx.sourceFile.text[node.end - 1];\n            if (actualQuoteMark === expectedQuoteMark) {\n                return;\n            }\n            var start = node.getStart(ctx.sourceFile);\n            var text = ctx.sourceFile.text.substring(start + 1, node.end - 1);\n            if (node.text.includes(expectedQuoteMark)) {\n                if (ctx.options.avoidEscape) {\n                    return;\n                }\n                text = text.replace(new RegExp(expectedQuoteMark, \"g\"), \"\\\\\" + expectedQuoteMark);\n            }\n            text = text.replace(new RegExp(\"\\\\\\\\\" + actualQuoteMark, \"g\"), actualQuoteMark);\n            return ctx.addFailure(start, node.end, Rule.FAILURE_STRING(actualQuoteMark, expectedQuoteMark), new Lint.Replacement(start, node.end - start, expectedQuoteMark + text + expectedQuoteMark));\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/returnUndefinedRule.js":"/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar u = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); });\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"return-undefined\",\n    description: \"Prefer `return;` in void functions and `return undefined;` in value-returning functions.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"style\",\n    typescriptOnly: false,\n    requiresTypeInfo: true,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_VALUE_RETURN = \"Value-returning function should use `return undefined;`, not just `return;`.\";\nRule.FAILURE_STRING_VOID_RETURN = \"`void` function should use `return;`, not `return undefined;`.\";\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    return ts.forEachChild(ctx.sourceFile, cb);\n    function cb(node) {\n        check(node);\n        return ts.forEachChild(node, cb);\n    }\n    function check(node) {\n        if (!u.isReturnStatement(node)) {\n            return;\n        }\n        var actualReturnKind = returnKindFromReturn(node);\n        if (actualReturnKind === undefined) {\n            return;\n        }\n        var functionReturningFrom = Lint.ancestorWhere(node, isFunctionLike);\n        if (!functionReturningFrom) {\n            // Return outside of function is invalid\n            return;\n        }\n        var returnKindFromType = getReturnKind(functionReturningFrom, checker);\n        if (returnKindFromType !== undefined && returnKindFromType !== actualReturnKind) {\n            ctx.addFailureAtNode(node, returnKindFromType === ReturnKind.Void ? Rule.FAILURE_STRING_VOID_RETURN : Rule.FAILURE_STRING_VALUE_RETURN);\n        }\n    }\n}\nfunction returnKindFromReturn(node) {\n    if (!node.expression) {\n        return ReturnKind.Void;\n    }\n    else if (u.isIdentifier(node.expression) && node.expression.text === \"undefined\") {\n        return ReturnKind.Value;\n    }\n    else {\n        return undefined;\n    }\n}\nvar ReturnKind;\n(function (ReturnKind) {\n    ReturnKind[ReturnKind[\"Void\"] = 0] = \"Void\";\n    ReturnKind[ReturnKind[\"Value\"] = 1] = \"Value\";\n})(ReturnKind || (ReturnKind = {}));\nfunction getReturnKind(node, checker) {\n    switch (node.kind) {\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.SetAccessor:\n            return ReturnKind.Void;\n        case ts.SyntaxKind.GetAccessor:\n            return ReturnKind.Value;\n        default:\n    }\n    // Go with an explicit type declaration if possible.\n    if (node.type) {\n        return node.type.kind === ts.SyntaxKind.VoidKeyword ? ReturnKind.Void : ReturnKind.Value;\n    }\n    var contextualType = node.kind === ts.SyntaxKind.FunctionExpression || node.kind === ts.SyntaxKind.ArrowFunction\n        ? checker.getContextualType(node)\n        : undefined;\n    var ty = contextualType || checker.getTypeAtLocation(node);\n    if (!ty) {\n        // Type error somewhere. Bail.\n        return undefined;\n    }\n    var sig = checker.getSignaturesOfType(ty, ts.SignatureKind.Call)[0];\n    var returnType = checker.getReturnTypeOfSignature(sig);\n    return Lint.isTypeFlagSet(returnType, ts.TypeFlags.Void) ? ReturnKind.Void : ReturnKind.Value;\n}\nfunction isFunctionLike(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n            return true;\n        default:\n            return false;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/semicolonRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALWAYS = \"always\";\nvar OPTION_NEVER = \"never\";\nvar OPTION_IGNORE_BOUND_CLASS_METHODS = \"ignore-bound-class-methods\";\nvar OPTION_IGNORE_INTERFACES = \"ignore-interfaces\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var options = {\n            always: this.ruleArguments.indexOf(OPTION_NEVER) === -1,\n            boundClassMethods: this.ruleArguments.indexOf(OPTION_IGNORE_BOUND_CLASS_METHODS) === -1,\n            interfaces: this.ruleArguments.indexOf(OPTION_IGNORE_INTERFACES) === -1,\n        };\n        return this.applyWithWalker(new SemicolonWalker(sourceFile, this.ruleName, options));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"semicolon\",\n    description: \"Enforces consistent semicolon usage at the end of every statement.\",\n    hasFix: true,\n    optionsDescription: (_a = [\"\\n            One of the following arguments must be provided:\\n\\n            * `\\\"\", \"\\\"` enforces semicolons at the end of every statement.\\n            * `\\\"\", \"\\\"` disallows semicolons at the end of every statement except for when they are necessary.\\n\\n            The following arguments may be optionally provided:\\n\\n            * `\\\"\", \"\\\"` skips checking semicolons at the end of interface members.\\n            * `\\\"\", \"\\\"` skips checking semicolons at the end of bound class methods.\"], _a.raw = [\"\\n            One of the following arguments must be provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces semicolons at the end of every statement.\\n            * \\\\`\\\"\", \"\\\"\\\\` disallows semicolons at the end of every statement except for when they are necessary.\\n\\n            The following arguments may be optionally provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` skips checking semicolons at the end of interface members.\\n            * \\\\`\\\"\", \"\\\"\\\\` skips checking semicolons at the end of bound class methods.\"], Lint.Utils.dedent(_a, OPTION_ALWAYS, OPTION_NEVER, OPTION_IGNORE_INTERFACES, OPTION_IGNORE_BOUND_CLASS_METHODS)),\n    options: {\n        type: \"array\",\n        items: [{\n                type: \"string\",\n                enum: [OPTION_ALWAYS, OPTION_NEVER],\n            }, {\n                type: \"string\",\n                enum: [OPTION_IGNORE_INTERFACES],\n            }],\n        additionalItems: false,\n    },\n    optionExamples: [\n        \"[true, \\\"\" + OPTION_ALWAYS + \"\\\"]\",\n        \"[true, \\\"\" + OPTION_NEVER + \"\\\"]\",\n        \"[true, \\\"\" + OPTION_ALWAYS + \"\\\", \\\"\" + OPTION_IGNORE_INTERFACES + \"\\\"]\",\n        \"[true, \\\"\" + OPTION_ALWAYS + \"\\\", \\\"\" + OPTION_IGNORE_BOUND_CLASS_METHODS + \"\\\"]\",\n    ],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_MISSING = \"Missing semicolon\";\nRule.FAILURE_STRING_COMMA = \"Properties should be separated by semicolons\";\nRule.FAILURE_STRING_UNNECESSARY = \"Unnecessary semicolon\";\nexports.Rule = Rule;\nvar SemicolonWalker = (function (_super) {\n    __extends(SemicolonWalker, _super);\n    function SemicolonWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.scanner = undefined;\n        return _this;\n    }\n    SemicolonWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            switch (node.kind) {\n                case ts.SyntaxKind.VariableStatement:\n                case ts.SyntaxKind.ExpressionStatement:\n                case ts.SyntaxKind.ReturnStatement:\n                case ts.SyntaxKind.BreakStatement:\n                case ts.SyntaxKind.ContinueStatement:\n                case ts.SyntaxKind.ThrowStatement:\n                case ts.SyntaxKind.ImportEqualsDeclaration:\n                case ts.SyntaxKind.DoStatement:\n                case ts.SyntaxKind.ExportAssignment:\n                    _this.checkSemicolonAt(node);\n                    break;\n                case ts.SyntaxKind.TypeAliasDeclaration:\n                case ts.SyntaxKind.ImportDeclaration:\n                case ts.SyntaxKind.ExportDeclaration:\n                case ts.SyntaxKind.DebuggerStatement:\n                    _this.checkSemicolonOrLineBreak(node);\n                    break;\n                case ts.SyntaxKind.ModuleDeclaration:\n                    // shorthand module declaration\n                    if (node.body === undefined) {\n                        _this.checkSemicolonOrLineBreak(node);\n                    }\n                    break;\n                case ts.SyntaxKind.PropertyDeclaration:\n                    _this.visitPropertyDeclaration(node);\n                    break;\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.FunctionDeclaration:\n                    if (node.body === undefined) {\n                        _this.checkSemicolonOrLineBreak(node);\n                    }\n                    break;\n                case ts.SyntaxKind.InterfaceDeclaration:\n                    if (_this.options.interfaces) {\n                        _this.checkInterface(node);\n                    }\n                    break;\n                case ts.SyntaxKind.SemicolonClassElement:\n                    return _this.reportUnnecessary(node.end - 1);\n                case ts.SyntaxKind.EmptyStatement:\n                    return _this.checkEmptyStatement(node);\n                default:\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    SemicolonWalker.prototype.visitPropertyDeclaration = function (node) {\n        // check if this is a multi-line arrow function\n        if (node.initializer !== undefined &&\n            node.initializer.kind === ts.SyntaxKind.ArrowFunction &&\n            ts.getLineAndCharacterOfPosition(this.sourceFile, node.getStart(this.sourceFile)).line\n                !== ts.getLineAndCharacterOfPosition(this.sourceFile, node.getEnd()).line) {\n            if (this.options.boundClassMethods) {\n                if (this.sourceFile.text[node.end - 1] === \";\" &&\n                    this.isFollowedByLineBreak(node.end)) {\n                    this.reportUnnecessary(node.end - 1);\n                }\n            }\n        }\n        else {\n            this.checkSemicolonOrLineBreak(node);\n        }\n    };\n    SemicolonWalker.prototype.isFollowedByLineBreak = function (pos) {\n        var scanner = this.scanner ||\n            (this.scanner = ts.createScanner(this.sourceFile.languageVersion, true, this.sourceFile.languageVariant, this.sourceFile.text));\n        scanner.setTextPos(pos);\n        return scanner.scan() === ts.SyntaxKind.EndOfFileToken || scanner.hasPrecedingLineBreak();\n    };\n    SemicolonWalker.prototype.checkSemicolonOrLineBreak = function (node) {\n        var hasSemicolon = this.sourceFile.text[node.end - 1] === \";\";\n        if (this.options.always && !hasSemicolon) {\n            this.reportMissing(node.end);\n        }\n        else if (!this.options.always && hasSemicolon && this.isFollowedByLineBreak(node.end)) {\n            // semicolon can be removed if followed by line break;\n            this.reportUnnecessary(node.end - 1);\n        }\n    };\n    SemicolonWalker.prototype.checkEmptyStatement = function (node) {\n        // An empty statement is only ever useful when it is the only statement inside a loop\n        if (!utils.isIterationStatement(node.parent)) {\n            var parentKind = node.parent.kind;\n            // don't remove empty statement if it is a direct child of if, with or a LabeledStatement\n            // otherwise this would unintentionally change control flow\n            var noFix = parentKind === ts.SyntaxKind.IfStatement ||\n                parentKind === ts.SyntaxKind.LabeledStatement ||\n                parentKind === ts.SyntaxKind.WithStatement;\n            this.reportUnnecessary(node.end - 1, noFix);\n        }\n    };\n    SemicolonWalker.prototype.checkInterface = function (node) {\n        for (var _i = 0, _a = node.members; _i < _a.length; _i++) {\n            var member = _a[_i];\n            var lastChar = this.sourceFile.text[member.end - 1];\n            var hasSemicolon = lastChar === \";\";\n            if (this.options.always && !hasSemicolon) {\n                if (lastChar === \",\") {\n                    this.addFailureAt(member.end - 1, 1, Rule.FAILURE_STRING_COMMA, new Lint.Replacement(member.end - 1, 1, \";\"));\n                }\n                else {\n                    this.reportMissing(member.end);\n                }\n            }\n            else if (!this.options.always && hasSemicolon &&\n                (member === node.members[node.members.length - 1] || this.isFollowedByLineBreak(member.end))) {\n                this.reportUnnecessary(member.end - 1);\n            }\n        }\n    };\n    SemicolonWalker.prototype.reportMissing = function (pos) {\n        this.addFailureAt(pos, 0, Rule.FAILURE_STRING_MISSING, Lint.Replacement.appendText(pos, \";\"));\n    };\n    SemicolonWalker.prototype.reportUnnecessary = function (pos, noFix) {\n        this.addFailureAt(pos, 1, Rule.FAILURE_STRING_UNNECESSARY, noFix ? undefined : Lint.Replacement.deleteText(pos, 1));\n    };\n    SemicolonWalker.prototype.checkSemicolonAt = function (node) {\n        var hasSemicolon = this.sourceFile.text[node.end - 1] === \";\";\n        if (this.options.always && !hasSemicolon) {\n            this.reportMissing(node.end);\n        }\n        else if (!this.options.always && hasSemicolon) {\n            switch (utils.getNextToken(node, this.sourceFile).kind) {\n                case ts.SyntaxKind.OpenParenToken:\n                case ts.SyntaxKind.OpenBracketToken:\n                case ts.SyntaxKind.PlusToken:\n                case ts.SyntaxKind.MinusToken:\n                case ts.SyntaxKind.RegularExpressionLiteral:\n                    break;\n                default:\n                    this.reportUnnecessary(node.end - 1);\n            }\n        }\n    };\n    return SemicolonWalker;\n}(Lint.AbstractWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/spaceBeforeFunctionParenRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar ALWAYS_OR_NEVER = {\n    enum: [\"always\", \"never\"],\n    type: \"string\",\n};\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new FunctionWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    description: \"Require or disallow a space before function parenthesis\",\n    hasFix: true,\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"always\\\"]\",\n        \"[true, \\\"never\\\"]\",\n        \"[true, {\\\"anonymous\\\": \\\"always\\\", \\\"named\\\": \\\"never\\\", \\\"asyncArrow\\\": \\\"always\\\"}]\",\n    ],\n    options: {\n        properties: {\n            anonymous: ALWAYS_OR_NEVER,\n            asyncArrow: ALWAYS_OR_NEVER,\n            constructor: ALWAYS_OR_NEVER,\n            method: ALWAYS_OR_NEVER,\n            named: ALWAYS_OR_NEVER,\n        },\n        type: \"object\",\n    },\n    optionsDescription: (_a = [\"\\n            One argument which is an object which may contain the keys `anonymous`, `named`, and `asyncArrow`\\n            These should be set to either `\\\"always\\\"` or `\\\"never\\\"`.\\n\\n            * `\\\"anonymous\\\"` checks before the opening paren in anonymous functions\\n            * `\\\"named\\\"` checks before the opening paren in named functions\\n            * `\\\"asyncArrow\\\"` checks before the opening paren in async arrow functions\\n            * `\\\"method\\\"` checks before the opening paren in class methods\\n            * `\\\"constructor\\\"` checks before the opening paren in class constructors\\n        \"], _a.raw = [\"\\n            One argument which is an object which may contain the keys \\\\`anonymous\\\\`, \\\\`named\\\\`, and \\\\`asyncArrow\\\\`\\n            These should be set to either \\\\`\\\"always\\\"\\\\` or \\\\`\\\"never\\\"\\\\`.\\n\\n            * \\\\`\\\"anonymous\\\"\\\\` checks before the opening paren in anonymous functions\\n            * \\\\`\\\"named\\\"\\\\` checks before the opening paren in named functions\\n            * \\\\`\\\"asyncArrow\\\"\\\\` checks before the opening paren in async arrow functions\\n            * \\\\`\\\"method\\\"\\\\` checks before the opening paren in class methods\\n            * \\\\`\\\"constructor\\\"\\\\` checks before the opening paren in class constructors\\n        \"], Lint.Utils.dedent(_a)),\n    ruleName: \"space-before-function-paren\",\n    type: \"style\",\n    typescriptOnly: false,\n};\nRule.INVALID_WHITESPACE_ERROR = \"Spaces before function parens are disallowed\";\nRule.MISSING_WHITESPACE_ERROR = \"Missing whitespace before function parens\";\nexports.Rule = Rule;\nvar FunctionWalker = (function (_super) {\n    __extends(FunctionWalker, _super);\n    function FunctionWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        // assign constructor now to avoid typescript assuming its a function type\n        _this.cachedOptions = { constructor: undefined };\n        _this.scanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, sourceFile.text);\n        _this.cacheOptions();\n        return _this;\n    }\n    FunctionWalker.prototype.visitArrowFunction = function (node) {\n        var option = this.getOption(\"asyncArrow\");\n        var syntaxList = Lint.childOfKind(node, ts.SyntaxKind.SyntaxList);\n        var isAsyncArrow = syntaxList.getStart() === node.getStart() && syntaxList.getText() === \"async\";\n        var openParen = isAsyncArrow ? Lint.childOfKind(node, ts.SyntaxKind.OpenParenToken) : undefined;\n        this.evaluateRuleAt(openParen, option);\n        _super.prototype.visitArrowFunction.call(this, node);\n    };\n    FunctionWalker.prototype.visitConstructorDeclaration = function (node) {\n        var option = this.getOption(\"constructor\");\n        var openParen = Lint.childOfKind(node, ts.SyntaxKind.OpenParenToken);\n        this.evaluateRuleAt(openParen, option);\n        _super.prototype.visitConstructorDeclaration.call(this, node);\n    };\n    FunctionWalker.prototype.visitFunctionDeclaration = function (node) {\n        this.visitFunction(node);\n        _super.prototype.visitFunctionDeclaration.call(this, node);\n    };\n    FunctionWalker.prototype.visitFunctionExpression = function (node) {\n        this.visitFunction(node);\n        _super.prototype.visitFunctionExpression.call(this, node);\n    };\n    FunctionWalker.prototype.visitMethodDeclaration = function (node) {\n        this.visitMethod(node);\n        _super.prototype.visitMethodDeclaration.call(this, node);\n    };\n    FunctionWalker.prototype.visitMethodSignature = function (node) {\n        this.visitMethod(node);\n        _super.prototype.visitMethodSignature.call(this, node);\n    };\n    FunctionWalker.prototype.cacheOptions = function () {\n        var _this = this;\n        var allOptions = this.getOptions();\n        var options = allOptions[0];\n        var optionNames = [\"anonymous\", \"asyncArrow\", \"constructor\", \"method\", \"named\"];\n        optionNames.forEach(function (optionName) {\n            switch (options) {\n                case undefined:\n                case \"always\":\n                    _this.cachedOptions[optionName] = \"always\";\n                    break;\n                case \"never\":\n                    _this.cachedOptions[optionName] = \"never\";\n                    break;\n                default:\n                    _this.cachedOptions[optionName] = options[optionName];\n            }\n        });\n    };\n    FunctionWalker.prototype.getOption = function (optionName) {\n        return this.cachedOptions[optionName];\n    };\n    FunctionWalker.prototype.evaluateRuleAt = function (openParen, option) {\n        if (openParen === undefined || option === undefined) {\n            return;\n        }\n        var hasSpace = this.isSpaceAt(openParen.getStart() - 1);\n        if (hasSpace && option === \"never\") {\n            var pos = openParen.getStart() - 1;\n            this.addFailureAt(pos, 1, Rule.INVALID_WHITESPACE_ERROR, this.deleteText(pos, 1));\n        }\n        else if (!hasSpace && option === \"always\") {\n            var pos = openParen.getStart();\n            this.addFailureAt(pos, 1, Rule.MISSING_WHITESPACE_ERROR, this.appendText(pos, \" \"));\n        }\n    };\n    FunctionWalker.prototype.isSpaceAt = function (textPos) {\n        this.scanner.setTextPos(textPos);\n        var prevTokenKind = this.scanner.scan();\n        return prevTokenKind === ts.SyntaxKind.WhitespaceTrivia;\n    };\n    FunctionWalker.prototype.visitFunction = function (node) {\n        var identifier = Lint.childOfKind(node, ts.SyntaxKind.Identifier);\n        var hasIdentifier = identifier !== undefined && (identifier.getEnd() !== identifier.getStart());\n        var optionName = hasIdentifier ? \"named\" : \"anonymous\";\n        var option = this.getOption(optionName);\n        var openParen = Lint.childOfKind(node, ts.SyntaxKind.OpenParenToken);\n        this.evaluateRuleAt(openParen, option);\n    };\n    FunctionWalker.prototype.visitMethod = function (node) {\n        var option = this.getOption(\"method\");\n        var openParen = Lint.childOfKind(node, ts.SyntaxKind.OpenParenToken);\n        this.evaluateRuleAt(openParen, option);\n    };\n    return FunctionWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/whitespaceRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_BRANCH = \"check-branch\";\nvar OPTION_DECL = \"check-decl\";\nvar OPTION_OPERATOR = \"check-operator\";\nvar OPTION_MODULE = \"check-module\";\nvar OPTION_SEPARATOR = \"check-separator\";\nvar OPTION_TYPE = \"check-type\";\nvar OPTION_TYPECAST = \"check-typecast\";\nvar OPTION_PREBLOCK = \"check-preblock\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new WhitespaceWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"whitespace\",\n    description: \"Enforces whitespace style conventions.\",\n    rationale: \"Helps maintain a readable, consistent style in your codebase.\",\n    optionsDescription: (_a = [\"\\n            Eight arguments may be optionally provided:\\n\\n            * `\\\"check-branch\\\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace.\\n            * `\\\"check-decl\\\"`checks that variable declarations have whitespace around the equals token.\\n            * `\\\"check-operator\\\"` checks for whitespace around operator tokens.\\n            * `\\\"check-module\\\"` checks for whitespace in import & export statements.\\n            * `\\\"check-separator\\\"` checks for whitespace after separator tokens (`,`/`;`).\\n            * `\\\"check-type\\\"` checks for whitespace before a variable type specification.\\n            * `\\\"check-typecast\\\"` checks for whitespace between a typecast and its target.\\n            * `\\\"check-preblock\\\"` checks for whitespace before the opening brace of a block\"], _a.raw = [\"\\n            Eight arguments may be optionally provided:\\n\\n            * \\\\`\\\"check-branch\\\"\\\\` checks branching statements (\\\\`if\\\\`/\\\\`else\\\\`/\\\\`for\\\\`/\\\\`while\\\\`) are followed by whitespace.\\n            * \\\\`\\\"check-decl\\\"\\\\`checks that variable declarations have whitespace around the equals token.\\n            * \\\\`\\\"check-operator\\\"\\\\` checks for whitespace around operator tokens.\\n            * \\\\`\\\"check-module\\\"\\\\` checks for whitespace in import & export statements.\\n            * \\\\`\\\"check-separator\\\"\\\\` checks for whitespace after separator tokens (\\\\`,\\\\`/\\\\`;\\\\`).\\n            * \\\\`\\\"check-type\\\"\\\\` checks for whitespace before a variable type specification.\\n            * \\\\`\\\"check-typecast\\\"\\\\` checks for whitespace between a typecast and its target.\\n            * \\\\`\\\"check-preblock\\\"\\\\` checks for whitespace before the opening brace of a block\"], Lint.Utils.dedent(_a)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [\"check-branch\", \"check-decl\", \"check-operator\", \"check-module\",\n                \"check-separator\", \"check-type\", \"check-typecast\", \"check-preblock\"],\n        },\n        minLength: 0,\n        maxLength: 7,\n    },\n    optionExamples: ['[true, \"check-branch\", \"check-operator\", \"check-typecast\"]'],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"missing whitespace\";\nexports.Rule = Rule;\nvar WhitespaceWalker = (function (_super) {\n    __extends(WhitespaceWalker, _super);\n    function WhitespaceWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.scanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, sourceFile.text);\n        return _this;\n    }\n    WhitespaceWalker.prototype.visitSourceFile = function (node) {\n        var _this = this;\n        _super.prototype.visitSourceFile.call(this, node);\n        var prevTokenShouldBeFollowedByWhitespace = false;\n        utils.forEachTokenWithTrivia(node, function (_text, tokenKind, range, parent) {\n            if (tokenKind === ts.SyntaxKind.WhitespaceTrivia ||\n                tokenKind === ts.SyntaxKind.NewLineTrivia ||\n                tokenKind === ts.SyntaxKind.EndOfFileToken) {\n                prevTokenShouldBeFollowedByWhitespace = false;\n                return;\n            }\n            else if (prevTokenShouldBeFollowedByWhitespace) {\n                _this.addMissingWhitespaceErrorAt(range.pos);\n                prevTokenShouldBeFollowedByWhitespace = false;\n            }\n            // check for trailing space after the given tokens\n            switch (tokenKind) {\n                case ts.SyntaxKind.CatchKeyword:\n                case ts.SyntaxKind.ForKeyword:\n                case ts.SyntaxKind.IfKeyword:\n                case ts.SyntaxKind.SwitchKeyword:\n                case ts.SyntaxKind.WhileKeyword:\n                case ts.SyntaxKind.WithKeyword:\n                    if (_this.hasOption(OPTION_BRANCH)) {\n                        prevTokenShouldBeFollowedByWhitespace = true;\n                    }\n                    break;\n                case ts.SyntaxKind.CommaToken:\n                case ts.SyntaxKind.SemicolonToken:\n                    if (_this.hasOption(OPTION_SEPARATOR)) {\n                        prevTokenShouldBeFollowedByWhitespace = true;\n                    }\n                    break;\n                case ts.SyntaxKind.EqualsToken:\n                    if (_this.hasOption(OPTION_DECL) && parent.kind !== ts.SyntaxKind.JsxAttribute) {\n                        prevTokenShouldBeFollowedByWhitespace = true;\n                    }\n                    break;\n                case ts.SyntaxKind.ColonToken:\n                    if (_this.hasOption(OPTION_TYPE)) {\n                        prevTokenShouldBeFollowedByWhitespace = true;\n                    }\n                    break;\n                case ts.SyntaxKind.ImportKeyword:\n                case ts.SyntaxKind.ExportKeyword:\n                case ts.SyntaxKind.FromKeyword:\n                    if (_this.hasOption(OPTION_MODULE)) {\n                        prevTokenShouldBeFollowedByWhitespace = true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        });\n    };\n    WhitespaceWalker.prototype.visitArrowFunction = function (node) {\n        this.checkEqualsGreaterThanTokenInNode(node);\n        _super.prototype.visitArrowFunction.call(this, node);\n    };\n    // check for spaces between the operator symbol (except in the case of comma statements)\n    WhitespaceWalker.prototype.visitBinaryExpression = function (node) {\n        if (this.hasOption(OPTION_OPERATOR) && node.operatorToken.kind !== ts.SyntaxKind.CommaToken) {\n            this.checkForTrailingWhitespace(node.left.getEnd());\n            this.checkForTrailingWhitespace(node.right.getFullStart());\n        }\n        _super.prototype.visitBinaryExpression.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitBlock = function (block) {\n        if (this.hasOption(OPTION_PREBLOCK)) {\n            this.checkForTrailingWhitespace(block.getFullStart());\n        }\n        _super.prototype.visitBlock.call(this, block);\n    };\n    // check for spaces between ternary operator symbols\n    WhitespaceWalker.prototype.visitConditionalExpression = function (node) {\n        if (this.hasOption(OPTION_OPERATOR)) {\n            this.checkForTrailingWhitespace(node.condition.getEnd());\n            this.checkForTrailingWhitespace(node.whenTrue.getFullStart());\n            this.checkForTrailingWhitespace(node.whenTrue.getEnd());\n        }\n        _super.prototype.visitConditionalExpression.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitConstructorType = function (node) {\n        this.checkEqualsGreaterThanTokenInNode(node);\n        _super.prototype.visitConstructorType.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitExportAssignment = function (node) {\n        if (this.hasOption(OPTION_MODULE)) {\n            var exportKeyword = node.getChildAt(0);\n            var position = exportKeyword.getEnd();\n            this.checkForTrailingWhitespace(position);\n        }\n        _super.prototype.visitExportAssignment.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitFunctionType = function (node) {\n        this.checkEqualsGreaterThanTokenInNode(node);\n        _super.prototype.visitFunctionType.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitImportDeclaration = function (node) {\n        var importClause = node.importClause;\n        if (this.hasOption(OPTION_MODULE) && importClause != null) {\n            // an import clause can have _both_ named bindings and a name (the latter for the default import)\n            // but the named bindings always come last, so we only need to check that for whitespace\n            var position = void 0;\n            if (importClause.namedBindings !== undefined) {\n                position = importClause.namedBindings.getEnd();\n            }\n            else if (importClause.name !== undefined) {\n                position = importClause.name.getEnd();\n            }\n            if (position !== undefined) {\n                this.checkForTrailingWhitespace(position);\n            }\n        }\n        _super.prototype.visitImportDeclaration.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitImportEqualsDeclaration = function (node) {\n        if (this.hasOption(OPTION_MODULE)) {\n            var position = node.name.getEnd();\n            this.checkForTrailingWhitespace(position);\n        }\n        _super.prototype.visitImportEqualsDeclaration.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitTypeAssertionExpression = function (node) {\n        if (this.hasOption(OPTION_TYPECAST)) {\n            var position = node.expression.getFullStart();\n            this.checkForTrailingWhitespace(position);\n        }\n        _super.prototype.visitTypeAssertionExpression.call(this, node);\n    };\n    WhitespaceWalker.prototype.visitVariableDeclaration = function (node) {\n        if (this.hasOption(OPTION_DECL) && node.initializer != null) {\n            if (node.type != null) {\n                this.checkForTrailingWhitespace(node.type.getEnd());\n            }\n            else {\n                this.checkForTrailingWhitespace(node.name.getEnd());\n            }\n        }\n        _super.prototype.visitVariableDeclaration.call(this, node);\n    };\n    WhitespaceWalker.prototype.checkEqualsGreaterThanTokenInNode = function (node) {\n        if (!this.hasOption(OPTION_OPERATOR)) {\n            return;\n        }\n        var equalsGreaterThanToken = Lint.childOfKind(node, ts.SyntaxKind.EqualsGreaterThanToken);\n        // condition so we don't crash if the arrow is somehow missing\n        if (equalsGreaterThanToken === undefined) {\n            return;\n        }\n        this.checkForTrailingWhitespace(equalsGreaterThanToken.getFullStart());\n        this.checkForTrailingWhitespace(equalsGreaterThanToken.getEnd());\n    };\n    WhitespaceWalker.prototype.checkForTrailingWhitespace = function (position) {\n        this.scanner.setTextPos(position);\n        var nextTokenType = this.scanner.scan();\n        if (nextTokenType !== ts.SyntaxKind.WhitespaceTrivia\n            && nextTokenType !== ts.SyntaxKind.NewLineTrivia\n            && nextTokenType !== ts.SyntaxKind.EndOfFileToken) {\n            this.addMissingWhitespaceErrorAt(position);\n        }\n    };\n    WhitespaceWalker.prototype.addMissingWhitespaceErrorAt = function (position) {\n        var fix = this.appendText(position, \" \");\n        this.addFailureAt(position, 1, Rule.FAILURE_STRING, fix);\n    };\n    return WhitespaceWalker;\n}(Lint.RuleWalker));\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/configs/latest.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// tslint:disable object-literal-sort-keys\n// tslint:disable:object-literal-key-quotes\nexports.rules = {\n    // added in v5.1\n    \"no-invalid-template-strings\": true,\n    \"no-sparse-arrays\": true,\n};\n// tslint:enable object-literal-sort-keys\n// work around \"extends\" being a keyword\nvar xtends = \"tslint:recommended\";\nexports.extends = xtends;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/configs/recommended.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rules = {\n    \"adjacent-overload-signatures\": true,\n    \"align\": {\n        options: [\n            \"parameters\",\n            \"statements\",\n        ],\n    },\n    \"array-type\": {\n        options: [\"array-simple\"],\n    },\n    \"arrow-parens\": true,\n    \"arrow-return-shorthand\": true,\n    \"ban-types\": {\n        options: [\n            [\"Object\", \"Avoid using the `Object` type. Did you mean `object`?\"],\n            [\"Function\", \"Avoid using the `Function` type. Prefer a specific function type, like `() => void`.\"],\n            [\"Boolean\", \"Avoid using the `Boolean` type. Did you mean `boolean`?\"],\n            [\"Number\", \"Avoid using the `Number` type. Did you mean `number`?\"],\n            [\"String\", \"Avoid using the `String` type. Did you mean `string`?\"],\n            [\"Symbol\", \"Avoid using the `Symbol` type. Did you mean `symbol`?\"],\n        ],\n    },\n    \"callable-types\": true,\n    \"class-name\": true,\n    \"comment-format\": {\n        options: [\"check-space\"],\n    },\n    \"curly\": true,\n    \"cyclomatic-complexity\": false,\n    \"eofline\": true,\n    \"forin\": true,\n    \"import-spacing\": true,\n    \"indent\": {\n        options: [\"spaces\"],\n    },\n    \"interface-name\": {\n        options: [\"always-prefix\"],\n    },\n    \"interface-over-type-literal\": true,\n    \"jsdoc-format\": true,\n    \"label-position\": true,\n    \"max-classes-per-file\": {\n        options: [1],\n    },\n    \"max-line-length\": {\n        options: [120],\n    },\n    \"member-access\": true,\n    \"member-ordering\": {\n        options: {\n            order: \"statics-first\",\n        },\n    },\n    \"new-parens\": true,\n    \"no-angle-bracket-type-assertion\": true,\n    \"no-any\": false,\n    \"no-arg\": true,\n    \"no-bitwise\": true,\n    \"no-conditional-assignment\": true,\n    \"no-consecutive-blank-lines\": true,\n    \"no-console\": {\n        options: [\n            \"debug\",\n            \"info\",\n            \"log\",\n            \"time\",\n            \"timeEnd\",\n            \"trace\",\n        ],\n    },\n    \"no-construct\": true,\n    \"no-debugger\": true,\n    \"no-duplicate-super\": true,\n    \"no-empty\": true,\n    \"no-empty-interface\": true,\n    \"no-eval\": true,\n    \"no-internal-module\": true,\n    \"no-invalid-this\": false,\n    \"no-misused-new\": true,\n    \"no-namespace\": true,\n    \"no-parameter-properties\": false,\n    \"no-reference\": true,\n    \"no-reference-import\": true,\n    \"no-shadowed-variable\": true,\n    \"no-string-literal\": true,\n    \"no-string-throw\": true,\n    \"no-switch-case-fall-through\": false,\n    \"no-trailing-whitespace\": true,\n    \"no-unnecessary-initializer\": true,\n    \"no-unsafe-finally\": true,\n    \"no-unused-expression\": true,\n    // disable this rule as it is very heavy performance-wise and not that useful\n    \"no-use-before-declare\": false,\n    \"no-var-keyword\": true,\n    \"no-var-requires\": true,\n    \"object-literal-key-quotes\": {\n        options: [\"consistent-as-needed\"],\n    },\n    \"object-literal-shorthand\": true,\n    \"object-literal-sort-keys\": true,\n    \"one-line\": {\n        options: [\n            \"check-catch\",\n            \"check-else\",\n            \"check-finally\",\n            \"check-open-brace\",\n            \"check-whitespace\",\n        ],\n    },\n    \"one-variable-per-declaration\": {\n        options: [\"ignore-for-loop\"],\n    },\n    \"only-arrow-functions\": {\n        options: [\n            \"allow-declarations\",\n            \"allow-named-functions\",\n        ],\n    },\n    \"ordered-imports\": {\n        options: {\n            \"import-sources-order\": \"case-insensitive\",\n            \"named-imports-order\": \"case-insensitive\",\n        },\n    },\n    \"prefer-const\": true,\n    \"prefer-for-of\": true,\n    \"quotemark\": {\n        options: [\n            \"double\",\n            \"avoid-escape\",\n        ],\n    },\n    \"radix\": true,\n    \"semicolon\": {\n        options: [\"always\"],\n    },\n    \"space-before-function-paren\": {\n        options: {\n            anonymous: \"never\",\n            asyncArrow: \"always\",\n            constructor: \"never\",\n            method: \"never\",\n            named: \"never\",\n        },\n    },\n    \"trailing-comma\": {\n        options: {\n            multiline: \"always\",\n            singleline: \"never\",\n        },\n    },\n    \"triple-equals\": {\n        options: [\"allow-null-check\"],\n    },\n    \"typedef\": false,\n    \"typedef-whitespace\": {\n        options: [{\n                \"call-signature\": \"nospace\",\n                \"index-signature\": \"nospace\",\n                \"parameter\": \"nospace\",\n                \"property-declaration\": \"nospace\",\n                \"variable-declaration\": \"nospace\",\n            }, {\n                \"call-signature\": \"onespace\",\n                \"index-signature\": \"onespace\",\n                \"parameter\": \"onespace\",\n                \"property-declaration\": \"onespace\",\n                \"variable-declaration\": \"onespace\",\n            }],\n    },\n    \"typeof-compare\": true,\n    \"unified-signatures\": true,\n    \"use-isnan\": true,\n    \"variable-name\": {\n        options: [\n            \"ban-keywords\",\n            \"check-format\",\n            \"allow-pascal-case\",\n        ],\n    },\n    \"whitespace\": {\n        options: [\n            \"check-branch\",\n            \"check-decl\",\n            \"check-operator\",\n            \"check-separator\",\n            \"check-type\",\n            \"check-typecast\",\n        ],\n    },\n};\nexports.jsRules = {\n    \"align\": {\n        options: [\n            \"parameters\",\n            \"statements\",\n        ],\n    },\n    \"class-name\": true,\n    \"curly\": true,\n    \"eofline\": true,\n    \"forin\": true,\n    \"import-spacing\": true,\n    \"indent\": {\n        options: [\"spaces\"],\n    },\n    \"jsdoc-format\": true,\n    \"label-position\": true,\n    \"max-line-length\": {\n        options: [120],\n    },\n    \"new-parens\": true,\n    \"no-arg\": true,\n    \"no-bitwise\": true,\n    \"no-conditional-assignment\": true,\n    \"no-consecutive-blank-lines\": true,\n    \"no-console\": {\n        options: [\n            \"debug\",\n            \"info\",\n            \"log\",\n            \"time\",\n            \"timeEnd\",\n            \"trace\",\n        ],\n    },\n    \"no-construct\": true,\n    \"no-debugger\": true,\n    \"no-duplicate-super\": true,\n    \"no-duplicate-variable\": true,\n    \"no-empty\": true,\n    \"no-eval\": true,\n    \"no-reference\": true,\n    \"no-shadowed-variable\": true,\n    \"no-string-literal\": true,\n    \"no-string-throw\": true,\n    \"no-switch-case-fall-through\": false,\n    \"no-trailing-whitespace\": true,\n    \"no-unused-expression\": true,\n    // disable this rule as it is very heavy performance-wise and not that useful\n    \"no-use-before-declare\": false,\n    \"object-literal-sort-keys\": true,\n    \"one-line\": {\n        options: [\n            \"check-catch\",\n            \"check-else\",\n            \"check-finally\",\n            \"check-open-brace\",\n            \"check-whitespace\",\n        ],\n    },\n    \"one-variable-per-declaration\": {\n        options: [\"ignore-for-loop\"],\n    },\n    \"quotemark\": {\n        options: [\n            \"double\",\n            \"avoid-escape\",\n        ],\n    },\n    \"radix\": true,\n    \"semicolon\": {\n        options: [\"always\"],\n    },\n    \"space-before-function-paren\": {\n        options: {\n            anonymous: \"never\",\n            asyncArrow: \"always\",\n            constructor: \"never\",\n            method: \"never\",\n            named: \"never\",\n        },\n    },\n    \"trailing-comma\": {\n        options: {\n            multiline: \"always\",\n            singleline: \"never\",\n        },\n    },\n    \"triple-equals\": {\n        options: [\"allow-null-check\"],\n    },\n    \"use-isnan\": true,\n    \"variable-name\": {\n        options: [\n            \"ban-keywords\",\n            \"check-format\",\n            \"allow-pascal-case\",\n        ],\n    },\n    \"whitespace\": {\n        options: [\n            \"check-branch\",\n            \"check-decl\",\n            \"check-operator\",\n            \"check-separator\",\n            \"check-type\",\n            \"check-typecast\",\n        ],\n    },\n};\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/checkstyleFormatter.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        var output = '<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle version=\"4.3\">';\n        if (failures.length) {\n            var failuresSorted = failures.sort(function (a, b) {\n                return a.getFileName().localeCompare(b.getFileName());\n            });\n            var previousFilename = null;\n            for (var _i = 0, failuresSorted_1 = failuresSorted; _i < failuresSorted_1.length; _i++) {\n                var failure = failuresSorted_1[_i];\n                var severity = failure.getRuleSeverity();\n                if (failure.getFileName() !== previousFilename) {\n                    if (previousFilename) {\n                        output += \"</file>\";\n                    }\n                    previousFilename = failure.getFileName();\n                    output += \"<file name=\\\"\" + this.escapeXml(failure.getFileName()) + \"\\\">\";\n                }\n                output += \"<error line=\\\"\" + (failure.getStartPosition().getLineAndCharacter().line + 1) + \"\\\" \";\n                output += \"column=\\\"\" + (failure.getStartPosition().getLineAndCharacter().character + 1) + \"\\\" \";\n                output += \"severity=\\\"\" + severity + \"\\\" \";\n                output += \"message=\\\"\" + this.escapeXml(failure.getFailure()) + \"\\\" \";\n                // checkstyle parser wants \"source\" to have structure like <anything>dot<category>dot<type>\n                output += \"source=\\\"failure.tslint.\" + this.escapeXml(failure.getRuleName()) + \"\\\" />\";\n            }\n            if (previousFilename) {\n                output += \"</file>\";\n            }\n        }\n        output += \"</checkstyle>\";\n        return output;\n    };\n    Formatter.prototype.escapeXml = function (str) {\n        return str\n            .replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/'/g, \"&#39;\")\n            .replace(/\"/g, \"&quot;\");\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"checkstyle\",\n    description: \"Formats errors as through they were Checkstyle output.\",\n    descriptionDetails: (_a = [\"\\n            Imitates the XMLLogger from Checkstyle 4.3. All failures have the 'warning' severity.\"], _a.raw = [\"\\n            Imitates the XMLLogger from Checkstyle 4.3. All failures have the 'warning' severity.\"], Utils.dedent(_a)),\n    sample: (_b = [\"\\n        <?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n        <checkstyle version=\\\"4.3\\\">\\n            <file name=\\\"myFile.ts\\\">\\n                <error line=\\\"1\\\" column=\\\"14\\\" severity=\\\"warning\\\" message=\\\"Missing semicolon\\\" source=\\\"failure.tslint.semicolon\\\" />\\n            </file>\\n        </checkstyle>\"], _b.raw = [\"\\n        <?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n        <checkstyle version=\\\"4.3\\\">\\n            <file name=\\\"myFile.ts\\\">\\n                <error line=\\\"1\\\" column=\\\"14\\\" severity=\\\"warning\\\" message=\\\"Missing semicolon\\\" source=\\\"failure.tslint.semicolon\\\" />\\n            </file>\\n        </checkstyle>\"], Utils.dedent(_b)),\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/msbuildFormatter.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar utils_1 = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures) {\n        var outputLines = failures.map(function (failure) {\n            var fileName = failure.getFileName();\n            var failureString = failure.getFailure();\n            var camelizedRule = utils_1.camelize(failure.getRuleName());\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var positionTuple = \"(\" + (lineAndCharacter.line + 1) + \",\" + (lineAndCharacter.character + 1) + \")\";\n            var severity = failure.getRuleSeverity();\n            return \"\" + fileName + positionTuple + \": \" + severity + \" \" + camelizedRule + \": \" + failureString;\n        });\n        return outputLines.join(\"\\n\") + \"\\n\";\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"msbuild\",\n    description: \"Formats errors for consumption by msbuild.\",\n    descriptionDetails: (_a = [\"\\n            The output is compatible with both msbuild and Visual Studio. All failures have the\\n            'warning' severity.\"], _a.raw = [\"\\n            The output is compatible with both msbuild and Visual Studio. All failures have the\\n            'warning' severity.\"], utils_1.dedent(_a)),\n    sample: \"myFile.ts(1,14): warning: Missing semicolon\",\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/formatters/vsoFormatter.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstractFormatter_1 = require(\"../language/formatter/abstractFormatter\");\nvar Utils = require(\"../utils\");\nvar Formatter = (function (_super) {\n    __extends(Formatter, _super);\n    function Formatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Formatter.prototype.format = function (failures, warnings) {\n        if (warnings === void 0) { warnings = []; }\n        var all = failures.concat(warnings);\n        var outputLines = all.map(function (failure) {\n            var fileName = failure.getFileName();\n            var failureString = failure.getFailure();\n            var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();\n            var line = lineAndCharacter.line + 1;\n            var character = lineAndCharacter.character + 1;\n            var code = (failure.getRuleName ? failure.getRuleName() : \"\");\n            var properties = \"sourcepath=\" + fileName + \";linenumber=\" + line + \";columnnumber=\" + character + \";code=\" + code + \";\";\n            return \"##vso[task.logissue type=warning;\" + properties + \"]\" + failureString;\n        });\n        return outputLines.join(\"\\n\") + \"\\n\";\n    };\n    return Formatter;\n}(abstractFormatter_1.AbstractFormatter));\n/* tslint:disable:object-literal-sort-keys */\nFormatter.metadata = {\n    formatterName: \"vso\",\n    description: \"Formats output as VSO/TFS logging commands.\",\n    descriptionDetails: (_a = [\"\\n            Integrates with Visual Studio Online and Team Foundation Server by outputting errors\\n            as 'warning' logging commands.\"], _a.raw = [\"\\n            Integrates with Visual Studio Online and Team Foundation Server by outputting errors\\n            as 'warning' logging commands.\"], Utils.dedent(_a)),\n    sample: \"##vso[task.logissue type=warning;sourcepath=myFile.ts;linenumber=1;columnnumber=14;code=semicolon;]Missing semicolon\",\n    consumer: \"machine\",\n};\nexports.Formatter = Formatter;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/fileHeaderRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var text = sourceFile.text;\n        // ignore shebang if it exists\n        var offset = text.startsWith(\"#!\") ? text.indexOf(\"\\n\") + 1 : 0;\n        if (!textHasComment(text, offset, new RegExp(this.ruleArguments[0]))) {\n            return [new Lint.RuleFailure(sourceFile, offset, offset, Rule.FAILURE_STRING, this.ruleName)];\n        }\n        return [];\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"file-header\",\n    description: \"Enforces a certain header comment for all files, matched by a regular expression.\",\n    optionsDescription: \"Regular expression to match the header.\",\n    options: {\n        type: \"string\",\n    },\n    optionExamples: ['[true, \"Copyright \\\\\\\\d{4}\"]'],\n    type: \"style\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"missing file header\";\nexports.Rule = Rule;\n// match a single line or multi line comment with leading whitespace\n// the wildcard dot does not match new lines - we can use [\\s\\S] instead\nvar commentRegexp = /^\\s*(\\/\\/(.*)|\\/\\*([\\s\\S]*?)\\*\\/)/;\nfunction textHasComment(text, offset, headerRegexp) {\n    // check for a comment\n    var match = commentRegexp.exec(text.slice(offset));\n    if (match === null) {\n        return false;\n    }\n    // either the third or fourth capture group contains the comment contents\n    var comment = match[2] !== undefined ? match[2] : match[3];\n    return comment.search(headerRegexp) !== -1;\n}\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/importBlacklistRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && this.ruleArguments.length > 0;\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ImportBlacklistWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"import-blacklist\",\n    description: (_a = [\"\\n            Disallows importing the specified modules directly via `import` and `require`.\\n            Instead only sub modules may be imported from that module.\"], _a.raw = [\"\\n            Disallows importing the specified modules directly via \\\\`import\\\\` and \\\\`require\\\\`.\\n            Instead only sub modules may be imported from that module.\"], Lint.Utils.dedent(_a)),\n    rationale: (_b = [\"\\n            Some libraries allow importing their submodules instead of the entire module.\\n            This is good practise as it avoids loading unused modules.\"], _b.raw = [\"\\n            Some libraries allow importing their submodules instead of the entire module.\\n            This is good practise as it avoids loading unused modules.\"], Lint.Utils.dedent(_b)),\n    optionsDescription: \"A list of blacklisted modules.\",\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n        },\n        minLength: 1,\n    },\n    optionExamples: [\"true\", '[true, \"rxjs\", \"lodash\"]'],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\nRule.FAILURE_STRING = \"This import is blacklisted, import a submodule instead\";\nexports.Rule = Rule;\nvar ImportBlacklistWalker = (function (_super) {\n    __extends(ImportBlacklistWalker, _super);\n    function ImportBlacklistWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImportBlacklistWalker.prototype.visitCallExpression = function (node) {\n        if (node.expression.kind === ts.SyntaxKind.Identifier &&\n            node.expression.text === \"require\" &&\n            node.arguments !== undefined &&\n            node.arguments.length === 1) {\n            this.checkForBannedImport(node.arguments[0]);\n        }\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    ImportBlacklistWalker.prototype.visitImportEqualsDeclaration = function (node) {\n        if (utils.isExternalModuleReference(node.moduleReference) &&\n            node.moduleReference.expression !== undefined) {\n            // If it's an import require and not an import alias\n            this.checkForBannedImport(node.moduleReference.expression);\n        }\n        _super.prototype.visitImportEqualsDeclaration.call(this, node);\n    };\n    ImportBlacklistWalker.prototype.visitImportDeclaration = function (node) {\n        this.checkForBannedImport(node.moduleSpecifier);\n        _super.prototype.visitImportDeclaration.call(this, node);\n    };\n    ImportBlacklistWalker.prototype.checkForBannedImport = function (expression) {\n        if (utils.isTextualLiteral(expression) && this.hasOption(expression.text)) {\n            this.addFailureFromStartToEnd(expression.getStart(this.getSourceFile()) + 1, expression.getEnd() - 1, Rule.FAILURE_STRING);\n        }\n    };\n    return ImportBlacklistWalker;\n}(Lint.RuleWalker));\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noInvalidThisRule.js":"/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_FUNCTION_IN_METHOD = \"check-function-in-method\";\nvar DEPRECATED_OPTION_FUNCTION_IN_METHOD = \"no-this-in-function-in-method\";\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var _this = this;\n        var hasOption = function (name) { return _this.ruleArguments.indexOf(name) !== -1; };\n        var checkFuncInMethod = hasOption(DEPRECATED_OPTION_FUNCTION_IN_METHOD) || hasOption(OPTION_FUNCTION_IN_METHOD);\n        return this.applyWithFunction(sourceFile, walk, checkFuncInMethod);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-invalid-this\",\n    description: \"Disallows using the `this` keyword outside of classes.\",\n    rationale: \"See [the rule's author's rationale here.](https://github.com/palantir/tslint/pull/1105#issue-147549402)\",\n    optionsDescription: (_a = [\"\\n            One argument may be optionally provided:\\n\\n            * `\", \"` disallows using the `this` keyword in functions within class methods.\"], _a.raw = [\"\\n            One argument may be optionally provided:\\n\\n            * \\\\`\", \"\\\\` disallows using the \\\\`this\\\\` keyword in functions within class methods.\"], Lint.Utils.dedent(_a, OPTION_FUNCTION_IN_METHOD)),\n    options: {\n        type: \"array\",\n        items: {\n            type: \"string\",\n            enum: [OPTION_FUNCTION_IN_METHOD],\n        },\n        minLength: 0,\n        maxLength: 1,\n    },\n    optionExamples: [\"true\", \"[true, \\\"\" + OPTION_FUNCTION_IN_METHOD + \"\\\"]\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_OUTSIDE = \"the \\\"this\\\" keyword is disallowed outside of a class body\";\nRule.FAILURE_STRING_INSIDE = \"the \\\"this\\\" keyword is disallowed in function bodies inside class methods, \" +\n    \"use arrow functions instead\";\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, checkFuncInMethod = ctx.options;\n    var inClass = false;\n    var inFunctionInClass = false;\n    ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ClassDeclaration:\n            case ts.SyntaxKind.ClassExpression:\n                if (!inClass) {\n                    inClass = true;\n                    ts.forEachChild(node, cb);\n                    inClass = false;\n                    return;\n                }\n                break;\n            case ts.SyntaxKind.FunctionDeclaration:\n            case ts.SyntaxKind.FunctionExpression:\n                if (inClass) {\n                    inFunctionInClass = true;\n                    ts.forEachChild(node, cb);\n                    inFunctionInClass = false;\n                    return;\n                }\n                break;\n            case ts.SyntaxKind.ThisKeyword:\n                if (!inClass) {\n                    ctx.addFailureAtNode(node, Rule.FAILURE_STRING_OUTSIDE);\n                }\n                else if (checkFuncInMethod && inFunctionInClass) {\n                    ctx.addFailureAtNode(node, Rule.FAILURE_STRING_INSIDE);\n                }\n                return;\n        }\n        ts.forEachChild(node, cb);\n    });\n}\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/noSwitchCaseFallThroughRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new NoSwitchCaseFallThroughWalker(sourceFile, this.ruleName, undefined));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"no-switch-case-fall-through\",\n    description: \"Disallows falling through case statements.\",\n    descriptionDetails: (_a = [\"\\n            For example, the following is not allowed:\\n\\n            ```ts\\n            switch(foo) {\\n                case 1:\\n                    someFunc(foo);\\n                case 2:\\n                    someOtherFunc(foo);\\n            }\\n            ```\\n\\n            However, fall through is allowed when case statements are consecutive or\\n            a magic `/* falls through */` comment is present. The following is valid:\\n\\n            ```ts\\n            switch(foo) {\\n                case 1:\\n                    someFunc(foo);\\n                    /* falls through */\\n                case 2:\\n                case 3:\\n                    someOtherFunc(foo);\\n            }\\n            ```\"], _a.raw = [\"\\n            For example, the following is not allowed:\\n\\n            \\\\`\\\\`\\\\`ts\\n            switch(foo) {\\n                case 1:\\n                    someFunc(foo);\\n                case 2:\\n                    someOtherFunc(foo);\\n            }\\n            \\\\`\\\\`\\\\`\\n\\n            However, fall through is allowed when case statements are consecutive or\\n            a magic \\\\`/* falls through */\\\\` comment is present. The following is valid:\\n\\n            \\\\`\\\\`\\\\`ts\\n            switch(foo) {\\n                case 1:\\n                    someFunc(foo);\\n                    /* falls through */\\n                case 2:\\n                case 3:\\n                    someOtherFunc(foo);\\n            }\\n            \\\\`\\\\`\\\\`\"], Lint.Utils.dedent(_a)),\n    rationale: \"Fall though in switch statements is often unintentional and a bug.\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING_PART = \"expected a 'break' before \";\nexports.Rule = Rule;\nvar NoSwitchCaseFallThroughWalker = (function (_super) {\n    __extends(NoSwitchCaseFallThroughWalker, _super);\n    function NoSwitchCaseFallThroughWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoSwitchCaseFallThroughWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (node.kind === ts.SyntaxKind.SwitchStatement) {\n                _this.visitSwitchStatement(node);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    NoSwitchCaseFallThroughWalker.prototype.visitSwitchStatement = function (node) {\n        var clauses = node.caseBlock.clauses;\n        var len = clauses.length - 1; // last clause doesn't need to be checked\n        for (var i = 0; i < len; ++i) {\n            if (clauses[i].statements.length !== 0 &&\n                // TODO type assertion can be removed with typescript 2.2\n                !utils.endsControlFlow(clauses[i]) &&\n                !this.isFallThroughAllowed(clauses[i])) {\n                this.reportError(clauses[i + 1]);\n            }\n        }\n    };\n    NoSwitchCaseFallThroughWalker.prototype.isFallThroughAllowed = function (clause) {\n        var sourceFileText = this.sourceFile.text;\n        var comments = ts.getLeadingCommentRanges(sourceFileText, clause.end);\n        if (comments === undefined) {\n            return false;\n        }\n        for (var _i = 0, comments_1 = comments; _i < comments_1.length; _i++) {\n            var comment = comments_1[_i];\n            var commentText = void 0;\n            if (comment.kind === ts.SyntaxKind.MultiLineCommentTrivia) {\n                commentText = sourceFileText.substring(comment.pos + 2, comment.end - 2);\n            }\n            else {\n                commentText = sourceFileText.substring(comment.pos + 2, comment.end);\n            }\n            if (commentText.trim() === \"falls through\") {\n                return true;\n            }\n        }\n        return false;\n    };\n    NoSwitchCaseFallThroughWalker.prototype.reportError = function (clause) {\n        var keyword = clause.kind === ts.SyntaxKind.CaseClause ? \"case\" : \"default\";\n        this.addFailureAt(clause.getStart(this.sourceFile), keyword.length, Rule.FAILURE_STRING_PART + \"'\" + keyword + \"'\");\n    };\n    return NoSwitchCaseFallThroughWalker;\n}(Lint.AbstractWalker));\nexports.NoSwitchCaseFallThroughWalker = NoSwitchCaseFallThroughWalker;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-tslint/node_modules/tslint/lib/rules/typeofCompareRule.js":"/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar LEGAL_TYPEOF_RESULTS = new Set([\"undefined\", \"string\", \"boolean\", \"number\", \"function\", \"object\", \"symbol\"]);\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\n/* tslint:disable:object-literal-sort-keys */\nRule.metadata = {\n    ruleName: \"typeof-compare\",\n    description: \"Makes sure result of `typeof` is compared to correct string values\",\n    optionsDescription: \"Not configurable.\",\n    options: null,\n    optionExamples: [\"true\"],\n    type: \"functionality\",\n    typescriptOnly: false,\n};\n/* tslint:enable:object-literal-sort-keys */\nRule.FAILURE_STRING = \"'typeof' expression must be compared to one of: \" + Array.from(LEGAL_TYPEOF_RESULTS).map(function (x) { return \"\\\"\" + x + \"\\\"\"; }).join(\", \");\nexports.Rule = Rule;\nvar Walker = (function (_super) {\n    __extends(Walker, _super);\n    function Walker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Walker.prototype.visitBinaryExpression = function (node) {\n        var operatorToken = node.operatorToken, left = node.left, right = node.right;\n        if (Lint.getEqualsKind(operatorToken) && (isFaultyTypeof(left, right) || isFaultyTypeof(right, left))) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        }\n        _super.prototype.visitBinaryExpression.call(this, node);\n    };\n    return Walker;\n}(Lint.RuleWalker));\nfunction isFaultyTypeof(left, right) {\n    return left.kind === ts.SyntaxKind.TypeOfExpression && isFaultyTypeofResult(right);\n}\nfunction isFaultyTypeofResult(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.StringLiteral:\n            return !LEGAL_TYPEOF_RESULTS.has(node.text);\n        case ts.SyntaxKind.Identifier:\n            return node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword;\n        case ts.SyntaxKind.NullKeyword:\n        case ts.SyntaxKind.NumericLiteral:\n        case ts.SyntaxKind.TrueKeyword:\n        case ts.SyntaxKind.FalseKeyword:\n        case ts.SyntaxKind.ObjectLiteralExpression:\n        case ts.SyntaxKind.ArrayLiteralExpression:\n            return true;\n        default:\n            return false;\n    }\n}\n"}